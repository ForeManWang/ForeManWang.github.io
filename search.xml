<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[联系方式网页跳转]]></title>
    <url>%2F%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[联系方式网页跳转 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 1 场景 网页上经常出现点击网页QQ跳转到网页形式的聊天界面，点击电话，直接拨&gt; 打电话等情况，想必大家都不陌生，下面贴出几个简单的实现，可直接复制粘贴到您的代码中使用 2 移动电话网页跳转 移动端使用较多，可自行去移动端测试 JS实现一键拨号的电话拨打： 1&lt;a href="tel:18818595048"&gt;点击我直接拨打电话或者手机拨打电话18818595048&lt;/a&gt; 实现效果：点击我直接拨打电话或者手机拨打电话18818595048 JS实现一键发送短信：1&lt;a href="sms:13764567708"&gt;点击我直接发送短信&lt;/a&gt; 实现效果：点击我直接发送短信 移动端使用wtai协议进行拨打电话：12&lt;a href="wtai://wp//mc;18818595048"&gt;拨打10010 &lt;/a&gt;&lt;a href="wtai://wp/ap;18818595048"&gt;将10010存储至电话簿 &lt;/a&gt; 实现效果：拨打10010 将10010存储至电话簿 3 QQ网页跳转1&lt;a target="_blank" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1281876368&amp;site=qq&amp;menu=yes"&gt;点击此处和我聊天或者添加我的QQ1281876368&lt;/a&gt; 实现效果：点击此处和我聊天或者添加我的QQ1281876368]]></content>
      <tags>
        <tag>QQ网页跳转</tag>
        <tag>电话网页跳转</tag>
        <tag>点击拨打电话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发之CMD规范]]></title>
    <url>%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B9%8BCMD%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[模块化开发之CMD规范 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 概念 CMD(Common Module Definition)，通用模块定义，它解决的问题和AMD规范是一样的，只不过在模块定义方式和模块加载时机上不同，CMD也需要额外的引入第三方的库文件，SeaJS SeaJS SeaJS推崇一个模块一个文件 定义模块 define 是一个全局函数，用来定义模块 语法： 1define define(id?, deps?, factory) 参数： id：可选，字符串类型，模块标识，如果没有提供参数，默认为文件名 dependencies：可选，字符串数组，当前模块依赖的模块，CMD 推崇依赖就近 factory：回调函数，工厂方法，初始化模块需要执行的函数或对象，如果为函数，它只被执行一次，如果是对象，此对象会作为模块的输出值 12345678910111213141516// cmd1.jsdefine(function(require,exports,module)&#123; // ... module.exports=&#123; // .. &#125;&#125;)// cmd2.jsdefine(function(require,exports,module)&#123; var cmd2 = require('./cmd1') // cmd2.xxx 依赖就近书写 module.exports=&#123; // ... &#125;&#125;) 除了给 exports 对象增加成员，还可以使用 return 直接向外提供接口 加载模块 SeaJS提供了seajs.use来加载模块 语法： 1seajs.use([dependencies], function()&#123;&#125;) 参数： dependencies：字符串数组，该模块的依赖 function：Function类型，所依赖的模块都加载成功之后，回调，依赖的模块会以参数的形式传入该函数，从而在回调函数内部就可以使用这些模块 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="sea.js"&gt;&lt;/script&gt; &lt;script src="cmd2.js"&gt;&lt;/script&gt; &lt;script src="cmd1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; seajs.use(['cmd2.js','cmd1.js'],function(cmd2,cmd1)&#123; // .... &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 文章推荐 模块化开发之AMD规范 模块化开发之CommonJS规范 ES6中Module语法与加载实现 浅谈模块化开发 参考文章 玉伯大大关于AMD 和 CMD 的区别有哪些的回答 github上的CMD 模块定义规范 一位道友的AMD和RequireJS初识 – 模块加载系列]]></content>
      <tags>
        <tag>模块化开发之CMD规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发之AMD规范]]></title>
    <url>%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B9%8BAMD%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[模块化开发之AMD规范 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 概念 AMD(Asynchronous Module Definition)，异步模块定义：它是在浏览器端实现模块化开发的规范。由于该规范不是原生js支持的，使用AMD规范进行开发的时候需要引入第三方的库函数，也就是鼎鼎大名的RequireJS RequireJS RequireJS主要解决了两个问题： 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 定义模块 RequireJS定义了一个define函数，用来定义模块 语法： 1define([id], [dependencies], factory) 参数： id：可选，字符串类型，定义模块标识，如果没有提供参数，默认为文件名 dependencies：可选，字符串数组，AMD 推崇依赖前置，即当前模块依赖的其他模块，模块依赖必须在真正执行具体的factory方法前解决 factory：必需，工厂方法，初始化模块需要执行的函数或对象。如果为函数，它只被执行一次。如果是对象，此对象会作为模块的输出值 123456789101112131415// mod1.jsdefine('mod1',[],function()&#123; // ... return &#123; // ... &#125;&#125;)// mod2.jsdefine('mod2', ['mod1'], function (mod1) &#123; // ... return &#123; // .... &#125;&#125;) 模块的加载 加载模块需要使用require()函数 语法： 1require([dependencies], function()&#123;&#125;) 参数： dependencies：字符串数组，该模块的依赖 function：Function类型，所依赖的模块都加载成功之后，回调，依赖的模块会以参数的形式传入该函数，从而在回调函数内部就可以使用这些模块 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="require.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="mod1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="mod2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; require(['mod1','mod2'],function(mod1, mod2)&#123; // ... &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; require()函数加载依赖模块是异步加载，这样浏览器就不会失去响应 AMD模式开发 AMD模式开发的简单三层结构（基础库/UI层/应用层）： 定义无依赖的模块 12345678// base.jsdefine(function () &#123; return &#123; bas: function (sou, tar) &#123; // ... &#125; &#125;&#125;) 定义有依赖的模块 12345678// ui.jsdefine(['base'], function (base) &#123; return &#123; initPage: function () &#123; // ... &#125; &#125;&#125;) 1234// page.jsdefine(['data', 'ui'], function (data, ui) &#123; // ...&#125;) 定义数据对象模块 12345// data.jsdefine(&#123; users: [], numbers: []&#125;) 具名模块 123define('index', ['data','base'], function(data, base) &#123; // ...&#125;) 包装模块 123456define(function(require, exports, module) &#123; var base = require('base'); exports.show = function() &#123; // todo with module base &#125;&#125;) dependencies是可选参数，当用户不提供该参数时，实现 AMD的框架应提供默认值为[“require”，”exports”，“module”] 文章推荐 模块化开发之CMD规范 模块化开发之CommonJS规范 ES6中Module语法与加载实现 浅谈模块化开发 参考文章 玉伯大大在知乎上对于AMD 和 CMD 的区别的回答 github上的AMD 一位道友的AMD和RequireJS初识 – 模块加载系列]]></content>
      <tags>
        <tag>模块化开发之AMD规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发之CommonJS规范]]></title>
    <url>%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B9%8BCommonJS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[模块化开发之CommonJS规范 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 前言随着网站开发的复杂度越来越高，不管是前台还是后台的js文件都越来越多，就出现了几个问题： 变量命名冲突 文件依赖复杂度增高 页面载入过多依赖傻傻分不清，不利于维护 NodeJS 模块化开发解决以上问题妥妥的，NodeJs模块化开发遵循CommonJS规范 CommonJS 模块化最初产生于服务端，并引申到客户端，CommonJS由Node推广 定义模块 在CommonJS规范中，一个单独的JS文件就是一个模块 每个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性 模块导出和载入 模块导出：exports 和 module.exports 模块载入：require 在 Node 中，每个模块内部都有一个自己的 module 对象 该 module 对象中，有一个成员叫：exports 也是一个对象 通过exports对象导出当前方法或者变量，也可以通过module.exports导出 Node 为了简化程序员的操作，专门提供了一个变量：exports 等于 module.exports，相当于在模块中还有这么一句代码var exports = module.exports 所以，语法： 导出多个成员：exports.xxx = xxx 或者 module.exports = { } 到处单个成员：module.exports 下面是模拟一个模块的导出 12345678910111213141516// math.js 该模块专门处理计算方面的操作 ，从该模块导出// 1. 如果一个模块需要直接导出某个成员，而非挂载的方式module.exports = 'hello'module.exports = function (x, y) &#123; return x + y&#125;// 2. 将上述两次导出合成一次的写法module.exports = &#123; add: function (x, y) &#123; return x + y &#125;, str: 'hello'&#125; 下面是模拟一个模块的载入以及require加载顺序 首先我们先去创建几个模块用来做模拟a.js，b.js，main.js 12345// a.jsconsole.log('a.js 被加载了')var fn = require('./b')console.log(fn) 123456// b.jsconsole.log('b.js 被加载了')module.exports = function () &#123; console.log('hello bbb')&#125; 12345require('./a')var fn = require('./b')console.log(fn) 分析与结论： 我们看上面三个模块中的代码，他们在后续的程序处理过程中可能会产生依赖，但是在没有加载之前，他们是相互独立的，互不影响 require优先从缓存中加载 看上面的代码，在main.js中提前加载了a.js，同时在a.js和main.js中加载b.js，由于a.js已经加载过b.js了，所以在main.js加载b.js的时候只是能拿到借口对象，但是不会重复执行里面的代码，这样做的好处是避免了重复加载，提高模块效率 .js文件后缀可以省略 文章推荐 模块化开发之AMD规范 模块化开发之CMD规范 ES6中Module语法与加载实现 浅谈模块化开发]]></content>
      <tags>
        <tag>模块化开发之CommonJS规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈模块化开发]]></title>
    <url>%2F%E6%B5%85%E8%B0%88%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[浅谈模块化开发 欢迎访问我的博客，祝所有码农同胞们早日走上人生巅峰，迎娶白富美~~ 前言 前段时间做的项目，其中也用到了模块化编程的思路，所以就想来总结下，方便以后使用，欢迎道友们踩点 什么是模块化 将一个项目按照功能划分，理论上一个功能一个模块，互不影响，在需要的时候载入，尽量遵循高内聚低耦合，关于高内聚低耦合可以看我的另一篇博客ES6中的Symbol中的章节1.4中有对耦合性和内聚性的解释 引入模块化的意义 以往在javascript中，没有明确的模块化的概念，不能够将一个大的项目分成一些相互依赖的小文件，这对于项目的开发就很难受，看看以往我们载入js文件 123456&lt;script src = '1.js'&gt;&lt;/script&gt;&lt;script src = '2.js'&gt;&lt;/script&gt;&lt;script src = '3.js'&gt;&lt;/script&gt;&lt;script src = '4.js'&gt;&lt;/script&gt;&lt;script src = '5.js'&gt;&lt;/script&gt;&lt;script src = '6.js'&gt;&lt;/script&gt; 这里解释一下src，想必很多人都知道，src相当于下载文档，且当执行src嵌入文件时，下面的程序都不会执行，将src指向的内容嵌入到文档标签所在位置，向更加深入理解移步这里src和href的区别 那么我们理解了src是直接嵌入内容到指定标签之后再去加载很多js文件，就会知道，它会产生很多问题： 变量冲突，脚本过多，不利于维护等 必须按照严格的依赖文件顺序 src对文件的加载时必须要将当前src加载的文件加载完成才会执行下面的代码，当过多的脚本载入页面，就增加了页面等待时间，影响用户体验 由于诸如以上的原因，引入模块化的解决方案 CommonJS请移步我的另一篇博客模块化开发之CommonJS规范 AMD 规范请移步我的另一篇博客模块化开发之AMD规范 CMD规范请移步我的另一篇博客模块化开发之CMD规范 AMD VS CMD 依赖规范：AMD 依赖 RequireJS，而 CMD 依赖 SeaJS 依赖模块：AMD 是提前执行，CMD 是延迟执行，不过 RequireJS 从 2.0开始，也改成可以延迟执行（根据写法不同，处理方式不同） API职责：AMD 的 API默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一，比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API都简单纯粹 ES6中的Module请移步我的另一篇博客ES6中Module语法与加载实现 ES6 中的模块与 CommonJS 模块差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 模块是运行时加载，其中的require全部下载模块，ES6 模块是编译时输出接口，其中的import可以按需加载 参考文章 阮一峰老师的module语法 玉伯大大的AMD 和 CMD 的区别有哪些？]]></content>
      <tags>
        <tag>浅谈模块化开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中Module语法与加载实现]]></title>
    <url>%2FES6%E4%B8%ADModule%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[ES6中Module语法与加载实现 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 前言 在前三篇文章中一次介绍了CommonJS，AMD，CMD，他们都需要单独载入文件 在阮一峰老师的module一文中写到，ES6 在语言标准的层面上，实现的模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案 引入ES6模块的好处 静态加载是提高效率 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供 静态加载带来的好处commonJS require实际上是整体加载fs模块，然后在需要使用的时候使用 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs')// 等同于let _fs = require('fs')let stat = _fs.statlet exists = _fs.existslet readfile = _fs.readfile ES6 ES6中的import可以在编译时，按照需要去加载所需要的模块，这个时候就相当于只加载了大括号里的3个方法，相比上面CommonJS中使用require加载整个fs模块好很多 1import &#123; stat, exists, readFile &#125; from 'fs' ES6中Module语法 模块功能主要由两个命令构成：export和import export命令 规定对外接口 输出变量： 1234// poeple.jsexport var name = 'zhangsan'export var height = 180export var age = 18 上述代码认为是一个模块，利用export向外输出三个变量 也可以在大括号内一块输出 123456// poeple.jsvar name = 'zhangsan'var height = 180var age = 18export &#123; name, height, age &#125; 输出函数或类： 123export function add (x, y) &#123; return x + y&#125; 输出变量改别名： 利用as关键字 12345678function a1 () &#123;&#125;function a2 () &#123;&#125;function a3 () &#123;&#125;export &#123; a1 as s1, a2 as s2, a3 as s3&#125; import命令 加载模块 12345import &#123; name, height, age &#125; from './people.js'function getPeople () &#123; return `$&#123;name&#125; is $&#123;height&#125; cm`&#125; import语句可以选择性的只加载需要的模块，更加节省了资源 模块的整体加载 星号（*）指定一个对象，所有输出值都加载在这个对象上面 那上面的例子 1import * as people from './people.js' export default命令 从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出 1234// export-default.jsexport default function () &#123; console.log('foo')&#125; 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字 123// import-default.jsimport something from './export-default'something() // 'foo' 跨模块常量 const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法 1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from './constants';console.log(A); // 1console.log(B); // 3 ES6中的Module加载实现 在浏览器和 Node 之中加载 ES6 模块 浏览器加载 浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=&quot;module&quot;属性，以此属性告诉浏览器，这加载的是一个 ES6 模块 1&lt;script type="module" src="./foo.js"&gt;&lt;/script&gt; 该加载是异步加载，不会造成阻塞，按出现顺序加载，相当于H5中的defer 123&lt;script type="module" src="./foo.js"&gt;&lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type="module" src="./foo.js" defer&gt;&lt;/script&gt; 同样的可以使用async属性，但此时不按顺序加载，依然是异步的，只不过不知道会先加载哪一个 1&lt;script type="module" src="./foo.js" async&gt;&lt;/script&gt; 文章推荐 模块化开发之AMD规范 模块化开发之CMD规范 模块化开发之CommonJS规范 浅谈模块化开发 参考文章 阮一峰老师的ES6 标准入门]]></content>
      <tags>
        <tag>ES6中Module语法与加载实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简书左侧目录]]></title>
    <url>%2F%E7%AE%80%E4%B9%A6%E5%B7%A6%E4%BE%A7%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[欢迎访问我的博客，祝所有码农同胞们早日走上人生巅峰，迎娶白富美~~ 1 前言因为文章也发布了一些，而CSDN上的目录有点隐蔽，对于初学者可能找不到，简书上我到现在也没找到目录的位置，所以本来初衷是要找简书和CSDN自动生成目录的解决方案的，CSDN的很好搞定，下面就先从CSDN说起 2 CSDN上自动生成目录 前提：你是用markdown写的具有h1-h6任意标题的 利用 markdown语法，现在你去尝试打开你的CSDN博客在线边界页面，往你想插入目录的位置写上一句代码@[TOC](文章目录)试试，结果就发现你的文章自动生成了目录 3 简书markdown自动生成目录 简书上的自动生成目录本来是找到了3个解决方案，有些不太合适我需要的，&gt; 有些文件是我网速太渣？反正下不下来，感兴趣的可以试试，我在下面贴出&gt; &gt; 网址，不感兴趣的跳过此段，往下看三篇文章见这里： 实用帖 | 如何为 Markdown 文件自动生成目录？，该文章介绍了利用VS Code内部扩展插件的方法，我去尝试了，目录是能出来，但是还是乱的，所以我没去用 简书makedown自动生成目录，该文章作者发布在github上的开源项目，并一直在维护，可惜我尝试了好多浏览器，两种网络环境都没下载下来 简书文章左侧目录(带滚动)，改文章写的内容是如何让自己看文章看的舒适，本来我的初衷是想让读者舒适的阅读的，那么既然读者暂时没解决，先让自己舒适吧，我就参照了这篇文章，安装了一个脚本，这样简书的文章读起来，有目录了，果然爽多了 4 简书文章左侧目录 讲这个之前，我们先介绍两个超级无比爆炸强大的插件插件下载请前往这里点击这里网盘下载 包含了两个插件：Tampermonkey：大家都叫他油猴脚本，很强大，可以编写任何你能想到的脚本到这个插件中，下面也要用到Chrome插件伴侣：自动安装插件到Chrome，一个字，爽！ 安装好了上述插件之后，请移步https://www.jianshu.com/p/ef9e3fe143c3这里有最详细的方法]]></content>
      <tags>
        <tag>简书markdown自动生成目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中的Symbol]]></title>
    <url>%2FES6%E4%B8%AD%E7%9A%84Symbol%2F</url>
    <content type="text"><![CDATA[ES6中的Symbol 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 声明：本文参考业界大佬阮一峰老师的Symbol 引入Symbol的好处 为解决属性名冲突问题而生 ES5 中方法和属性的命名： 以前，我们给一个对象下的方法或者属性命名的时候，可能会与该对象原有的方法或者属性产生冲突，这样的场景想必大家也很熟悉，我们常用到的解决办法是将方法前加一段项目名称的简拼或者一些其他的方式，其根本原因就是给方发或者属性带上一个独一无二的标志，最大限度的防止命名上的冲突 ES6 中方法和属性的命名： ES6中引入了Symbol数据类型，其基本解决思路也是和ES5差不多的，只不过就是直接利用Symbol能够表示一个独一无二的值，这就从根本上防止方法或者属性名的冲突 Symbol基本概念 Symbol是ES6中引入得一种新型的数据类型，它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值Boolean、字符串String、数值Number、对象Object` 基本用法 下面一个简单的例子说明如何生成Symbol值 12let a = Symbol()typeof a // 'symbol' Symbol值通过Symbol()函数生成，且凡是属性名属于&#39;symbol&#39;类型就不会与其他属性名冲突，我们来看看下面一个例子 123let a1 = Symbol()let a2 = Symbol()a1 === a2 // false 看起来仿佛一模一样的a1和a2实际上是不相等的，这进一步说明了Symbol值是独一无二的 Symbol 中的参数 Symbol函数中可以传参，只用以描述Symbol实例，为了在控制台输出时利于区分 12345let a1 = Symbol('foo')let a2 = Symbol('bar')a1 // Symbol(foo)a2 // Symbol(bar) 上述代码： 若不加参数，虽然二者都是独一无二的，二者是不一样的，这在上面的例子中也提到过，但是他们在控制台打印的结果却都是Symbol() 现在给他们分别加上参数，在控制台打印出来就能一眼辨别了 那么加上参数，若参数是一样的，说明描述也一样，那他们的Symbol值相等吗？看下面一个例子 1234567let a1 = Symbol('foo')let a2 = Symbol('foo')a1 // Symbol(foo)a2 // Symbol(foo)a1 === a2 // false 可见，依然不相等，这又进一步的证明了，Symbol值的独一无二 Symbol 转换 请看下面的四个例子，对应这四点： Symbol 值可以显式转为字符串 Symbol 值也可以转为布尔值 Symbol 值不能转为数值，且不能做数值运算 Symbol 值不能与其他类型的值进行运算 123let a1 = Symbol('foo')String(a1) // 'Symbol(foo)'a1.toString // 'Symbol(foo)' 123let a1 = Symbol('foo')Boolean(a1) // true!a1 // false 123let a1 = Symbol('foo')Number(a1) // TypeErrora1 + 1 // TypeError 12let a1 = Symbol('foo')'hello' + a1 // TypeError: can't convert symbol to string Symbol 值作为属性名 由于Symbol值的独一无二，将其作为对象的属性以防止属性名冲突问题再合适不过了 注意：关于下面例子中Object.definproperty： 该方法会直接在一个对象上定义一个新对象，或者修改一个对象的现有属性，并返回这个对象 语法：Object.defineProperty(obj, prop, descriptor) 参数： obj：要在obj上定义属性，就写obj prop：要修改的属性 descriptor：属性值 例如下面例子中的：Object.definproperty(obj3, a, { value: &#39;我是symbol值a作为obj对象的属性&#39; })表示在对象obj3上修改属性prop，其属性值修改为&#39;我是symbol值a作为obj对象的属性&#39; 123456789101112131415let a = Symbol()// 写法一let obj1 = &#123;&#125;obj1[a] = '我是symbol值a作为obj对象的属性'// 写法二let obj2 = &#123; [a]: '我是symbol值a作为obj对象的属性'&#125;// 第三种写法let obj3 = &#123;&#125;Object.definproperty(obj3, a, &#123; value: '我是symbol值a作为obj对象的属性' &#125;)obj1[a] // '我是symbol值a作为obj对象的属性'obj2[a] // '我是symbol值a作为obj对象的属性'obj3[a] // '我是symbol值a作为obj对象的属性' 注意：不能像以前对象那样用.运算 12345let a = Symbol()let obj = &#123;&#125;obj[a] = '我是symbol值a作为obj对象的属性'obj[a] // '我是symbol值a作为obj对象的属性'obj.a // undefined 注意：在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中 1234let a = Symbol()let obj = &#123; [a]: function(x) &#123; ... &#125;&#125; 也可以简写为 123456let a = Symbol()let obj = &#123; [a](x) &#123; ... &#125;&#125;// 调用obj[a](1) Symbol 类型定义常量 定义一组常量，保证这组常量的值都是不相等的 123456const obj = &#123;&#125;obj.alw = &#123; DEBUG: Symbol('debug'), INFO: Symbol('info'), WARN: Symbol('warn') &#125; Symbol 消除魔术字符串 先解释几个名词： 什么叫魔术字符串：在代码中多次出现，且与代码形成强耦合的某一个具体的字符串或者数值，这种关联性太多的字符串就会导致变量含义不明确，所以应当尽量消除魔术字符串，改由含义清晰的变量代替 耦合性：常用来表示块之间的联系，耦合性越强，其代码块或者模块之间的联系就越强，设计代码块或者模块就是为了其功能的独立性，所以往往更希望低耦合 内聚性：常用来表示块内在的联系，内聚性越强，模块功能强度越强，即一个模块内各元素（语名之间、程序段之间）联系的就越紧密，所以一般就更希望高内聚 看了以上几个名词解释想必就能清晰地理解上面的魔术字符串了吧，简单粗暴的讲就是这样的变量出现多次，就和代码形成了强大的联系，不利于以后的修改和维护，下面的几个例子借用了阮一峰老师在《ES6标准入门第3版》中的例子 1234567891011121314function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case 'Triangle': // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ &#125; return area;&#125;getArea('Triangle', &#123; width: 100, height: 100 &#125;); // 魔术字符串 常用的消除魔术字符串的方法，就是把它写成一个变量，这种方法也叫变量本地化，这样假如需要维护和修改就只需要修改最初定义的变量的值就行了 123456789101112131415const shapeType = &#123; triangle: 'Triangle'&#125;;function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值 123const shapeType = &#123; triangle: Symbol()&#125;; 属性名的遍历 ES6中提供有Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值 1234567let a = Symbol('a')let b = Symbol('b')let obj = &#123;&#125;obj[a] = 'hello'obj[b] = 'world'const objs = Object.getOwnPropertySymbols(obj)objs // [Symbol(a), Symbol(b)] Symbol.for() 若想使用同一个Symbol值，就用Symbol.for() 方法 1234567891011let a1 = Symbol.for('a')let a2 = Symbol.for('a')a1 === a2 // truelet a1 = Symbol.for()let a2 = Symbol.for()a1 === a2 // truelet a1 = Symbol.for('a')let a2 = Symbol.for('b')a1 === a2 // false 看上述例子，请注意，当参数两个需要重用的值参数要不然都不写，要不然一定要一样，否则二者不会相等 Symbol.keyFor() Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key 1234567891011// Symbol.for 有参数let a1 = Symbol.for('a')Symbol.keyFor(a1) // "a"// Symbol.for 无参数let a1 = Symbol.for()Symbol.keyFor(a1) // undefined// 无 Symbol.for 表明未登记let a1 = Symbol()Symbol.keyFor(a1) // undefined 从上述代码看出，往往返回的就是那个参数，但是当没有参数或者没有使用Symbol.for()方法的时候返回undefined 其他 剩下的一些内容，本来我自己也接触比较少，就没在这里写，详细请移步Symbol]]></content>
      <tags>
        <tag>ES6中的Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中的class关键字]]></title>
    <url>%2FES6%E4%B8%AD%E7%9A%84class%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[ES6中的class关键字 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 声明：本文参考业界大佬阮一峰老师的ES6标准入门 ES5 中的面向对象12345678910111213// 创建一个构造函数function People (name, age) &#123; this.name = name this.age = age&#125;// 向构造函数的原型对象中添加 say 方法People.prototype.say = function () &#123; return 'hello everyone'&#125;// 实例化 People 构造函数，并保存在变量 a 中var a = new People('zhangsan', 10) ES6 中的 class 关键字 用 ES6 中的 class 类去改写上面的例子看看 123456789class People &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; say() &#123; return 'hello everyone' &#125;&#125; 两个例子可以说实际功能一模一样，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象，且方法之间不需要逗号分隔，加了会报错 ES6 的 class 类，完全可以看作构造函数的另一种写法，证明如下： 123class People &#123; &#125;typeof People // "function"People.prototype.constructor === People // true 类的实例 同样的，也是用new 关键字 12345678910class People &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; say() &#123; return 'hello everyone' &#125;&#125;var people = new People('zhangsan', 18) 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上） 类的所有实例共享一个原型对象 123456789101112class People &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; say() &#123; return 'hello everyone' &#125;&#125;var people1 = new People('zhangsan', 18)var people2 = new People('zhaosi', 20)people1._proto_ === people2._proto // true 这就意味着可以通过实例的__proto__属性为“类”添加方法 12345678910111213141516class People &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; say() &#123; return 'hello everyone' &#125;&#125;var people1 = new People('zhangsan', 18)var people2 = new People('zhaosi', 20)people1._proto_.eat = function () &#123; return 'banner'&#125;people1.eat() // 'banner'people2.eat() // 'banner' 取值函数（getter）和存值函数（setter） 案例借用阮一峰老师的《ES6标准入门》 1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, "html");"get" in descriptor // true"set" in descriptor // true 存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致 一些需要注意的点不存在变量提升 类不存在变量提升 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 如上代码，定义Foo在后，使用在前，则报错 name 由于本质上，ES6 的类只是ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性 12class People &#123;&#125;People.name // "People" name属性总是返回紧跟在class关键字后面的类名 Generator 方法 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数 generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能，详细请移步廖雪峰老师的generator 12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125;// hello// world 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器，不断返回多次，一次打印出一个参数，直到遍历出所有的参数 this 类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错 1234567891011class People &#123; getPeople(name = 'zhangsan') &#123; this.print(`hello $&#123; name &#125;`) &#125; print(text) &#123; console.log(text) &#125;&#125;const people = new People()const &#123; getPeople &#125; = peoplegetPeople() // TypeError: Cannot read property 'print' of undefined 解决办法一：在constructor中绑定this 1234567891011121314class People &#123; constructor() &#123; this.getPeople = this.getPeople.bind(this) &#125; getPeople(name = 'zhangsan') &#123; this.print(`hello $&#123; name &#125;`) &#125; print(text) &#123; console.log(text) &#125;&#125;const people = new People()const &#123; getPeople &#125; = peoplegetPeople() // 'hello zhangsan' 解决方法二：使用箭头函数 1234567891011class People &#123; constructor() &#123; this.getPeople = (name = 'zhangsan') =&gt; this.print(`hello $&#123; name &#125;`) &#125; print(text) &#123; console.log(text) &#125;&#125;const people = new People()const &#123; getPeople &#125; = peoplegetPeople() // 'hello zhangsan' 静态方法 static关键字，带有static关键字的方法不会被继承，且实例不能调用，必须用过类直接调用 123456789101112class People &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; static say() &#123; console.log('say everyone') &#125;&#125;People.say() // 'hello everyone' var people = new Peoplepeople.say() // TypeError: people.say is not a function 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例 123456789101112class People &#123; static hello() &#123; this.say() &#125; static say() &#123; console.log('我是静态') &#125; say() &#123; console.log('我是非静态') &#125;&#125;People.hello() // 我是静态 静态属性 将static关键字，加在属性前面，即定义了静态属性 123class Foo &#123; static prop = 1;&#125; 私有方法 私有方法是常见需求，但 ES6不提供，只能通过变通方法模拟实现 方法一：在命名上加以区别 1234567891011class People &#123; // 公有方法 foo (name) &#123; this._getName(name) &#125; // 私有方法 _getName(name) &#123; return this.peop = name &#125;&#125; 上面代码中，getName方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法 方法二：将私有方法移出模块 12345678910class People &#123; // 公有方法 foo (name) &#123; getName.call(this, name) &#125;&#125;// 私有方法getName(name) &#123; return this.peop = name&#125; 上述代码中，利用call使this即foo调用了getName方法，这使得getName实际上成为了当前模块的私有方法 方法三：Symbol 值的唯一性 对于 Symbol 可以参考ES6中的Symbol 12345678910111213const a = Symbol('a')const b = Symbol('b')export default class People &#123; // 公有方法 foo (name) &#123; this[a](name) &#125; // 私有方法 [a](name) &#123; return this[b] = name &#125;&#125; 私有属性 请参照http://es6.ruanyifeng.com/#docs/class 类的继承 Class 可以通过extends关键字实现继承，先看个例子 extends1234567891011121314151617181920// 这是父类class Person &#123; constructor(name, age)&#123; this.name = name this.age = age &#125;&#125;// 这是子类 美国人 可继承父类的一些属性和方法class American extends Person &#123;&#125;const a1 = new American('Jack', 20)console.log(a1.name) // Jack// 这是子类 中国人 可继承父类的一些属性和方法class Chinese extends Person&#123;&#125;const c1 = new Chinese('张三', 22)console.log(c1.name) // 张三 super 既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同 情况一：super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数 123456789101112131415161718192021222324252627282930313233343536373839// 这是父类class Person &#123; constructor(name, age)&#123; this.name = name this.age = age &#125; // 打招呼 的 实例方法 sayHello()&#123; console.log('大家好') &#125;&#125;// 这是子类 美国人 class American extends Person &#123; constructor(name, age)&#123; super(name, age) &#125;&#125;const a1 = new American('Jack', 20)console.log(a1)a1.sayHello()// 这是子类 中国人class Chinese extends Person&#123; // name 姓名 // age 年龄 // IDNumber 身份证号 【中国人独有的】，既然是独有的，就不适合 挂载到 父类上； constructor(name, age, IDNumber)&#123; super(name, age) this.IDNumber = IDNumber &#125;&#125;const c1 = new Chinese('张三', 22, '130428******')console.log(c1)c1.sayHello() 注意： 如果需要添加自己独有的属性，则不能挂在到父类上 在子类中， this 只能放到 super 之后使用 情况二：super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类 12345678910111213141516171819202122// 这是父类class Person &#123; constructor(name, age)&#123; this.name = name this.age = age &#125; // 打招呼 的 实例方法 sayHello()&#123; console.log('大家好') &#125;&#125;// 这是子类 美国人 class American extends Person &#123; constructor(name, age)&#123; super(name, age) console.log(super.sayHello()) &#125;&#125;let amer = new American() 上面代码中，子类American当中的super.sayHello()，就是将super当作一个对象使用。这时，super在普通方法之中，指向Person.prototype，所以super.sayHello()就相当于Person.prototype.sayHello()。]]></content>
      <tags>
        <tag>ES6中的class关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 新特性]]></title>
    <url>%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[ES6 新特性 欢迎访问我的博客https://qqqww.com/，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 声明：本文参考文章如下： 业界大佬阮一峰老师的ES6标准入门 一位道友的理解 JavaScript 中的 for…of 循环 github上的You-Dont-Know-JS Babel 转码请移步我的另一篇博客ES6-Babel转码 声明变量 在 ES6 中常用 let 或 const 来声明变量，下面介绍 let 和 const let ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效 引入 let 的好处 我们在 ES5 中使用 var 来声明变量，但是var的变量提升往往会带来一些问题： 1234567// 使用 varconsole.log(a) // 输出 undefinedvar a = 1// 使用 letconsole.log(b) // 输出 ReferenceErrorlet b = 1 一般我们认为应该先声明变量再使用，但是这里使用var声明的变量却能提前使用，而不报错，本身在逻辑性上可能会觉得不太好，但是还没有看到具体会引起什么错误，那么再看下面的代码： 123456789var a = new Date() // Tue Jan 29 2019 20:31:15 GMT+0800 (中国标准时间)function fn () &#123; cosole.log(a) if (false) &#123; a = 'hello' console.log(a) &#125;&#125;fn() // undefined 上述代码由于if代码块使用内层的变量，外面的使用外层的变量，看似互不影响，但是由于var存在变量提升，导致内层的a覆盖了外层的a，甚至有可能将局部变量提升为全局变量，以后有可能引起内存泄漏 所以引入let，let声明的变量有自己独立的作用域块，let声明的变量只在let所在的块内起作用，不再受外部影响，形成暂时性死区，有效防止变量提升问题 暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的 我们将上述代码中的 var 换为 let 看看 123456789let a = new Date() // Tue Jan 29 2019 20:31:15 GMT+0800 (中国标准时间)function fn () &#123; cosole.log(a) if (false) &#123; a = 'hello' console.log(a) &#125;&#125;fn() // Tue Jan 29 2019 20:31:15 GMT+0800 (中国标准时间) 这时候就不存在变量提升的问题了 let 规则 使用let声明的变量可以重新赋值,但是不能在同一作用域内重新声明 const const 和 let 引入的好处基本一样，但是为什么还要引入呢？看看下面的 const 规则： 使用const声明的变量必须赋值初始化,但是不能在同一作用域类重新声明也无法重新赋值 它们的区别就在于规则，其他几乎一模一样 模板字面量 ES6中的模板字面量就是通过一种更加简便的方法去拼接字符串，在以前我们常通过+或者concat()等方法去拼接字符串 123456789const dog1 = &#123; name: 'dahuang', age: 10&#125;const dog2 = &#123; name: 'xiaohei', age: 10&#125;let mes = dog1.name + 'and' + dog2.name + 'are dog' 下面用模板字面量去拼接字符串 1let mes = `$&#123;dog1.name&#125; and $&#123;dog2.name&#125; are dog` 一对反引号搞定 解构赋值 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） 以前为变量赋值，只能直接指定值，下面来自阮一峰老师的文档里的一个小例子 123let a = 1let b = 2let c = 3 ES6 允许下面这样 1let [a, b, c] = [1, 2, 3] 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错 12let &#123; prop: x &#125; = undefined // TypeErrorlet &#123; prop: y &#125; = null // TypeError 数组的解构赋值123const arr = [1, 2, 3]const [a, b, c] = arrconsole.log(a, b, c) // 1, 2, 3 对象的解构赋值12let &#123; foo1, foo2 &#125; = &#123; foo1: 'a', foo2: 'b' &#125;// foo1 =&gt; 'a' foo2 =&gt; 'b' 对象字面量的写法： 1234let name = 'dahuang'let color = 'yellow'const dog = &#123;name, color&#125;console.log(dog) 字符串的解构赋值123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值 函数参数的解构赋值12345function add([x, y])&#123; return x + y&#125;add([1, 2]) // 3 函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y 我们用Babel在线转换工具把上述ES6代码转化为ES5代码看看，实际上就是讲作为参数的数组分别结构成了x和y再返回他们的和 12345678910111213"use strict";var _slicedToArray = function () &#123; function sliceIterator(arr, i) &#123; var _arr = []; var _n = true; var _d = false; var _e = undefined; try &#123; for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) &#123; _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; &#125; &#125; catch (err) &#123; _d = true; _e = err; &#125; finally &#123; try &#123; if (!_n &amp;&amp; _i["return"]) _i["return"](); &#125; finally &#123; if (_d) throw _e; &#125; &#125; return _arr; &#125; return function (arr, i) &#123; if (Array.isArray(arr)) &#123; return arr; &#125; else if (Symbol.iterator in Object(arr)) &#123; return sliceIterator(arr, i); &#125; else &#123; throw new TypeError("Invalid attempt to destructure non-iterable instance"); &#125; &#125;; &#125;();function add(_ref) &#123; var _ref2 = _slicedToArray(_ref, 2), x = _ref2[0], y = _ref2[1]; return x + y;&#125;add([1, 2]); // 3 其他 当然对于解构赋值还有很多新玩法，例如可以添加默认值，这里阮一峰老师写的很详细，请移步ES6标准入门 for…of for...of 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 for...of 循环，以替代 for...in 和 forEach() ，并支持新的迭代协议。for...of 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等 我们先来看看以前的方法 for 循环 1234let arr = [1, 2, 3, 4, 5, 6]for (let i = 1; i &lt; arr.length; i++) &#123; console.log(arr[i])&#125; 缺点：需要跟踪计时器和退出条件 虽然 for 循环在循环数组时的确具有优势，但是某些数据结构不是数组，因此并非始终适合使用 loop 循环 for…in循环 1234let arr = [1, 2, 3, 4, 5, 6]for (const index in arr) &#123; console.log(arr[index])&#125; 缺点： for...in 循环循环访问所有可枚举的属性，意味着如果向数组的原型中添加任何其他属性或者方法，这些属性或方法也会出现在循环中，这就无意间浪费了资源 forEach()循环 数组方法，只用于数组中，局限性大 for…of循环 12345const arrs = [1, 2, 3, 4, 5, 6]for (const arr of arrs) &#123; console.log(arr)&#125;// 可忽略索引 而且可以随时退出或者停止for…of循环 1234567const arrs = [1, 2, 3, 4, 5, 6]for (const arr of arrs) &#123; if (arr % 2 === 0) &#123; continue &#125; console.log(arr)&#125; 且不用担心向对象中添加新的属性。for…of 循环将只循环访问对象中的值 展开运算符 ES6中提供了展开运算符为... 12const dogs = ['dahuang', 'xiaohei', 'xiaobai']console.log(...dogs) // dahuang xiaohei xiaobai 数组拼合12345const dogs = ['dahuang', 'xiaohei', 'xiaobai']const peoples = ['xiaoming', 'zhangsan', 'zhaosi', 'wangwu'] const animals = [...dogs, ...peoples] console.log(animals) // ['dahuang', 'xiaohei', 'xiaobai', 'xiaoming', 'zhangsan', 'zhaosi', 'wangwu'] 这实际上已经完成了以前拼合数组使用的concat()的功能 剩余参数 使用展开运算符将数组展开为多个元素, 使用剩余参数可以将多个元素绑定到一个数组中 将变量赋数组值 1234const goods = [20, 200, 'pen', 'book', 'ruler']const [price, totalCount, ...studyGoods] = goodsconsole.log(price, totalCount, studyGoods) // 前两个参数对应前两个，后面的作为数组传入 studyGoods 可变剩余参数作为函数形参使用 1234567function add (...numbers) &#123; let sum = 0 for (const number of numbers) &#123; sum += number &#125; return sum&#125; ES6 箭头函数 箭头函数是 ES6中的一大亮点 ，下面看简单的 ES5 中的函数 和 ES6 中的箭头函数 ES5 中的函数 1var fn = function () &#123; console.log('我是es5') &#125; ES6中的箭头函数 123const fn = () =&gt; &#123; console.log('我是es6') &#125;// 等价于const fn = () =&gt; console.log('我是es6') 就是讲ES5中的function（）去掉，变成() =&gt;，且当函数体只有一句程序的时候，大括号也能省略 比较ES5中的函数和箭头函数： 前者可以使函数声明或者函数表达式，但是后者只能是函数表达式，因此只在表达式有效的时候才能使用 什么是表达式有效时？ 存储在变量中 当做参数传递给函数 存储在对象属性中 存储在变量中的时候 其实上面的例子也说明了这点，下面再举两个简单的例子 123const fn = numbers =&gt; `The pen are $&#123; numbers &#125;`// 调用fn(200) // The pen are 200 1const people = (name, age) =&gt; console.log(`$&#123; name &#125; is $&#123; age &#125; years old`) 当做参数传递给函数的时候 将函数表达式当做参数传递给map函数，一般就是用于需要回调的函数 1const people = ['zhangsan', 'zhaosi', 'wangwu'].map(name =&gt; name.toUpperCase()） 存储在对象属性中的时候123456const people = &#123; name: 'zhangsan', age: 10, say: () =&gt; console.log('hello')&#125;console.dir(people.say) // say() 方法 箭头函数与this 对于普通函数,this的值基于函数如何被调用, 对于箭头函数,this的值基于函数周围的上下文, 换句话说,this的值和函数外面的this的值是一样的 普通情况下的this new对象， 1const time = new Date() // 此时的this是Date()构造函数的实例对象 上下文 1window.setTimeout() // 函数`setTimeout()`是对象`window`下的方法，此时this指向window 指定的对象 123const arr = Array.prototype.slice.call(arr1)const arr = Array.prototype.slice.apply(arr1)// call 或者 apply 第一个参数设置 this 指向，所以此时 this 指向 arr1 此外，this 指向还有很多其他的讲究，详细见You-Dont-Know-JS 箭头函数与this 我们首先来看一个例子 123456Array.prototype.init = function () &#123; console.log(this) setTimeout(function () &#123; console.log(this) &#125;, 1000)&#125; 这时候两次打印出来的 this 一样吗？执行Array.prototype.init()打印结果出来看一下： 很显然，第一个打印出了Array构造函数，第二个是Window，因为setTimeout()是Window的方法，所以会改变this指向，那么使用箭头函数看看 12345Array.prototype.init = function () &#123; console.log(this) setTimeout( () =&gt; console.log(this), 1000)&#125;Array.prototype.init() 这次就打印出了两个Array，this指向没有发生变化 应用场景 一些事件绑定之后需要操作原事件对象时防止this改变 用到一些构造函数的方法的时候，防止该构造函数的this被改变 等等…… Symbol 请移步我的另一篇博客ES6中的Symbol class类 请移步我的另一篇博客ES6中的class关键字 Promise 请移步我的另一篇博客node-读取文件方法封装 Module 请移步我的另一篇博客ES6中Module语法与加载实现 Proxy 拦截代理，即在目标对象外层包裹一层拦截，外接对对象的访问都必须要先通过这层拦截，有点过滤的感觉，也有点像“门卫”，小区进门之前都要先过“门卫” 语法1var proxy = new Proxy(target, handler) 参数 target：对象类型，表示需要被拦截的对象 handler：对象类型，表示需要对这个对象target要做的拦截操作 例子123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 如果handler没有设置任何拦截，那就等同于直接通向原对象 12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = 'b';target.a // "b"]]></content>
      <tags>
        <tag>ES6 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.offset(), .position(), .scrollTop(), .width(), .innerWidth(), .outerWidth()]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E8%B7%9D%E7%A6%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[一些距离属性和宽高属性 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 上篇文档总结了《一些坐标属性》，这里总结一些距离或者宽高属性，它们分别为：.offset().position().scrollTop()，.scrollLeft.width()，.height.innerWidth()，innerHeight().outerWidth()，outerHeight() .offset() .offset().top：元素距离文档上边的距离.offset().left：元素距离文档左边的距离当然也可以自己设置1234xxx.offset(&#123; left: 10, top: 10&#125;) .position() .position().top 和 .position().left: 与被定位的祖先元素的偏移距离 若父元素被定位了，则就是离父元素的偏移距离 反之，网上辈祖先找，如果没有祖先被定位，一般是相对于 body 偏移距离 .scrollTop()，.scrollLeft 滚动条滚动被卷去的距离：.scrollTop()：滚动条卷去的垂直距离.scrollLeft()：滚动条卷去的水平距离 .width()，.height 元素的宽度，不包含padding，border，margin，且支持写操作，例如$test.width(100) .innerWidth()，innerHeight() 元素的宽度，包含padding，不包含border与margin，且支持写操作，例如$test.innerWidth(100) .outerWidth()，outerHeight() 元素的宽度，包含padding和border，不包含margin 若.outerWidth(true)，此时连margin一块都包括了]]></content>
      <tags>
        <tag>.offset(), .position(), .scrollTop(), .width(), .innerWidth(), .outerWidth()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[e.clientX,e.clientY,e.pageX,e.pageY,e.offsetX,e.offsetY,e.screenX,e.screenY]]></title>
    <url>%2F%E5%87%A0%E4%B8%AA%E5%9D%90%E6%A0%87%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[e.clientX,e.clientY, e.pageX , e.pageY , e.offsetX , e.offsetY , e.screenX , e.screenY 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 声明：参考文档你是如何理解var e=e||window.event的 刚才写博客《javascript实现简单拖曳功能》的时候，用到了e.clientX这一类坐标属性，就想到把这一类相似的属性都整理一下，他们分别为e.clientX , e.clientYe.pageX , e.pageYe.offsetX , e.offsetYe.screenX , e.screenY e 是什么 这里先说一下 e 是什么 e 是给一个事件对象，可以在编写函数的时候，传入一个形参e，然后执行函数的时候传入一个实参，那么e这个时候就是这个作为实参的对象 var event = e || event 兼容性写法，这样写可能不太好理解，但是假如给他写成var event = event || window.event，或者写成var event = e ? event : window.event 想必就更好理解了 下面借用道友的一张图来说明一下针对于不同浏览器的兼容性问题很显然，在Firefox浏览器中仅支持event，而且Forefox支持对象参数的传入，但是IE6/7/8是不支持对象参数的传入的，所以此种方法保证对所有浏览器的兼容 e.clientX , e.clientY 鼠标相对于浏览器窗口可视区域的X，Y坐标，可视区域不包括工具栏和滚动条，IE事件和标准事件支持 e.screenX , e.screenY 上面讲了e.clientX , e.clientY，再讲e.screenX , e.screenY感觉再合适不过了，因为是鼠标相对于屏幕的坐标，包括浏览器上面的工具栏和滚动条，二者差别就在这，IE事件和标准事件支持 e.pageX , e.pageY 相对于文档的定位，文档的左上角为(0,0)，向右为正，向下为正，IE不支持 e.offsetX , e.offsetY 和e.pageX , e.pageY一模一样的功能，但是这两个属性只有IE支持 相关的一些写法 在文档中的位置Y坐标等于在可视区域的Y坐标加上滚动条垂直方向卷去的距&gt; 离：e.pageY = e.pageY || e.clientY + $(window).scrollTop()​(window).scrollTop()：浏览器滚动条滚动的垂直距离]]></content>
      <tags>
        <tag>e.clientX,e.clientY,e.pageX,e.pageY,e.offsetX,e.offsetY,e.screenX,e.screenY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript实现简单拖曳功能]]></title>
    <url>%2Fjavascript%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%8B%96%E6%9B%B3%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[javascript实现简单拖曳功能 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 场景：想必大家对这一类场景很熟悉，QQ登陆面板跟着鼠标的拖动，鼠标到哪它到哪，飞机大战小游戏里，鼠标或者手指到哪，飞机到哪，这一类场景用的很多，那么下面来简单实现一下： 思路： 在鼠标移动的时候，计算鼠标位置 给盒子一个绝对定位，将鼠标位置赋值给盒子 HTML 结构 12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div id="drag"&gt;想看效果？狠狠的拽我！！&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS 样式 1234567891011121314#drag&#123; width: 200px; height: 200px; background: yellow; color: red; font-size: 20px; font-weight: bold; position: absolute;/*这很关键*/ left: 40%; top: 37%;&#125;#drag:active&#123; cursor: move;&#125; 这时候就有了个黄底红字的大盒子，用 JS 去编写 鼠标按下，鼠标移动，鼠标抬起的事件驱动程序，实现拖曳效果 思路：将鼠标所在位置直接赋值给盒子的绝对定位的位置left和top 12345678910111213141516171819var oDrag = document.getElementById("drag")getDarg(oDrag)function getDarg(obj)&#123; //鼠标按下 obj.onmousedown = function(e)&#123; //鼠标移动 document.onmousemove = function(e)&#123; var event = e || event obj.style.left = event.clientX + 'px' obj.style.top = event.clientY + 'px' &#125; //鼠标放开 document.onmouseup = function()&#123; // 鼠标抬起的时候清空事件，有效避免内存泄漏 document.onmousemove = null document.onmouseup = null &#125; &#125; &#125; 这样实现了拖曳效果，但是很显然，这样鼠标拖曳按钮一直在黄盒子的左上角，体验很不好，那么就要合理的计算鼠标在盒子中的位置，鼠标在盒子中的位置计算可以用鼠标在可视区域的位置减去盒子绝对定位的位置 1234567891011121314151617181920212223var oDrag = document.getElementById("drag")getDarg(oDrag)function getDarg(obj)&#123; //鼠标按下 obj.onmousedown = function(e)&#123; // 兼容性处理 var event = e || event // 鼠标在盒子中的位置 var distanceX = event.clientX - this.offsetLeft var distanceY = event.clientY - this.offsetTop //鼠标移动 document.onmousemove = function(e)&#123; ... &#125; //鼠标放开 document.onmouseup = function()&#123; ... &#125; &#125; &#125; 这样就基本实现了需求，但是拖动的时候会不注意选中盒子上的文字，也影响用户体验，借助window和document下面的方法在拖曳盒子即移动鼠标的时候取消文本选中 1window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty() 这样就好多了 下面上完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src='./js/jquery-1.8.3.min.js'&gt;&lt;/script&gt; &lt;style type="text/css"&gt;#drag&#123; width: 200px; height: 200px; background: yellow; color: red; font-size: 20px; font-weight: bold; position: absolute;/*这很关键*/ left: 40%; top:37%;&#125;#drag:active&#123; cursor: move;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="drag"&gt;想看效果？狠狠的拽我！！&lt;/div&gt;&lt;script type="text/javascript"&gt;var oDrag = document.getElementById("drag")getDarg(oDrag)function getDarg(obj)&#123; //鼠标按下 obj.onmousedown = function(e)&#123; // 兼容性处理 var event = e || event // 鼠标在盒子中的位置 var distanceX = event.clientX - this.offsetLeft var distanceY = event.clientY - this.offsetTop //鼠标移动 document.onmousemove = function(e)&#123; var event = e || event // 着鼠标的拖曳移动 obj.style.left = event.clientX - distanceX + 'px' obj.style.top = event.clientY - distanceY + 'px' // 取消文本选中 window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty() &#125; //鼠标放开 document.onmouseup = function()&#123; // 鼠标抬起的时候清空事件，有效避免内存泄漏 document.onmousemove = null document.onmouseup = null &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 至此，简单拖曳功能完成，对应的如果开发移动端，只需要改上移动端的事件即可，例如touchstart ,touchmove,touchend, touchcancel等]]></content>
      <tags>
        <tag>javascript实现简单拖曳功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进增强和优雅降级]]></title>
    <url>%2F%E6%B5%85%E8%B0%88%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[浅谈渐进增强和优雅降级 欢迎访问我的博客https://qqqww.com/，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 声明：本文参考大佬张鑫旭老师和康斌老师的文章： CSS “渐进增强”在web制作中常见应用举例 渐进增强 VS 优雅降级 概念 渐进增强：先解决页面基本布局，再逐渐根据需求进行完善，张鑫旭老师在他的博客 CSS “渐进增强”在web制作中常见应用举例里举的例子，很有意思，说是农村包围城市的感觉优雅降级：先搭建一套针对于最高级浏览器最完善的功能的设计，再慢慢向下兼容，根据上面渐进增强里的例子，让我想到优雅降级有点让一部分人先富起来带动另一部分人富起来的感觉 应用场景 渐进增强和优雅降级都有其一些应用场景 渐进增强 农村包围城市的味道先说一个简单的例子，例如先完成了页面的基本布局，没有任何特效，那么加个小动画，加个文字阴影等，就是渐进增强了 CSS3 text-shadow 文字阴影属性：这个属性在之前做一些布局的时候，用的也很多，一些文字的白色阴影，这让我想到了box-shadow，当然张鑫旭老师在文章后面也提到了 CSS3 box-shadow 盒子阴影属性：这个属性就是我上面提到的，做卡片阴影的时候很好用，例如向京东购物的商品简单展示卡片，也可以看一下张鑫旭老师在他的文章中提到的Firefox的例子 CSS3 boder-radius 圆角属性：这个常用来制作按钮，或者应用到导航菜单上，显得十分美观，配合切换的时候圆角盒子高亮，提升用户体验 CSS3 gradient 渐变背景属性：渐变背景可以说是 CSS3 里一个强大如斯的功能了，线性渐变（linear-gradient）和径向渐变（radial-gradient），常见的应用场景，按钮，标题栏，一些搜索栏等效果，颜色平稳过渡，体验是极好的 CSS选择器、伪类：利用选择器和伪类实现的渐进增强也是十分巧妙，例如一个radio单选，点击单选，周围用伪类加上红色外圈，显得更为好看，且伪类不占空间，不影响布局，或者页面导航布局的分割线等 当然，其实渐进增强的例子有很多，比如CSS3 rotate() 旋转属性做鼠标经过图片旋转之类的动画，或者比如CSS3 transition() 过渡属性和CSS3 translate() 属性配合做购物车购物动画 等等，还有很多，具体的应用场景，我用的不够多，但是用的够多的话，像张老师将近十年经验应该就能随手举例一大把场景应用了吧，还可以参照我的CSS3新特性整理这篇博客里列举了很多常用的CSS3新特性，很多都是可以用到渐进增强上的优雅降级 让一部分人先富起来带动另一部分人富起来的感觉说一个简单的举例，例如CSS3 linear-gradient首先仅支持IE10 123#grad &#123; background: linear-gradient(red,yellow,blue);&#125; 再进行兼容其他浏览器，即优雅降级 123456#grad &#123; background: linear-gradient(to right, red , blue); /* 标准语法 */ background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 to 15 */ background: -o-linear-gradient(right, red, blue); /* Opera 11.1 to 12.0 */ background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 to 6.0 */ &#125; CSS3 中有很多属性是需要做优雅降级的，这里不举例 抉择根据你的客户的客户端版本决定： 若拥有低版本客户端的客户居多，则考虑渐进增强 反之，考虑优雅降级 最主要是为了提升用户体验 事实情况：绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。例如：新浪微博网站前端的更新，拥有这种亿级用户的网站，绝对不可能追求某个特效而不考虑低版本用户可不可用，一定是确保低版本到高版本的可访问性，再去渐进增强 个人观点：当然以上观点，个人觉得过于片面，一个项目就算是最初的演示版本，也不应该单单从用户体验去考虑问题吧 单谈技术的话： 技术方面，是否允许 对于SEO，是否友好 团队层面的话： 时间方面，是否充足 资金方面，是否充足 等等，其实有很多需要考虑的因素，由于我接触的还少，仅保留意见，以后更新，更欢迎道友们分享]]></content>
      <tags>
        <tag>渐进增强和优雅降级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步加载、异步加载和延迟加载和预加载]]></title>
    <url>%2Fjavascript%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%E3%80%81%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[同步加载、异步加载、延迟加载和预加载 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 同步加载 常默认的是同步加载 1&lt;script src="http://yourdomain.com/script.js"&gt;&lt;/script&gt; 同步模式又称阻塞模式，会阻止浏览器的后续操作，相当于阻止了后续的文件的解析，执行等。 流览器之所以会采用同步模式，是因为加载的js文件中有对dom的操作，重定向，输出document等默认行为，所以同步才是最安全的。 通常加载js文件或者放&lt;script&gt;标签都在结构最后面，也是因为它会阻止浏览器后续操作的原因，所以放在后面，当页面结构和样式全部渲染完成再执行js，提升用户体验 异步加载 异步加载又称非阻塞加载，浏览器在下载执行js的同时，还会继续进行后续页面的处理。主要有三种方式 async、await 这个是 ES7 中的特性，async顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成 详细可以参考这篇文章大佬的文章 onload 把插入script的方法放在一个函数里面，然后放在window.onload方法里面执行，这样就解决了阻塞onload事件触发的问题 H5 async 当浏览器解析到script脚本，没有defer或async时，defer在延迟加载中会说到 1&lt;script src="main.js"&gt;&lt;/script&gt; 浏览器会立即加载并执行指定的脚本，“立即”指在渲染该script标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行 当浏览器解析到script脚本，有async时 1&lt;script async src="main.js"&gt;&lt;/script&gt; 浏览器会立即下载脚本，但不妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。加载和渲染后续文档元素的过程和main.js的加载与执行并行进行，这个过程是异步的 延迟加载 有些代码在某种特定情况下才需要，并不是一股脑子都加载出来了，这个时候就需要延迟加载 这里也是 H5 的内容 H5 defer 当浏览器解析到script脚本，有defer时 123&lt;script defer="defer" src="main1.js"&gt;&lt;/script&gt;&lt;script defer="defer" src="main2.js"&gt;&lt;/script&gt; 此时单纯看这两个需要被加载的js文件和其他HTML的渲染，CSS的加载，图片的加载等是同时进行的，是异步操作 但是单看main1.js和main2.js又和同步的执行是一样的，当加载main1.js的时候，main2.js会等待main1.js加载完毕再加载 这就是defer的作用了，当有defer的时候，先架加载第一个延迟脚本 async VS defer相同点：异步加载文件 不同点： async：虽然是异步加载，但当有多个脚本异步加载的时候，不一定先加载哪一个，加载顺序不一定 defer：加载顺序由第一个延迟脚本到最后一个延迟脚本 预加载 预加载是一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源，当用户访问某个预加载的链接时，如果从缓存命中,页面就得以快速呈现]]></content>
      <tags>
        <tag>同步加载、异步加载、延迟加载和预加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的深拷贝与浅拷贝]]></title>
    <url>%2Fjavascript%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[javascript中的深拷贝与浅拷贝 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 声明：参考文章：http://www.cnblogs.com/Chen-XiaoJun/p/6217373.html 看这个深拷贝和浅拷贝之前，先要对javascript中不同数据类型之间的传值有一定的了解 javascript中不同数据类型之间的传值 javascript中数据类型简单分为基本数据类型和引用数据类型 基本数据类型：String，Number，Boolean等 引用数据类型：Array，Object等 基本数据类型和引用数据类型最大的区别在于他们的处安置方式不同 基本数据类型的传值： 12345678var a = 1var b = a// a = 1// b = 1b = 2// a = 1// b = 2// a 的原始值不会被修改 引用数据类型的传值： 1234567891011var people = &#123; name: 'zhangsan', age: 10&#125;var people2 = peopleconsole.log(people.age) // 10console.log(people2.age) // 10people2.age = 100console.log(people.age) // 100console.log(people2.age) // 100// people 的值被修改了 这里发现 people 的值被修改了，因为这就是引用传值，他们本身指向了同一个引用，即地址，修改的是同一个地址中的值，所以会发生想修改people2的时候，却无意间影响到了people的原始值，这就是浅拷贝 深拷贝和浅拷贝如上例子，简单粗暴的理解就是当people2复制了people，而当people2修改时，people一块被修改了，这叫浅拷贝，当people2修改时，而people没有被修改，这叫深拷贝 但是，本意不想修改people，只想修改people2的，却造成了这样的错误，如何避免呢？ 123456789101112131415var people = &#123; name: 'zhangsan', age: 10&#125;var people2 = &#123; name: people.name, age: people.age&#125;var people2 = peopleconsole.log(people.age) // 10console.log(people2.age) // 10people2.age = 100console.log(people.age) // 10console.log(people2.age) // 100// people 的值没有被修改 这个时候是深拷贝，但是总不能总不能这么复杂吧，要一个一个的拷贝到people2对象中，很麻烦，容易出错，这时候就要有深拷贝的方法和浅拷贝的方法 浅拷贝的实现 赋值，上面介绍传值的时候也有的方法，就是直接赋值的操作，可以参照上面的例子 Object.assign() 介绍：Object.assign是ES6的新函数，Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象，但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身 语法：Object.assign(target, ...sources) 参数：target：目标对象，sources：任意多个源对象 返回值：返回目标对象 1234567891011121314151617var people = &#123; name: 'zhangsan', age: 10, zhangsan: &#123; say: function () &#123; console.log('hello') &#125;, height: 180 &#125;&#125;var people2 = Object.assign(&#123;&#125;, people)console.log(people.zhangsan.height) // 180console.log(people2.zhangsan.height) // 180people2.zhangsan.height = 181console.log(people.zhangsan.height) // 181console.log(people2.zhangsan.height) // 181// people 的值被修改了 但是当Object.assign()去处理只有一层的拷贝的时候，再看看 1234567891011var people = &#123; name: 'zhangsan', age: 10&#125;var people2 = Object.assign(&#123;&#125;, people)console.log(people.age) // 10console.log(people2.age) // 10people2.age = 100console.log(people.age) // 10console.log(people2.age) // 100// people 的值没有被修改 总结： 当Object.assign()去处理一层的拷贝的时候，可以达到，修改people2不影响people，但是当Object.assign()进行深一层的拷贝的时候，修改people2会影响people 深拷贝的实现 手动复制，这在上面介绍传值的时候，有过例子，可以参照上面的例子，缺点：很麻烦 对象只有一层的话，可以用上面的Object.assign()去处理 利用JSON字符串的基本类型赋值 优点：理解简单，用起来也简单 缺点：只适用于那些能够被 json 直接表示的数据结构，且它会抛弃对象的constructor 12345678var people = &#123; zhangsan: &#123; age: 10 &#125; &#125;var people2 = JSON.parse(JSON.stringify(people))console.log(people.zhangsan.age) // 10console.log(people2.zhangsan.age) // 10people2.zhangsan.age = 100console.log(people.zhangsan.age) // 10console.log(people2.zhangsan.age) // 100// people.zhangsan.age 原始值没被修改 递归拷贝 12345678910111213141516function deepClone(a, b) &#123; var obj = b || &#123;&#125; for (var i in a) &#123; if (typeof a[i] === 'object') &#123; obj[i] = (a[i].constructor === Array) ? [] : &#123;&#125; arguments.callee(a[i], obj[i]) &#125; else &#123; obj[i] = a[i] &#125; &#125; return obj&#125;var str = &#123;&#125;var obj = &#123; a: &#123;a: "hello", b: 21&#125; &#125;deepClone(obj, str)console.log(str.a) 上述方法已经能够实现，深拷贝，但是当两个对象相互引用的时候，问题就来了，会出现死循环 为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否相互引用对象，如果是则退出循环 改进如下： 1234567891011121314151617181920function deepClone(a, b) &#123; var obj = b || &#123;&#125; for (var i in a) &#123; var prop = a[i] // 避免相互引用对象导致死循环，如a.a = a的情况 if(prop === obj) &#123; // 避免相互引用对象导致死循环，如a.a = a的情况 continue &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : &#123;&#125; arguments.callee(prop, obj[i]) &#125; else &#123; obj[i] = prop &#125; &#125; return obj&#125;var str = &#123;&#125;var obj = &#123; a: &#123;a: "hello", b: 21&#125; &#125;deepClone(obj, str)console.log(str.a) 使用Object.create()方法 Object.create()方法的原理其实就和上面递归拷贝实现改进版是一样的 1234567891011121314151617var people = &#123; name: 'zhangsan', age: 10, zhangsan: &#123; say: function () &#123; console.log('hello') &#125;, height: 180 &#125;&#125;var people2 = Object.create(people)console.log(people.zhangsan.height) // 180console.log(people2.zhangsan.height) // 180people2.zhangsan.height = 181console.log(people.zhangsan.height) // 180console.log(people2.zhangsan.height) // 181// people 的值没被修改 JQuery 中的 $.extend 123456789101112131415161718var $ = require('jquery')var people = &#123; name: 'zhangsan', age: 10, zhangsan: &#123; say: function () &#123; console.log('hello') &#125;, height: 180 &#125;&#125;var people2 = $.extend(true, &#123;&#125;, people)console.log(people.zhangsan.height) // 180console.log(people2.zhangsan.height) // 180people2.zhangsan.height = 181console.log(people.zhangsan.height) // 180console.log(people2.zhangsan.height) // 181// people 的值没被修改]]></content>
      <tags>
        <tag>javascript中的深拷贝与浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax工作原理及实例]]></title>
    <url>%2FAjax%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Ajax工作原理及实例 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ Ajax基本概念 Ajax(Asynchronous JavaScript And XML)，异步 JavaScript 和 XML，用于异步请求数据，在不刷新网页的情况下更新页面数据，提升用户体验 基本工作原理 注意：涉及到 AJAX 操作的页面“不能”使用文件协议访问（文件的方式访问） 安装用户代理（实例化 XMLHttpRequest()） 打开浏览器，输入网址 敲回车键，开始请求 1234567// 1. 安装浏览器（用户代理） // xhr 就类似于浏览器的作用（发送请求接收响应） var xhr = new XMLHttpRequest() // 2. 打开浏览器 输入网址 xhr.open('GET', 'http://xxx/xxx.php') // 这里的 url 路径写你需要请求的地址 // 3. 敲回车键 开始请求 xhr.send() 对于上述代码，我们在控制台给 XMLHttpRequest 打印出来看看 XMLHttpRequest中有很多属性和方法，内容太多，不上图了，解释里面一部分 readyState readyState有5个值，代表了Ajax请求状态 0：初始化，请求对象代理 1：open（）方法已经调用，建立一个与服务端特定端口的连接 2：已经接收到了响应报文的响应头getAllResponseHeaders()，但是还没有拿到响应体reponseText 3：正在下载响应报文的响应体，有可能为空，也有可能不完整 4：整个响应报文已经下载下来了，请求完成 下面上代码： 这里自己创建一个文件，作为请求用的，我这里创建的是time.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;readyState&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() console.log('======readyState = 0======') console.log(xhr.readyState) // =&gt; 0 // 初始化 请求代理对象 xhr.open('GET', 'time.php') console.log('======readyState = 1======') console.log(xhr.readyState) // =&gt; 1 // open 方法已经调用，建立一个与服务端特定端口的连接 xhr.send() xhr.addEventListener('readystatechange', function () &#123; switch (this.readyState) &#123; case 2: // =&gt; 2 // 已经接受到了响应报文的响应头 // 可以拿到头 console.log('======readyState = 2======') console.log(this.getAllResponseHeaders()) // console.log(this.getResponseHeader('server')) // 但是还没有拿到体 console.log(this.responseText) break case 3: // =&gt; 3 // 正在下载响应报文的响应体，有可能响应体为空，也有可能不完整 // 在这里处理响应体不保险（不可靠） console.log('======readyState = 3======') console.log(this.responseText) break case 4: // =&gt; 4 // 一切 OK （整个响应报文已经完整下载下来了） console.log('======readyState = 4======') console.log(this.responseText) break &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 去控制台打印看看 onreadystatechange 这个事件并不是只在响应时触发，状态改变就触发 上代码 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;onreadystatechange&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() // 如果需要捕获第一个状态的变化，需要注意代码执行顺序的问题（不要出现来不及的情况） xhr.onreadystatechange = function () &#123; // 这个事件并不是只在响应时触发，状态改变就触发 console.log('======触发了onreadystatechange======') console.log(this.readyState) &#125; xhr.open('GET', './time.php') xhr.send() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 去控制台打印出来看看 因为客户端永远不知道服务端何时才能返回我们需要的响应，所以 AJAX API 采用事件的机制（通知的感觉） 上代码 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;onreadystatechange&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() // 如果需要捕获第一个状态的变化，需要注意代码执行顺序的问题（不要出现来不及的情况） // xhr.onreadystatechange = function () &#123; // // 这个事件并不是只在响应时触发，状态改变就触发 // console.log('======触发了onreadystatechange======') // console.log(this.readyState) // &#125; xhr.open('GET', './time.php') xhr.send() // 因为客户端永远不知道服务端何时才能返回我们需要的响应 // 所以 AJAX API 采用事件的机制（通知的感觉） xhr.onreadystatechange = function () &#123; // 这个事件并不是只在响应时触发，XHR 状态改变就触发 // console.log(1) if (this.readyState !== 4) return // 获取响应的内容（响应体） console.log(this.responseText) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时已经能够接收完整的报文 onload onload是 HTML5 中提供的XMLHttpRequest v2.0 定义的，当页面完全加载完成后执行 上代码 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;online&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open('GET', 'time.php') xhr.send(null) xhr.onload = function () &#123; console.log(this.readyState) console.log(this.responseText) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; setRequestHeader 设置一个请求头 123456789var xhr = new XMLHttpRequest() xhr.open('POST', '/add.php') // 设置请求行 xhr.setRequestHeader('Foo', 'Bar') // 设置一个请求头 // 一旦你的请求体是 urlencoded 格式的内容，一定要设置请求头中 Content-Type 'application/x-www-form-urlencoded' xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') xhr.send('key1=value1&amp;key2=value2') // 以 urlencoded 格式设置请求体 Ajax优缺点优点： Ajax最大的优点就是能在不刷新整个页面的情况下维持与服务器通信 使用异步的方式与服务器通信，不打断用户的操作 可将一些后端的工作移到前端，减少服务器与带宽的负担 Ajax使得界面与应用分离，也就是数据与呈现分离 缺点： Ajax干掉了Back与History功能，即对浏览器机制的破坏，在动态更新页面的情况下，用户无法回到前一页的页面状态，因为浏览器仅能记忆历史纪录中的静态页面 AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑 对搜索引擎支持较弱 JQuery中的Ajax $.ajax()方法 1234567891011121314151617$(function()&#123; $('#send').click(function()&#123; $.ajax(&#123; type: "GET", url: "test.json", data: &#123;username:$("#username").val(), content:$("#content").val()&#125;, dataType: "json", contentType: "application/x-www-form-urlencoded" async: true, cache: true, timeout: 5000, success: function (data) &#123;&#125;, error: function () &#123;&#125;, complete: function () &#123;&#125; &#125;); &#125;);&#125;); urlString类型，请求的地址 typeString类型，请求方式，一般为get或者post请求，但是http的其他请求当然也可以 timeoutNumber类型，超时时间，单位为毫秒 asyncBoolean类型，是否异步，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，设置为false cacheBoolean类型，是否从浏览器缓存中加载请求信息，默认为true，表示会从浏览器缓存中加载请求信息 dataObject或者String类型，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式 dataTypeString类型，希望服务器返回的数据类型，如果不是，就转化为指定的数据类型，如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下： xml：返回XML文档，可用JQuery处理 html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行 script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求 json：返回JSON数据 jsonp：JSONP格式 text：返回纯文本字符串 beforeSendFunction类型，表示发送数据之前，进行的操作，例如想在发送数据之前设置请求头 123beforeSend: function(request) &#123; request.setRequestHeader("Header", "x-www-***");&#125;, contentTypeString类型，发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded” dataFilterFunction类型，过滤数据（预处理数据），例如时间格式的预处理等，2个参数，参数一：Ajax返回的原始数据，参数二：dataType参数 123dataFilter: function (data, type) &#123; return data&#125; globalBoolean类型，默认为true，表示触发全局ajax事件，改为false则不会触发ajax全局事件 successFunction类型，请求数据成功回调，2个参数，参数一：必需，服务器返回后经过dataType参数处理后的数据，参数二：可选，描述状态的字符串 1success: function (data, dataStatus) &#123;&#125; errorFunction类型，请求数据成功回调，3个参数，参数一：必需，XMLHttpRequest对象，参数二：必需，错误信息，参数三：可选，捕获的错误对象 1error: function (XMLHttpRequest, status, error) &#123;&#125; completeFunction类型，只要请求数据完成就回调，不管成功不成功，2个参数，参数一：必需，XMLHttpRequest对象，参数二：可选，描述请求类型的字符串 1complete: function (XMLHttpRequest, status) &#123;&#125; jsonpString类型，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分 usernameString类型，用于响应HTTP访问认证请求的用户名 passwordString类型，响应HTTP访问认证请求的密码]]></content>
      <tags>
        <tag>Ajax工作原理及实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的伪数组]]></title>
    <url>%2Fjavascript%E4%B8%AD%E7%9A%84%E4%BC%AA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[javascript中的伪数组 欢迎访问我的博客https://qqqww.com/，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 什么是伪数组假如有这样一段代码 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id = 'ul'&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; var liArr = document.getElementById('ul') console.dir(liArr.children)&lt;/script&gt;&lt;/html&gt; 去看控制台看看 上图就是一个伪数组，长相很像数组，但是将他的原型_proto_打开看看，它没有数组的splice，concat，pop等方法 特点： 具有length属性 按索引方式存储数组 不具有数组的方法 将伪数组转化为真数组 可以通过call或者apply的方法，将伪数组转化为真数组 12Array.prototype.slice.call(liArr.children)// Array.prototype.slice.apply(liArr.children) 原理借用数组原型方法： 123456789101112var arr = Array.prototype.slice.call(liArr.children); Array.prototype.forEach.call(liArr.children, function(v) &#123; // 循环liArr.children对象&#125;);// push// some// every// filter// map// ... 可以简化为： 12Array.prototype.slice.call(liArr.children) // 此时已经改变了 this 指向，使得 liArr.children 拥有了真数组的原型方法 总结 伪数组没有数组 Array.prototype 的属性值，类型是 Object ，而数组类型是 Array 数组是基于索引的实现， length 会自动更新，而对象是键值对 使用对象可以创建伪数组，伪数组可以利用call或者apply很方便的转化为真数组]]></content>
      <tags>
        <tag>伪数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的parseInt()]]></title>
    <url>%2Fjavascript%E4%B8%AD%E7%9A%84parseInt()%2F</url>
    <content type="text"><![CDATA[欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 本文参考MDN 中的 parseInt() 英文好的，请移步 MDN parseInt() MDN中对 parseInt()的讲解总结如下： 语法1parseInt(string, [radix]); 参数string： 必需，要解析的值，如果string 不是字符串，则将其转化为字符串，并忽略字符串中的前面的空格 radix： 可选，一个介于2到36之间的整数，表示进制，假设parseInt(&#39;10&#39;, 8)，就表示以 8进制来解析这个字符串 10 返回值从给定字符串中解析的整数，如果第一个字符不能够被转换为数字，则返回 NaN 说明 如果 radix 为 0，或者没有设置该参数的时候，parseInt()会根据 string判断需要多少进制 如果 string 以 0x 开头，parseInt()会把 string其余部分解析为 十六进制的整数 如果 string以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字，关于这一点，我去控制台测试parseInt(&#39;010&#39;) = 10，并没有像官方说的那样按照 8 进制去解析字符串 10，TODO：所以此处，还待求证，保留意见，欢迎广大道友提出宝贵意见~~ 如果 string以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数 注意： 只有字符串中的第一个数字会被返回 开头和结尾的空格是允许的 如果字符串的第一个字符不能被转换为数字，则返回 NaN 当 radix &lt;= string字符串的第一个数字，返回 NaN，下面是我在控制台测试的一些实例 123456789101112131415161718192021222324parseInt('9asdsad9')9parseInt('9asdsad9', 10)9parseInt('9asdsad9', 11)109parseInt('9asdsad9', 12)118parseInt('9asdsad9', 0)9parseInt('9asdsad9', 6)NaNparseInt('9asdsad9', 8)NaNparseInt('9asdsad9', 9)NaNparseInt('9asdsad9', 9)NaNparseInt('9asdsad9', 10)9parseInt('8asd9', 9)8parseInt('9', 9)NaN]]></content>
      <tags>
        <tag>javascript中的parseInt()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP:从输入网址到呈现]]></title>
    <url>%2F%E5%9B%BE%E8%A7%A3HTTP-%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E5%91%88%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[图解HTTP:从输入网址到呈现 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 那首先上图，看下图参照下面的说明 说明： 下面以按具体流程讲解： 当用户需要请求github.com的时候，首先要打开浏览器，输入URL地址，即输入github.com 浏览器发起 DNS 调用去解析URL中的域名字段： 先检查本地缓存中有没有这个域名 如果有，浏览器将接收到的URL中抽取出域名字段，就是访问的主机名，比如https://github.com，并将这个主机名传送给DNS应用的客户端 如果没有查找系统hosts文件有没有这个域名，如果有，解析出IP 如果没有，DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段 该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址 一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接 浏览器先通过本地随机端口去建立一个通向服务端的连接通道，此通道遵循HTTP协议 浏览器将客户端信息打“包” 将“包”通过连接通道发送到服务端 服务端接收并打开这个“包”，读取到里面的请求路径 根据文件请求路径找到MIME-TYPE，即获得了消息内容类型 判断这个文件是否为静态文件，如果是静态文件，自己处理，如果自己不能处理，交给自己服务中的其他“小弟们”处理 如果是静态文件，则读取静态文件内容，将内容返回给客户端 如果不是静态文件，则发送给“小弟”处理，这里假设PHP能处理，就按照PHP的语法规则去处理并返回给服务端 服务端将处理好的数据以及其他一些内容，打“包”并通过之前建立的通道发送给客户端 客户端接收并打开这个服务端发送回来的“包”，找到其中的Content-Type 根据Content-Type指定的编码格式（例如html，css，javascript等），决定怎么去处理这些文件或者渲染网页 假设是HTML，则直接渲染到网页结构上]]></content>
      <tags>
        <tag>图解HTTP-从输入网址到呈现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中substring,substr和slice对比]]></title>
    <url>%2Fjavascript%E4%B8%ADsubstring%E5%92%8Csubstr%E5%92%8Cslice%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[javascript中substring,substr和slice对比 欢迎访问我的博客https://qqqww.com/，祝所有码农同胞们早日走上人生巅峰，迎娶白富美~~ 先写下最终结论，这样方便阅读者快速使用： substring(a, b)：指的是截取从开始位置到结束位置，a：开始位置，b：结束位置的后一位 slice(a, b)：指的是截取从开始位置到结束位置，且a和b可以为负数，a：开始位置，b：结束位置的后一位 substr(a, b)：指的是从开始位置a截取长度为b的字符号才能，且a和b可以为负数，a：开始位置，b：要截取的字符串长度 substring 提取在substring(a, b)两个参数之间的字符串片段 语法1substring(a, b) // a：开始位置，b：结束位置的后一位 参数 a: 必需，一个非负整数，规定截取字符串的第一个字符在原字符串中的位置，即规定了截取的开始位置 b: 可选，一个非负整数，规定截取字符串的最后一个字符在原字符串中的位置的前一位，即规定了截取的终止位置，如果省略该参数，那么返回的子串会一直到字符串的结尾 注意： 如果参数a = b，则返回空字符串 如果a &gt; b，则该方法会先交换这两个参数，再执行该方法程序 返回值返回一个新的字符串(a位置到b - 1位置的字符串片段) 实例 建议直接去浏览器控制台调试 1234var str = 'sajdadjsahdah'str.substring(1, 3) // 'aj'str.substring(1) // 'ajdadjsahdah'str.substring(3, 1) // 'aj' slice 提取在slice(a, b)两个参数之间的字符串片段 语法1slice(a, b) // a：开始位置，b：结束位置的后一位 参数 a: 必需，正负整数都支持，正数表示从字符串头到尾的起始下标，负数表示从字符串的尾到头的起始下标 b: 可选，正负整数都支持，正数表示从字符串头到尾的起始下标 - 1，负数表示从字符串的尾到头的起始下标 - 1 注意： 如果参数a = b或者a &gt; b，则返回空字符串 返回值返回一个新的字符串(a位置到b - 1位置的字符串片段) 实例123456789101112131415var str = 'sajdadjsahdah'str.slice(1, 3)// "aj"str.slice(1)// "ajdadjsahdah"str.slice(1, 1)// ""str.slice(3, 1)// ""str.slice(-3, -1)// "da"str.slice(-1, -3)// ""str.slice(-3)// "dah" substr 提取slice(a, b)从a开始，长度为b的字符串 语法1substr(a, b) // a: 起始位置，b：截取的字符串长度 参数 a: 必需，正负整数都支持，正数表示从字符串头到尾的起始下标，负数表示从字符串的尾到头的起始下标 b: 可选，将要截取的字符串长度 注意： 如果省略参数b，那么返回的子串会一直到字符串的结尾 返回值返回一个新的字符串(从a位置开始，长度为b的字符串) 实例123456789var str = 'sajdadjsahdah'str.substr(1, 3)// "ajd"str.substr(1)// "ajdadjsahdah"str.substr(-3, 3)// "dah"str.substr(3, 0)// ""]]></content>
      <tags>
        <tag>substring,substr VS slice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将博客搬至CSDN]]></title>
    <url>%2F%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%87%B3CSDN%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Web前端中的几种布局]]></title>
    <url>%2FWeb%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 圣杯布局 圣杯布局是一种三列布局，两边定宽，中间宽度自适应 圣杯布局可以将整个div.container看做一个奖杯，div.left和div.right看做奖杯的两个耳朵 圣杯布局的原理就是当子元素处于浮动状态时，设置负margin，子元素会叠盖到兄弟元素之上 方法一：利用 BFC 元素与浮动元素不会相互覆盖的特性，实现圣杯布局 三个盒子都加上背景色，方便观察，两边固定宽度，左边左浮动，右边右浮动，中间创建 BFC 123&lt;div class="left"&gt;left&lt;/div&gt;&lt;div class="middle"&gt;middle&lt;/div&gt;&lt;div class="right"&gt;right&lt;/div&gt; 123456789101112131415html, body &#123; margin: 0; padding: 0; &#125;.left &#123;background: yellow; float: left; width: 180px;&#125;.middle &#123; background: blue; overflow: hidden; &#125;.right &#123; background: red; width: 180px; float: right;&#125; 此时发现div.right这个盒子掉下来了，为什么呢？是因为由于div.middle这个盒子是自适应宽度并且在结构中先渲染，此时会提前挤占剩余宽度，所以会将div.right盒子挤下来，而解决办法就是让div.right盒子先渲染，原理是浮动元素脱离文档流，并提前浮动到右边，且 BFC 元素与浮动元素不会相互覆盖，此时div.middle再去占有剩余宽度就可以了 完整代码： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; .left &#123; background: yellow; float: left; width: 180px; &#125; .middle &#123; background: blue; overflow: hidden; &#125; .right &#123; background: red; width: 180px; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt; &lt;div class="middle"&gt;middle&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 此时再去浏览器，拉伸一下浏览器或者缩小浏览器，看看效果就两边宽度固定中间自适应了 方法二：margin的应用 先把三个盒子呈现出来 12345&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122* &#123; margin: 0; padding: 0;&#125;html, body &#123; width: 100%;&#125;.left, .middle, .right &#123; min-height: 150px;&#125;.left, .right &#123; width: 220px;&#125;.left &#123; background-color: yellow;&#125;.middle &#123; background-color: blue;&#125;.right &#123; background-color: red;&#125; 此时三者是垂直排列，需要将他们横向排列，所以给三者都添加浮动 12345.left, .middle, .right &#123; float: left;&#125; 这时候只是达到了三个盒子在一行的效果，并不能达到前面自适应的需求，而且整个页面不正常了，不着急，继续下一步，设置div.container的盒模型，使得父元素两边留白，留够div.left和div.right的空间 123.container &#123; padding: 0 220px;&#125; 给div.middle设置100%宽度，使其自适应 123.middle &#123; width: 100%;&#125; 设置div.left和div.right的负外边距，让其到div.container留白位置 123456.left &#123; margin-left: -220px;&#125;.right &#123; margin-right: -220px;&#125; 此时惊奇的发现，这三列已经排列正常，且能自适应了 但是发现，div.footer上去了，很简单，这是因为三个浮动元素会脱离标准文档流，所以div.footer会上去占有他们的文档流，解决办法是将div.footer设置一个BFC区域就行，BFC区域详细文档可以看BFC 123.footer &#123; overflow: hidden;&#125; 完整代码看这里： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body &#123; width: 100%; margin: 0; padding: 0; &#125; .header, .footer &#123; overflow: hidden; width: 100%; background-color: #ccc; text-align: center; &#125; .container &#123; padding: 0 220px; &#125; .left, .middle, .right &#123; position: relative; float: left; min-height: 150px; &#125; .left, .right &#123; width: 220px; &#125; .left &#123; margin-left: -220px; background-color: yellow; &#125; .middle &#123; width: 100%; background-color: blue; &#125; .right &#123; margin-right: -220px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="header"&gt;header&lt;/div&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="middle"&gt;middle&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局 看完了圣杯布局，来看双飞翼布局，其实和圣杯布局差不多，可以将div.container看做一只大鸟，将div.middle看做鸟的身体，将div.left和div.right看做鸟的两个翅膀 实现方式与圣杯布局差不多，但在解决中间栏div.middle部分的思路不一致 直接上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body &#123; width: 100%; margin: 0; padding: 0; &#125; .header, .footer &#123; clear: both; width: 100%; background-color: #ccc; text-align: center; &#125; .left, .main, .right &#123; float: left; height: 150px; text-align: center; &#125; .left, .right &#123; width: 220px; &#125; .left &#123; margin-left: -100%; background-color: yellow; &#125; .main &#123; width: 100%; &#125; .middle &#123; min-height: 150px; margin: 0 220px; background-color: blue; &#125; .right &#123; margin-left: -220px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="header"&gt;header&lt;/div&gt; &lt;div class="container"&gt; &lt;div class="main"&gt; &lt;div class="middle"&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局 VS 双飞翼布局主要是针对于中间div.middle的处理思路不一样 圣杯布局是先留白，在用margin让两边过去，利用了相对布局 双飞翼布局多创建一个div，包裹middle，利用margin为负值来布局 相比较而言，双飞翼布局比圣杯布局多用了个div，container的padding不需要加了，相对布局position: relative，双飞翼布局的子div用margin布局 注意：两种布局一般都需要将div.middle这一栏提到结构div.left的上面先渲染 前面分析了圣杯布局和双飞翼布局，了解到他们的原理实际上都是是当子元素处于浮动状态时，设置负margin，子元素会叠盖到兄弟元素之上 那么将中间是三个盒子的代码再复制一份，嵌套在div.middle中，看看效果 此时会发现，中间div.middle部分多一部分盒子，且依然满足两边固定，中间宽度自适应，这个很像Bootstrap里的栅格嵌套 栅格布局 Bootstrap的栅格布局提供了一套响应式的解决方案，其实把这套布局拆分来看，分为这几部分： container的设计 响应式布局实现 行 列 其中行和列的布局原理和圣杯布局原理一样 container设计 响应式布局实现 @media媒体查询 123456789101112131415161718192021222324252627.container &#123; padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto;&#125;@media (min-width: 768px) &#123;/*当宽度大于768px时触发*/ .container &#123; width: 750px; &#125;&#125;@media (min-width: 992px) &#123;/*当宽度大于992px时触发*/ .container &#123; width: 970px; &#125;&#125;@media (min-width: 1200px) &#123;/*当宽度大于1200px时触发*/ .container &#123; width: 1170px; &#125;&#125;.container-fluid &#123; /*这个是宽度默认*/ padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto;&#125; 行（row） 1234.row &#123; margin-right: -15px; margin-left: -15px;&#125; 列（col）Bootstrap分别将他们分割成12份，意思是你可以随意使用者12份，加起来要正好12，并能自己调整分配数字 Bootstrap实现了更好的响应式布局，列的种类是有很多种的 .col-xs-* 针对超小屏幕 手机（&lt;768px） .col-sm-* 小屏幕 平板 (≥768px) .col-md-* 中等屏幕 桌面显示器 (≥992px)(栅格参数) .col-lg-* 针对特大的（≥1200px） 例子： 表示小屏幕手机采用col-sm-6布局，中屏幕手机采用col-md-4布局 1&lt;div class="col-sm-6 col-md-4"&gt;&lt;/div&gt; Bootsrap中关于栅格布局的代码实现，很多，这里不粘贴了，原理就是前面所说的，可以去官网看 当然，Bootstrap远不止实现了上面那点东西，例如 .col-md-offset-* .col-md-push-* 能够实现很好的细节的排版等等很多，这个神奇的东西还是需要慢慢领悟的~~，下面不能废话了，继续回归正题，说布局 Flex布局参考文档：Flex布局 绝对定位布局绝对定位布局很多地方都有应用，依靠绝对定位，想定到哪，定到那，这里不细说]]></content>
      <tags>
        <tag>Web前端布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOCTYPE解读]]></title>
    <url>%2FDOCTYPE%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[DOCTYPE解读 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ DOCTYPE的作用？标准模式和兼容模式各有什么区别？为什么html5只需要写&lt;!doctype html&gt; 參考文档：https://www.cnblogs.com/wuqiutong/p/5986191.html DOCTYPE的作用 &lt;!doctype&gt; 声明位于 HTML 文档第一行， 处于&lt;html&gt; 标签之前，用于告诉浏览器该以什么文档标准去解析这个文档 若 DOCTYPE 声明不存在或者不正确会导致文档以兼容模式呈现 标准模式 VS 兼容模式 标准模式（standards）：又称严格模式，指浏览器按照 W3C 标准解析代码，排版和 JS 的运行都是以浏览器支持的最高标准运行 兼容模式（quirks）：又称怪异模式或者混杂模式，指浏览器以自己的方式解析代码 区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关 标准模式呈现：有 URL 的过渡 DTD 混杂模式呈现： 没有 URL 的过渡 DTD 没有DTD或者格式不正确 HTML5中不是基于SGML的，没有DTD，没有标准和兼容模式之分，所以只需要写&lt;!doctype html&gt; 具体到两种模式解析上的不同点： 盒模型的高宽包含内边距padding和边框border， 在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在IE5.5及以下的浏览器及其他版本的Quirks模式下，IE的宽度和高度还包含了padding和border 在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效 在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的 使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效,quirks模式下的解决办法，用text-align属性:body{text-align:center};#content{text-align:left} quirks模式下设置图片的padding会失效 quirks模式下Table中的字体属性不能继承上层的设置 quirks模式下white-space:pre会失效 DOCTYPE 的文档类型 我们去编译器里快速生成这些各种类型的声明来看看： 1. HTML5（一种）： 1&lt;!DOCTYPE html&gt; 2. HTML 4.01（三种）： 严格模式包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font），不允许框架集（Framesets）；过渡模式包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font），不允许框架集（Framesets）；框架模式等同于过渡模式，但允许框架集内容 HTML 4.01 Strict： 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; HTML 4.01 Transitional ： 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; HTML 4.01 Frameset ： 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt; 3、XHTML 1.0(四种) ： 前三种模式同上，XHML 必须以格式正确的 XML 来编写标记 XHTML 1.0 Strict ： 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; XHTML 1.0 Transitional ： 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" " http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; XHTML 1.0 Frameset： 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt; XHTML 1.1 该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt; XHTML、HTML VS HTML5 文档声明不同，具体见上面一节DOCTYPE 的文档类型 HTML 没有提供结构语义化的标签，而HTML5提供了很多新的语义化的标签 XHML VS HTML： 相比较 HTML 而言，XHTML 更加严格 XHTML 所有的标记都必须要有一个相应的结束标记 XHTML 所有标签的元素和属性的名字都必须使用小写 所有的 XML 标记都必须合理嵌套 XHTML 所有的属性必须用引号括起来 XHTML 文档图片必须有说明文字 名词解释 以上有一些名词，可能平时会少注意一些，但是以后肯定是有用的，我去百度查了下，大概总结如下，同时也贴了相关链接在本文中，遇到问题方便查找 DTD 文档类型定义(Document Type Definition)是一套为了进行程序间的数据交换而建立的关于标记符的语法规则 文档类型定义可定义合法的标准通用标记语言、可扩展标记语言文档构建模块 它使用一系列合法的元素来定义文档的结构 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用 SGML SGML(Standard Generalized Markup Language，即标准通用标记语言) 详细见智库百科 主要特点： 它可以支持众多的文档结构类型，例如布告、技术手册、章节目录、设计规范、各种信函等 它可以创建与特定的软硬件无关的文档，因此很容易与使用不同计算机系统的用户交换文档 主要构成： SGML声明(SGML Declaration) 文档类型定义(Document Type Definition，DTD) 文档实例(Document Instance) RSS 简易信息聚合（也叫聚合内容）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议 RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的XML应用 详细见[RSS简易信息聚合]]]></content>
      <tags>
        <tag>DOCTYPE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-sprites]]></title>
    <url>%2FCSS-sprites%2F</url>
    <content type="text"><![CDATA[CSS-sprites，又叫精灵图 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 概念：CSS-sprites，又叫精灵图，也是CSS图像拼合或者CSS贴图定位 CSS-sprites拼合 选择合适的图像素材去拼合到一张图片上，再、利用定位将图像在网页中渲染出来 一般小素材或者icon类素材或者比较少改动的图片适合拼合为CSS sprites 一般大图像或者网页背景不适合拼合为CSS sprites，网络带宽不好的情况下，访问大图的拼合图像，加载时间需要更长 推荐：一般最好将尺寸大小差不多的品何在一张图片上，这样也会有利于开发者计算定位，降低出错率，提高效率 CSS-sprites优点和缺点优点： 将众多小图像拼合，一次性加载，减少http请求，提高网站性能 减少图片文件数量，减少命名太多的困扰，对开发者友好，降低出错率，提高效率 缺点： 在做图片拼合的时候，需要在页面中留有合适的空间，需要精确测量计算位置，会很繁琐，当然现在也有对应的自动拼合且产生定位代码的软件 不利于维护，当CSS-sprites上的一个图像需要改动时，往往需要改动其他的图像的CSS代码，这就要在制作CSS sprites的时候就要考虑这种图片以后改动会不会很频繁，如果很频繁，可以不放在拼合图像中 CSS-sprites例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1, maximum-scale=1,minimal-ui, user-scalable=no"/&gt; &lt;style&gt; .sprites div &#123; margin: 5px; &#125; .sprites span &#123; float: left; width: 20px; height: 20px; background-image: url(sprite.png); background-size: 60px 40px; &#125; .sprites1&#123; background-position: 0 0; &#125; .sprites2&#123; background-position: -20px 0; &#125; .sprites3&#123; background-position: 0 -20px; &#125; .sprites4&#123; background-position: -20px -20px; &#125; .sprites5&#123; background-position: -40px 0; &#125; .sprites6&#123; background-position: -40px -20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="sprites"&gt; &lt;div&gt;&lt;span class="sprites1"&gt;&lt;/span&gt;付款图标&lt;/div&gt; &lt;div&gt;&lt;span class="sprites2"&gt;&lt;/span&gt;删除图标&lt;/div&gt; &lt;div&gt;&lt;span class="sprites3"&gt;&lt;/span&gt;存款图标&lt;/div&gt; &lt;div&gt;&lt;span class="sprites4"&gt;&lt;/span&gt;粘贴图标&lt;/div&gt; &lt;div&gt;&lt;span class="sprites5"&gt;&lt;/span&gt;笑脸图标&lt;/div&gt; &lt;div&gt;&lt;span class="sprites6"&gt;&lt;/span&gt;编辑图标&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 然后快去看看执行结果吧：]]></content>
      <tags>
        <tag>CSS-sprites</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS BFC的理解]]></title>
    <url>%2FCSS-BFC%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[BFC 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 在 Web 页面的 CSS 渲染中，BFC （Block Fromatting Context）块级格式化上下文，即 BFC 区域是一块独立的块级渲染区域，并且拥有一套渲染规则，来约束盒子布局，且与外部区域无关，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列 创建BFC W3C 中对于 BFC 是这样说的： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文） 简单粗暴来讲就是，满足以下任意一个条件或者多个条件即形成 BFC float 值不是 none overflow 值不是 visible display 值是 inline-block、table-cell、table-caption、flex 或 inline-flex position 值是 absoulute或fixed 所以只要满足了上述条件一个或多个，即形成 BFC 123&lt;div class = "container"&gt; 内容区域&lt;/div&gt; 123.container &#123; overflow: hidden;&#125; BFC的约束规则浏览器对于BFC这块区域的约束规则如下： 在 BFC 区域，其内部元素会在垂直方向，一个接一个的排列，第一个元素的左上角顶部和 BFC 区域左上角顶部重合 且每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘(border-left)，（对于从右到左的格式来说，则触碰到右边缘） 垂直方向上的距离由margin决定，相邻两个兄弟元素（例如上兄弟元素的margin-bottom和下兄弟元素的margin-top会发生重叠)，但与方向无关，水平方向也可以发生重叠，一般很少 每个元素都不会超过它的包含块，即不会超过 BFC 区域，浮动元素也不例外，而position为absolute的元素可以超出他的包含块边界 BFC 区域是一块隔离的区域，与外界无关 BFC的应用 BFC 在页面布局中有很多应用，有很多其实已经用过，但是原理是要慢慢去领悟，例如： 垂直方向防止 margin 重叠 浮动元素会尽量接近左上角 为父元素设置 overflow: hidden;来清除浮动 …….等 margin重叠 同一个 BFC 区域的两个相邻子元素的相邻的margin会发生重叠 margin嵌套重叠12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;!--The viewport meta tag is used to improve the presentation and behavior of the samples on iOS devices--&gt; &lt;meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no"/&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; html, body &#123; height: 100%; width: 100%; margin: 0; padding: 0; &#125; #map&#123; padding:0; &#125; .first&#123; margin:20px; background:lightgreen; width:100px; height:100px; &#125; ul&#123; /*display:inline-block;*/ margin:10px; background:lightblue; &#125; li&#123; margin:25px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body class="claro"&gt; &lt;div class="first"&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;/html&gt; 这里给了 .first盒子和ul和li的margin值分别为20px，10px，25px 在浏览器的控制面板调试如下图 此时，垂直方向上，div.frist和ul两个盒子之间的距离是25px，由.first，ul，li三者中最大的margin决定 解决 margin 嵌套重叠： 如上例子，将例子中的 注释部分display:inline-block;去掉再去浏览器看看结果，就可以解决margin嵌套重叠的问题了，margin此时的值是二者之和30px了 原理是：将ul形成了一个BFC区域，它和上面的div.first都是独立的BFC区域，互不影响。 ul BFC区域中的问题： 但是此时，去看看ul中的li的margin仍然是存在问题的，依然发生了margin嵌套重叠，因为此时li是属于ul这个封闭的BFC区域的 BFC中的浮动 当给一个父元素的子元素设置浮动的时候，父元素往往会发生高度塌陷，即父元素高度变为0 原因：浮动元素会脱离文档流（像绝对定位的元素也会脱离文档流），所以此时如果没有高度的容器的子元素是浮动元素，则该容器是不会被撑开的 常见的解决办法是：给父元素加overflow: hidden;清除浮动 原理：创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题。实际上只要让父元素生成BFC即可，并不只有这两种方式 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .container &#123; background-color: green; /*overflow: hidden;*/ /*display: inline-block;*/ /*display: table-cell;*/ /*display: flex;*/ /*display: table-caption;*/ /*display: inline-flex;*/ /*float: left;*/ /*float: right;*/ /*position: absolute;*/ /*position: fixed;*/ &#125; .container div &#123; float: left; background-color: lightgreen; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div&gt;Sibling&lt;/div&gt; &lt;div&gt;Sibling&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 将上段代码复制到你的编译器中，打开浏览器，打开控制面板，我们看一下，两个字元素是浮动的，父元素div.container`是没有高度的，原因正如上面解释的一样 解决办法：将我上面代码中的注释去掉任意一个，都可以解决这种父元素塌陷的问题 原理正如上面解释的一样，创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题。实际上只要让父元素生成BFC即可，并不只有这种方式 此时再去打开浏览器看看，父元素div.container就有高度了 拓展：一般清除浮动最常用的方式，双伪元素清除浮动，若子元素需要浮动，则给其父元素加一个类clearfix使其形成BFC即可 12345678.clearfix:before, .clearfix:after &#123; content: ''; display: block; clear: both;&#125;.clearfix &#123; overflow: hidden; // 形成 BFC&#125; 多栏布局 与浮动元素相邻的已生成BFC的元素不能与浮动元素相互覆盖。利用该特性可以作为多栏布局的一种实现方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;!--The viewport meta tag is used to improve the presentation and behavior of the samples on iOS devices--&gt; &lt;meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no"/&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; html, body &#123; height: 100%; width: 100%; margin: 0; padding: 0; &#125; .left &#123; background: yellow; float: left; width: 180px; &#125; .center &#123; background: blue; overflow: hidden; &#125; .right &#123; background: red; width: 180px; float: right; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body class="claro"&gt; &lt;div class="container"&gt; &lt;div class="left"&gt; &lt;pre&gt; .left &#123; background: yellow; float: left; width: 180px; &#125; &lt;/pre&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;pre&gt; .right &#123; background: blue; width: 180px; float: right; &#125; &lt;/pre&gt; &lt;/div&gt; &lt;div class="center"&gt; &lt;pre&gt; .center &#123; background: red; overflow: hidden; height: 116px; &#125; &lt;/pre&gt; &lt;/div&gt; &lt;/div&gt;&lt;/html&gt; 这种布局的特点在于左右两栏宽度固定，中间栏可以根据浏览器宽度自适应]]></content>
      <tags>
        <tag>CSS BFC的理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3新特性整理]]></title>
    <url>%2FCSS3%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[CSS3新特性 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 声明：本文参考 W3C CSS3 教程、菜鸟教程等，详细移步 W3C 或菜鸟教程 用 CSS3 做过一些小动画，很好用，特别是里面一些新特性，都是 CSS2 不可比拟的，这里整理一些出来，当做笔记，也当做教程，共勉！ CSS3 相比 CSS 2 对边框、背景、渐变、文本效果、字体、转换效果、过渡、动画、图片、用户界面、盒模型、媒体查询等都有了很大的改进，新增了不少功能和属性 CSS3边框 用 CSS3，可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序 属性 border-radius box-shadow border-image 兼容性 IE9 支持 border-radius 和 box-shadow 属性 IE 浏览器不支持 border-image 属性 Firefox、Chrome 以及 Safari 支持所有新的边框属性 对于 border-image，Safari 5 以及更老的版本需要前缀 -webkit- Opera 支持 border-radius 和 box-shadow 属性，但是对于 border-image 需要前缀 -o- CSS3 圆角边框 CSS3中border-radius属性是用于创建圆角的 语法12border-radius：n1, n2, n3, n4 /* n1 - n4 分别代表左上角、右上角、右下角、左下角 ，值可为百分比或像素值*/ ####例子 123456div &#123; width: 100px; height: 100px; /* border-radius: 25px; */ border-radius: 25%;&#125; CSS3盒阴影 CSS3中的box-shadow属性被用来添加阴影 语法1box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置inset就是从外往里） 例子1234567div &#123; width: 100px; height: 100px; background-color: yellow; box-shadow: 10px 10px 5px #888888 inset; &#125; CSS3边界图片 border-image 属性允许你指定一个图片作为边框！用于创建上文边框的原始图像 语法1border-image: 图片url 图像边界向内偏移 图像边界的宽度(默认为边框的宽度) 用于指定在边框外部绘制偏移的量（默认0） 铺满方式--重复（repeat）、拉伸（stretch）或铺满（round）（默认：拉伸（stretch）） 例子12345div &#123; border-image:url(border.png) 30 30 round; -webkit-border-image:url(border.png) 30 30 round; /* Safari 5 and older */ -o-border-image:url(border.png) 30 30 round; /* Opera */ &#125; CSS3背景 CSS3更新了几个新的背景属性，提供更大背景元素控制，通过这几个背景属性，您能够做出更加精美的样式 属性 background-image background-size background-origin background-clip 兼容性表格中的数字表示支持该属性的第一个浏览器版本号。 紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号。 属性 chrome IE Firefox Safari Opera background-image (with multiple backgrounds) 4.0 9.0 3.6 3.1 11.5 background-size 4.0 1.0 -webkit- 9.0 4.0 3.6 -moz- 4.1 3.0 -webkit- 10.5 10.0 -o- background-origin 1.0 9.0 4.0 3.0 10.5 background-clip 4.0 9.0 4.0 3.0 10.5 CSS3 背景图片 CSS3中可以通过background-image属性添加背景图片 语法1background-image: url, 定位, 平铺 例子 不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张 12345#example1 &#123; background-image: url(img_flwr.gif), url(paper.gif); background-position: right bottom, left top; background-repeat: no-repeat, repeat; &#125; 可以给不同的图片设置多个不同的属性，每张图片之间依然用逗号隔开 123#example1 &#123; background: url(img_flwr.gif) right bottom no-repeat, url(paper.gif) left top repeat;&#125; CSS3 背景图像大小 background-size指定背景图像的大小。CSS3以前，背景图像大小由图像的实际大小决定 语法1background-size: 宽 高; // 宽高可以是像素值，也可以是百分比 例子 像素值 123456div&#123; background: url(img_flwr.gif); background-size: 80px 60px; background-repeat: no-repeat;&#125; 相对于父元素的宽度和高度的百分比的大小 123456div&#123; background: url(img_flwr.gif); background-size: 100% 100%; background-repeat: no-repeat;&#125; CSS3 背景起始位置 background-Origin属性指定了背景图像的位置区域 语法 content-box, padding-box,和 border-box区域内可以放置背景图像。 12background-Origin: content-box, padding-box,和 border-box;// 三个属性三选一，区域内可以放置背景图像 例子 在 content-box 中定位背景图片 1234567div &#123; background: url(img_flwr.gif); background-repeat: no-repeat; background-size: 100% 100%; background-origin: content-box; &#125; CSS3 背景图像裁剪 CSS3中background-clip背景剪裁属性是从指定位置开始绘制 语法 从content-box, padding-box,或 border-box位置进行背景图像裁剪 12background-clip: content-box, padding-box,和 border-box;// 三个属性三选一，区域内可以放置背景图像 例子 从 content-box 开始裁剪 123456#example1 &#123; border: 10px dotted black; padding: 35px; background: yellow; background-clip: content-box; &#125; CSS3渐变 CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡 属性 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 径向渐变（Radial Gradients）- 由它们的中心定义 兼容性 表中的数字指定了完全支持该属性的第一个浏览器版本。 后边跟 -webkit-、-moz- 或 -o- 的数字指定了需加上前缀才能支持属性的第一个版本 属性 Chrome IE Firefox Safari Opera linear-gradient 26.0 10.0 -webkit- 10.0 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- radial-gradient 26.0 10.0 -webkit- 10.0 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.6 -o- repeating-linear-gradient 26.0 10.0 -webkit- 10.0 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.1 -o- repeating-radial-gradient 26.0 10.0 -webkit- 10.0 16.0 3.6 -moz- 6.1 5.1 -webkit- 12.1 11.6 -o- CSS3线性渐变 为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度） 语法 linear-gradient 1background: linear-gradient(direction, color-stop1, color-stop2, ...); 例子 从上到下：从顶部开始的线性渐变。起点是红色，慢慢过渡到蓝色 123456#grad &#123; background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, blue); /* 标准的语法 */ &#125; 从左到右：从左边开始的线性渐变。起点是红色，慢慢过渡到蓝色 123456#grad &#123; background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to right, red , blue); /* 标准的语法 */ &#125; 对角：从左上角开始（到右下角）的线性渐变。起点是红色，慢慢过渡到蓝色 123456#grad &#123; background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */ &#125; 使用多个颜色节点从上到下的线性渐变 123456#grad &#123; background: -webkit-linear-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, green, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, green, blue); /* 标准的语法 */ &#125; 带有彩虹颜色和文本从左到右的线性渐变 12345678910#grad &#123; /* Safari 5.1 - 6.0 */ background: -webkit-linear-gradient(left,red,orange,yellow,green,blue,indigo,violet); /* Opera 11.1 - 12.0 */ background: -o-linear-gradient(left,red,orange,yellow,green,blue,indigo,violet); /* Firefox 3.6 - 15 */ background: -moz-linear-gradient(left,red,orange,yellow,green,blue,indigo,violet); /* 标准的语法 */ background: linear-gradient(to right, red,orange,yellow,green,blue,indigo,violet); &#125; 使用透明度（Transparency） CSS3 渐变也支持透明度（transparency），可用于创建减弱变淡的效果。 为了添加透明度，我们使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明 从左边开始的线性渐变。起点是完全透明，慢慢过渡到完全不透明的红色 123456#grad &#123; background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */ background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/ background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/ background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */ &#125; repeating-linear-gradient() 函数用于重复线性渐变 12345678910#grad &#123; /* Safari 5.1 - 6.0 */ background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%); /* Opera 11.1 - 12.0 */ background: -o-repeating-linear-gradient(red, yellow 10%, green 20%); /* Firefox 3.6 - 15 */ background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%); /* 标准的语法 */ background: repeating-linear-gradient(red, yellow 10%, green 20%); &#125; 角度渐变 角度渐变：属于线性渐变，如果你想要在渐变的方向上做更多的控制，你可以定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等） #####语法 角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变 1background: linear-gradient(angle, color-stop1, color-stop2); 注意：很多浏览器(Chrome,Safari,fiefox等)的使用了旧的标准，即 0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度 例子 带有指定的角度的线性渐变 123456#grad &#123; background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(180deg, red, blue); /* 标准的语法 */ &#125; CSS3径向渐变 说明：我这里是参照 W3C 总结的，发现了几篇更为详细的文档，这里推荐一下： CSS3 Gradient 再说CSS3渐变——线性渐变 再说CSS3渐变——径向渐变 神奇的 conic-gradient 圆锥渐变 为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色 语法 radial-gradient 可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落） 12background: radial-gradient(center, shape size, start-color, ..., last-color)// 渐变的中心、形状（圆形或椭圆形）、大小 例子 颜色结点均匀分布的径向渐变 123456#grad &#123; background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: radial-gradient(red, green, blue); /* 标准的语法 */ &#125; 颜色结点不均匀分布的径向渐变 123456#grad &#123; background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */ background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */ &#125; 设置形状 shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse 形状为圆形的径向渐变 123456#grad &#123; background: -webkit-radial-gradient(circle, red, yellow, green); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(circle, red, yellow, green); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(circle, red, yellow, green); /* Firefox 3.6 - 15 */ background: radial-gradient(circle, red, yellow, green); /* 标准的语法 */ &#125; 不同尺寸大小关键字的使用 size 参数定义了渐变的大小。它可以是以下四个值: closest-side farthest-side closest-corner farthest-corner 不同尺寸大小关键字的径向渐变 123456789101112131415161718192021#grad1 &#123; /* Safari 5.1 - 6.0 */ background: -webkit-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); /* Opera 11.6 - 12.0 */ background: -o-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); /* Firefox 3.6 - 15 */ background: -moz-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); /* 标准的语法 */ background: radial-gradient(60% 55%, closest-side,blue,green,yellow,black); &#125; #grad2 &#123; /* Safari 5.1 - 6.0 */ background: -webkit-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black); /* Opera 11.6 - 12.0 */ background: -o-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black); /* Firefox 3.6 - 15 */ background: -moz-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black); /* 标准的语法 */ background: radial-gradient(60% 55%, farthest-side,blue,green,yellow,black); &#125; 重复的径向渐变 repeating-radial-gradient() 函数用于重复径向渐变 12345678910#grad &#123; /* Safari 5.1 - 6.0 */ background: -webkit-repeating-radial-gradient(red, yellow 10%, green 15%); /* Opera 11.6 - 12.0 */ background: -o-repeating-radial-gradient(red, yellow 10%, green 15%); /* Firefox 3.6 - 15 */ background: -moz-repeating-radial-gradient(red, yellow 10%, green 15%); /* 标准的语法 */ background: repeating-radial-gradient(red, yellow 10%, green 15%); &#125; CSS3文本效果 CSS3中包含几个新的文本特征 属性 text-shadow box-shadow text-overflow word-wrap word-break 兼容性 浏览器支持 属性 Chrome IE Firefox Safari Opera text-shadow 4.0 10.0 3.5 4.0 9.5 box-shadow 10.0 4.0 -webkit- 9.0 4.0 3.5 -moz- 5.1 3.1 -webkit- 10.5 text-overflow 4.0 6.0 7.0 3.1 11.0 9.0 -o- word-wrap 23.0 5.5 3.5 6.1 12.1 word-break 4.0 5.5 15.0 3.1 15.0 CSS3文本阴影 CSS3中，text-shadow 属性适用于文本阴影 语法1text-shadow: 水平阴影，垂直阴影，模糊的距离，阴影的颜色 例子 给标题添加阴影 123h1&#123; text-shadow: 5px 5px 5px #FF0000;&#125; CSS3盒子阴影 CSS3 中 box-shadow 属性适用于盒子阴影 语法1box-shadow: x轴偏移 y轴偏移 模糊距离 阴影颜色 例子1div &#123; box-shadow: 10px 10px 5px yellow;&#125; 也可以在 ::before 和 ::after 两个伪元素中添加阴影效果 1234567891011121314151617181920#boxshadow &#123; position: relative; box-shadow: 1px 2px 4px rgba(0, 0, 0, .5); padding: 10px; bac kground: white;&#125; #boxshadow img &#123; width: 100%; border: 1px solid #8a4419; border-style: inset;&#125; #boxshadow::after &#123; content: ''; position: absolute; z-index: -1; /* hide shadow behind image */ box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); width: 70%; left: 15%; /* one half of the remaining 30% */ height: 100px; bottom: 0;&#125; 文字卡片效果 12345div.card &#123; width: 250px; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); text-align: center;&#125; CSS3溢出内容效果 CSS3文本溢出属性Text Overflow指定应向用户如何显示溢出内容 语法 clip： 修剪文本 ellipsis：显示省略符号来代表被修剪的文本 string：使用给定的字符串来代表被修剪的文本 1text-overflow: clip|ellipsis|string; 例子 带有 hover 效果的 Text-overflow 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; div.test&#123;white-space:nowrap; width:12em; overflow:hidden; border:1px solid #000000;&#125;div.test:hover&#123;text-overflow:inherit;overflow:visible;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;如果您把光标移动到下面两个 div 上，就能够看到全部文本。&lt;/p&gt;&lt;p&gt;这个 div 使用 "text-overflow:ellipsis" ：&lt;/p&gt;&lt;div class="test" style="text-overflow:ellipsis;"&gt;This is some long text that will not fit in the box&lt;/div&gt;&lt;p&gt;这个 div 使用 "text-overflow:clip"：&lt;/p&gt;&lt;div class="test" style="text-overflow:clip;"&gt;This is some long text that will not fit in the box&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS3换行 word-wrap自动换行属性允许您强制文本换行 - 即使这意味着分裂它中间的一个字 语法 normal：只在允许的断字点换行（浏览器保持默认处理） break-word：在长单词或 URL 地址内部进行换行 1word-wrap: normal|break-word; 例子 允许长文本换行 1p &#123;word-wrap: break-word;&#125; CSS3单词拆分行 CSS3 单词拆分换行属性word-break指定换行规则 语法 normal：使用浏览器默认的换行规则 break-all：允许在单词内换行 keep-all：只能在半角空格或连字符处换行 1word-break: normal|break-all|keep-all; 例子123456p.test1 &#123; word-break: keep-all;&#125; p.test2 &#123; word-break: break-all;&#125; CSS其他文本属性 内容来自菜鸟教程 属性 描述 CSS hanging-punctuation 规定标点字符是否位于线框之外。 3 punctuation-trim 规定是否对标点字符进行修剪。 3 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 3 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 3 text-justify 规定当 text-align 设置为 “justify” 时所使用的对齐方法。 3 text-outline 规定文本的轮廓。 3 text-overflow 规定当文本溢出包含元素时发生的事情。 3 text-shadow 向文本添加阴影。 3 text-wrap 规定文本的换行规则。 3 word-break 规定非中日韩文本的换行规则。 3 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 3 CSS3字体 通过CSS3，web设计师可以使用他们喜欢的任意字体 属性 当您找到或购买到希望使用的字体时，可将该字体文件存放到web服务器上，它会在需要时被自动下载到用户的计算机上 @font-face 兼容性 表格中的数字表示支持该属性的第一个浏览器版本号。 属性 Chrome IE Firefox Safari Opera @font-face 4.0 9.0 3.5 3.2 10.0 Internet Explorer 9+, Firefox, Chrome, Safari, 和 Opera 支持 WOFF (Web Open Font Format) 字体. Firefox, Chrome, Safari, 和 Opera 支持 .ttf(True Type字体)和.otf(OpenType)字体字体类型）。 Chrome, Safari 和 Opera 也支持 SVG 字体/折叠. Internet Explorer 同样支持 EOT (Embedded OpenType) 字体. 需要注意的是： Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。 CSS3设置字体 CSS3中用@font-face属性来设置自己喜欢的字体 语法 在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件 例子12345678910@font-face&#123; font-family: myFirstFont; src: url(sansation_light.woff);&#125;div&#123; font-family:myFirstFont;&#125; CSS3 字体描述 下表列出了所有的字体描述和里面的@font-face规则定义 说明：表格来源于 W3C 描述符 值 描述 font-family name 必需。规定字体的名称。 src URL 必需。定义字体文件的 URL。 font-stretch normal/condensed/ultra-condensed/extra-condensed/semi-condensed/expanded/semi-expanded/extra-expanded/ultra-expanded 可选。定义如何拉伸字体。默认是 “normal”。 font-style normalitalicoblique 可选。定义字体的样式。默认是 “normal”。 font-weight normal/bold/100-900 可选。定义字体的粗细。默认是 “normal”。 unicode-range unicode-range 可选。定义字体支持的 UNICODE 字符范围。默认是 “U+0-10FFFF”。 CSS3 2D 转换 可以移动，比例化，反过来，旋转，和拉伸元素 属性 transform transform-origin 方法 translate() rotate() scale() skew() matrix() 兼容性 表格中的数字表示支持该属性的第一个浏览器版本号 紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号 属性 Chrome IE Firefox Safari Opera transform 36.0 4.0 -webkit- 10.0 9.0 -ms- 16.0 3.5 -moz- 3.2 -webkit- 23.0 15.0 -webkit- 12.1 10.5 -o- transform-origin (two-value syntax) 36.0 4.0 -webkit- 10.0 9.0 -ms- 16.0 3.5 -moz- 3.2 -webkit- 23.0 15.0 -webkit- 12.1 10.5 -o- Internet Explorer 10, Firefox, 和 Opera支持transform 属性. Chrome 和 Safari 要求前缀 -webkit- 版本. 注意： Internet Explorer 9 要求前缀 -ms- 版本. translate() 移动 translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动 语法1transform: translate(x轴移动距离, y轴移动距离) // 原点在左上角 案例 translate值（50px，100px）是从左边元素移动50个像素，并从顶部移动100像素 12345div &#123; transform: translate(50px,100px); -ms-transform: translate(50px,100px); /* IE 9 */ -webkit-transform: translate(50px,100px); /* Safari and Chrome */ &#125; rotate() 旋转，旋转过后，原点会跟着变化 rotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转 语法1transform: rotate(angle) // 括号内填写旋转角度 例子 rotate值（30deg）元素顺时针旋转30度 12345div &#123; transform: rotate(30deg); -ms-transform: rotate(30deg); /* IE 9 */ -webkit-transform: rotate(30deg); /* Safari and Chrome */ &#125; scale() 缩放 scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数 语法1transform: scale(宽度的倍数, 高度的倍数) ####例子 scale（2,4）转变宽度为原来的大小的2倍，和其原始大小4倍的高度 123456div &#123; transform: scale(2,4); -ms-transform: scale(2,4); /* IE 9 */ -webkit-transform: scale(2,4); /* Safari and Chrome */ &#125; skew() CSS3 倾斜 包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜 语法 skewX( );表示只在X轴(水平方向)倾斜。 skewY( );表示只在Y轴(垂直方向)倾斜。 1transform: skew(相对于x轴角度, 相对于y轴角度) 例子 skew(30deg,20deg) 是元素在X轴和Y轴上倾斜30度20度 此处 W3C 上教程有误，他写的是 skew(30deg,20deg) 是元素在X轴和Y轴上倾斜20度30度 12345div &#123; transform: skew(30deg,20deg); -ms-transform: skew(30deg,20deg); /* IE 9 */ -webkit-transform: skew(30deg,20deg); /* Safari and Chrome */ &#125; ###matrix() CSS3 矩阵，反正我用得少 matrix()方法将2D变换方法合并成一个 语法1transform: matrix(旋转角度, 缩放比例, 移动, 倾斜) 例子 利用matrix()方法旋转div元素30° 123456div &#123; transform:matrix(0.866,0.5,-0.5,0.866,0,0); -ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */ -webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */ &#125; CSS3 3D转换 CSS3 允许您使用 3D 转换来对元素进行格式化 兼容性 表格中的数字表示支持该属性的第一个浏览器版本号 紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号 属性 Chrome IE Firefox Safari Opera transform 36.0 12.0 -webkit- 10.0 16.0 10.0 -moz- 4.0 -webkit- 23.0 15.0 -webkit- transform-origin (three-value syntax) 36.0 12.0 -webkit- 10.0 16.0 10.0 -moz- 4.0 -webkit- 23.0 15.0 -webkit- transform-style 36.0 12.0 -webkit- 11.0 16.0 10.0 -moz- 4.0 -webkit- 23.0 15.0 -webkit- perspective 36.0 12.0 -webkit- 10.0 16.0 10.0 -moz- 4.0 -webkit- 23.0 15.0 -webkit- perspective-origin 36.0 12.0 -webkit- 10.0 16.0 10.0 -moz- 4.0 -webkit- 23.0 15.0 -webkit- backface-visibility 36.0 12.0 -webkit- 10.0 16.0 10.0 -moz- 4.0 -webkit- 23.0 15.0 -webkit- ###rotateX() 例子 rotateX()方法，围绕其在一个给定度数X轴旋转的元素 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;W3C(w3cschool.cn)&lt;/title&gt; &lt;style&gt; div&#123; width:100px; height:75px; background-color:red; border:1px solid black;&#125;div#div2&#123; transform:rotateX(120deg); -webkit-transform:rotateX(120deg); /* Safari and Chrome */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; Internet Explorer 9 (以及更早版本的浏览器) 和 Opera 不支持 rotateX 方法.&lt;/p&gt;&lt;div&gt;Hello. This is a DIV element.&lt;/div&gt;&lt;div id="div2"&gt;Hello. This is a DIV element.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; rotateY() 例子 rotateY()方法，围绕其在一个给定度数Y轴旋转的元素 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;W3C(w3cschool.cn)&lt;/title&gt; &lt;style&gt; div&#123; width:100px; height:75px; background-color:red; border:1px solid black;&#125;div#div2&#123; transform:rotateY(130deg); -webkit-transform:rotateY(130deg); /* Safari and Chrome */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; Internet Explorer 9 (以及更早版本的浏览器) 和 Opera 不支持 rotateY方法.&lt;/p&gt;&lt;div&gt;Hello. This is a DIV element.&lt;/div&gt;&lt;div id="div2"&gt;Hello. This is a DIV element.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS3 转换属性 下表列出了CSS3所有的转换属性 属性 描述 CSS transform 向元素应用 2D 或 3D 转换。 3 transform-origin 允许你改变被转换元素的位置。 3 transform-style 规定被嵌套元素如何在 3D 空间中显示。 3 perspective 规定 3D 元素的透视效果。 3 perspective-origin 规定 3D 元素的底部位置。 3 backface-visibility 定义元素在不面对屏幕时是否可见。 3 CSS3 3D 转换方法 类似于 CSS3 2D 转换方法的使用 函数 描述 matrix3d(n**,n, n,n,n,n ,n,n,n ,n,n,n, n,n,n,**n ) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate3d(x**,y,**z) 定义 3D 转化。 translateX(x) 定义 3D 转化，仅使用用于 X 轴的值。 translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。 translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。 scale3d(x**,y,**z) 定义 3D 缩放转换。 scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。 scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。 scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。 rotate3d(x**,y,z,**angle) 定义 3D 旋转。 rotateX(angle) 定义沿 X 轴的 3D 旋转。 rotateY(angle) 定义沿 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿 Z 轴的 3D 旋转。 perspective(n) 定义 3D 转换元素的透视视图。 CSS3 过渡 CSS3中，我们为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript 属性 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 兼容性 表格中的数字表示支持该属性的第一个浏览器版本号 紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号 属性 Chrome IE Firefox Safari Opera transition 26.0 4.0 -webkit- 10.0 16.0 4.0 -moz- 6.1 3.1 -webkit- 12.1 10.5 -o- transition-delay 26.0 4.0 -webkit- 10.0 16.0 4.0 -moz- 6.1 3.1 -webkit- 12.1 10.5 -o- transition-duration 26.0 4.0 -webkit- 10.0 16.0 4.0 -moz- 6.1 3.1 -webkit- 12.1 10.5 -o- transition-property 26.0 4.0 -webkit- 10.0 16.0 4.0 -moz- 6.1 3.1 -webkit- 12.1 10.5 -o- transition-timing-function 26.0 4.0 -webkit- 10.0 16.0 4.0 -moz- 6.1 3.1 -webkit- 12.1 10.5 -o- transition语法 transition需要配合一个变化的属性进行 123456div:hover &#123; width: 300px;&#125;div &#123; transition: 指定需要变化的属性（例如width）,完成时间, 转速曲线, 延迟执行的时间 &#125; 例子 指定当鼠标经过 div 的 1s 之后 , div 的 width 在 1 秒时间内，匀速变化为 300 px 123456div:hover &#123; width: 300px;&#125;div &#123; transition: width 1s linear 1s;&#125; 拆分写法 123456789101112131415div:hover &#123; width: 300px;&#125;div &#123; transition-property: width; transition-duration: 1s; transition-timing-function: linear; transition-delay: 1s; /* Safari */ -webkit-transition-property: width; -webkit-transition-duration: 1s; -webkit-transition-timing-function: linear; -webkit-transition-delay: 1s; &#125; 注：这里看到了一篇很棒的文档，推荐一下CSS3过渡和动画 CSS3 动画 CSS3，我们可以创建动画，它可以取代许多网页动画图像，Flash动画，和JAVAScripts 属性 @keyframes animation 兼容性 Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性 紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号 属性 Chrome IE Firefox Safari Opera @keyframes 43.0 4.0 -webkit- 10.0 16.0 5.0 -moz- 9.0 4.0 -webkit- 30.0 15.0 -webkit- 12.0 -o- animation 43.0 4.0 -webkit- 10.0 16.0 5.0 -moz- 9.0 4.0 -webkit- 30.0 15.0 -webkit- 12.0 -o- 语法 @keyframes 和 animation 一般配合使用，使用 @keyframes 定义一个动画，使用 animation 去执行这个动画 例子 必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0 12345678910111213141516@keyframes myfirst&#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125;div &#123; animation: myfirst 5s; -webkit-animation: myfirst 5s; /* Safari and Chrome */&#125; 可以以百分比指定动画发生时间 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器 当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变 1234567891011121314151617181920@keyframes myfirst&#123; 0% &#123;background: red;&#125; 25% &#123;background: yellow;&#125; 50% &#123;background: blue;&#125; 100% &#123;background: green;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; 0% &#123;background: red;&#125; 25% &#123;background: yellow;&#125; 50% &#123;background: blue;&#125; 100% &#123;background: green;&#125;&#125;div &#123; animation: myfirst 5s; -webkit-animation: myfirst 5s; /* Safari and Chrome */&#125; 改变背景色和位置 12345678910111213141516171819202122@keyframes myfirst&#123; 0% &#123;background: red; left:0px; top:0px;&#125; 25% &#123;background: yellow; left:200px; top:0px;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0px; top:200px;&#125; 100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; 0% &#123;background: red; left:0px; top:0px;&#125; 25% &#123;background: yellow; left:200px; top:0px;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0px; top:200px;&#125; 100% &#123;background: red; left:0px; top:0px;&#125;&#125;div &#123; animation: myfirst 5s; -webkit-animation: myfirst 5s; /* Safari and Chrome */&#125; CSS3的动画属性 下面的表格列出了 @keyframes 规则和所有动画属性 属性 描述 CSS @keyframes 规定动画。 3 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 3 animation-name 规定 @keyframes 动画的名称。 3 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 3 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 3 animation-delay 规定动画何时开始。默认是 0。 3 animation-iteration-count 规定动画被播放的次数。默认是 1。 3 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 3 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 3 运行myfirst动画，设置所有的属性 1234567891011121314151617div &#123; animation-name: myfirst; animation-duration: 5s; animation-timing-function: linear; animation-delay: 2s; animation-iteration-count: infinite; animation-direction: alternate; animation-play-state: running;/* Safari and Chrome: */ -webkit-animation-name: myfirst; -webkit-animation-duration: 5s; -webkit-animation-timing-function: linear; -webkit-animation-delay: 2s; -webkit-animation-iteration-count: infinite; -webkit-animation-direction: alternate; -webkit-animation-play-state: running;&#125; 与上面的动画相同，但是使用了简写的动画 animation 属性 12345div &#123; animation: myfirst 5s linear 2s infinite alternate; /* Safari and Chrome: */ -webkit-animation: myfirst 5s linear 2s infinite alternate;&#125; CSS3 弹性盒子(Flex Box)详见Flex布局 CSS3用户界面 在 CSS3 中, 增加了一些新的用户界面特性来调整元素尺寸，框尺寸和外边框 属性 resize box-sizing outline-offset 兼容性 表格中的数字表示支持该属性的第一个浏览器版本号 紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号 属性 Chrome IE Firefox Safari Opera resize 4.0 不兼容 5.0 4.0 -moz- 4.0 15.0 box-sizing 10.0 4.0 -webkit- 8.0 29.0 2.0 -moz- 5.1 3.1 -webkit- 9.5 outline-offset 4.0 不兼容 5.0 4.0 -moz- 4.0 9.5 CSS3 调整尺寸 CSS3中，resize属性指定一个元素是否应该由用户去调整大小 语法 resize属性指定一个元素是否是由用户调整大小的 1resize: none|both|horizontal|vertical 值 描述 none 用户无法调整元素的尺寸。 both 用户可调整元素的高度和宽度。 horizontal 用户可调整元素的宽度。 vertical 用户可调整元素的高度。 例子123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;/title&gt;&lt;style&gt; div&#123; border:2px solid; padding:10px 40px; width:300px; resize:both; overflow:auto;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; Firefox, Safari,和 Chrome 兼容 resize 属性.&lt;/p&gt;&lt;div&gt;The resize property specifies whether or not an element is resizable by the user.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS3 方框大小调整 box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容 简单来说就是当需要考虑 width 或者 height 包不包括 padding 和 border 的时候可以考虑使用 box-sizing 例如：box-sizing:border-box的时候，边框和padding包含在元素的宽高之内 语法1box-sizing: content-box|border-box|inherit 值 说明 content-box 这是CSS2.1指定的宽度和高度的行为。指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度。元素的填充和边框布局和绘制指定宽度和高度除外 border-box 指定宽度和高度（最小/最大属性）确定元素边框box。也就是说，对元素指定宽度和高度包括padding和border的指定。内容的宽度和高度减去各自双方该边框和填充的宽度从指定的”宽度”和”高度”属性计算 inherit 指定box-sizing属性的值，应该从父元素继承 例子123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;/title&gt;&lt;style&gt; div.container&#123; width:30em; border:1em solid;&#125;div.box&#123; box-sizing:border-box; -moz-box-sizing:border-box; /* Firefox */ width:50%; border:1em solid red; float:left;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;&lt;div class="box"&gt;This div occupies the left half.&lt;/div&gt;&lt;div class="box"&gt;This div occupies the right half.&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS3 外形修饰 简单来说就是在边框 border 外面又加了一层 outline-offset 轮廓与边框有两点不同： 轮廓不占用空间 轮廓可能是非矩形 语法1outline-offset: length|inherit 值 描述 length 轮廓与边框边缘的距离。 inherit 规定应从父元素继承 outline-offset 属性的值。 ####例子 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;/title&gt;&lt;style&gt; div&#123; margin:20px; width:150px; padding:10px; height:70px; border:2px solid black; outline:2px solid red; outline-offset:15px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; Internet Explorer 不兼容 outline-offset属性.&lt;/p&gt;&lt;div&gt;这个 div有一个轮廓边界15 px边境外的边缘。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS3 媒体查询 媒体查询很多就是用来进行响应式开发了 兼容性 属性 Chrome IE Firefox Safari Opera @media 21.0 9.0 3.5 4.0 9.0 @media语法123@media 媒体类型 and (条件) &#123; &#125; 例子利用媒体查询做响应式布局开发： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt;body &#123; background-color: pink;&#125;@media screen and (max-width: 960px) &#123; body &#123; background-color: darkgoldenrod; &#125;&#125;@media screen and (max-width: 480px) &#123; body &#123; background-color: lightgreen; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;重置浏览器窗口查看效果！&lt;/h1&gt;&lt;p&gt;如果媒体类型屏幕的可视窗口宽度小于 960 px ，背景颜色将改变。&lt;/p&gt;&lt;p&gt;如果媒体类型屏幕的可视窗口宽度小于 480 px ，背景颜色将改变。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>CSS3新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雅虎十四条性能优化原则]]></title>
    <url>%2F%E5%BC%80%E5%8F%91%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[雅虎十四条性能优化原则 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 首先我去看了《雅虎十四条性能优化原则》，当然是看大佬博客翻译过来的，纯英文的我看不懂 Web 应用性能优化黄金法则: 先优化前端程序 (front-end) 的性能,因为这是80% 或以上的最终用户响应时间的花费所在 减少HTTP请求 使用CDN 添加Expires头 压缩组件 将样式表放在头部 将脚本放在底部 避免CSS表达式 使用外部的js和css 减少DNS查找 精简js 避免重定向 删除重复脚本 配置ETag 使Ajax可缓存 原文中写的很详细，但是整个文章结构不是很明显，所以本文总结了下重点，并整理了一下结构，想看更加详细的请移步14条Yahoo（雅虎）十四条优化原则 减少HTTP请求 80%的最终用户响应时间花在前端程序上,而其大部分时间则花在各种页面元素, 如图像、 样式表、 脚本和 Flash 等的下载上 减少页面元素：简化页面设计 image：使用精灵图，配合 background-image 和 background-position实现部分图片 Combined files ：组合多个脚本文件到单一文件，同样的，样式也可以采用类似的方式处理 描述：40-60% 据的日常访问是首次访问,因此为首次访问者加快页面访问速度是用户体验的关键 CDN CDN(Content Delivery Network, 内容分发网络 ) 是地理上分布的web server的集合,用于更高效地发布内容。 通常基于网络远近来选择给具体用户服务的 web server 用户离 web server 的远近对响应时间也有很大影响。从用户角度看,把内容部署到多个地理位置分散的服务器上将有效提高页面装载速度 分布静态内容 使用如Akamai Technologies, Mirror Image Internet, 或 Limelight Networks 等 CDN 服务提供商的服务将是划算的 上面是原文中提供的CDN服务商，但我记得国内百度、阿里应该都有CDN服务，应该也是可用的，但由于使用CDN需要域名备案，我的域名暂未来得及备案，所以暂未测试 Expires Header 通过使用Expires header, 在客户端缓存更多的脚本文件、样式表、图像文件和 Flash Expires header常用于图像文件,但是它也应该用于脚本文件、样式表和 Flash 如果服务器是Apache 的话,您可以使用ExpiresDefault基于当期日期来设置过期日期,如: ExpiresDefault “access plus 10 years设置过期时间为从请求时间开始计算的10 年 注意：如果使用超长的过期时间,则当内容改变时,必须修改文件名称 压缩页面元素 通过压缩HTTP响应内容可减少页面响应时间 Accept-Encoding: gzip, deflate 如果 Web server 检查到 Accept-Encoding 头,它会使用客户端支持的方法来压 缩 HTTP 响应,会设置 Content-Encoding 头,如:Content-Encoding: gzip Gzip 是目前最流行及有效的压缩方法 如果是Apache,在 1.3 版本下需 使用 mod_gzip 模块,而在 2.x 版本下,则需使用mod_deflate Web server 根据文件类型来决定是否压缩: 一般HTML、脚本文件、样式表文件等进行压缩 图像文件和 PDF 文件一般不应该被压缩,因为它 们本来就是压缩格式保存的 把样式表放在头部 浏览器会阻塞显示直到样式表下载完毕,因此我们需要把样式表放在 HEAD部分 把样式表移到HEAD部分可以提高界面加载速度 把脚本文件放在底部 我们需尽量把它们放在页面的底部,这样一方面能顺序显示,另方面可达到最大的并行下载 脚本阻塞并行下载数量，HTTP/1.1 规范建议浏览器每个主机的并行下载数不超过2 个。 因此如果您把图像文件分布到多台机器的话,就可以达到超过2个的并行下载 但是当脚本文件下载时,浏览器不会启动其他的并行下载,甚至其他主机的下载也不启动 所以直接将脚本放在底部 避免 CSS 表达式 CSS 表达式是功能强大的(同时也是危险的)用于动态设置CSS属性的方式 直接以明确的数值来写，不写表达式 如果必须动态设置的话,可使用事件处理函数代替 把JavaScript和CSS放到外部文件中 在现实世界中,使用外部文件会加快页面显示速度,因为外部文件会被浏览器缓存 减少DNS查询次数 DNS用于映射主机名和IP地址,一般一次解析需要 20~120 毫秒 把内容分布到至少2 个,最多4个不同的主机名上 最小化JavaScript代码 最小化JavaScript代码指在JS代码中删除不必要的字符,从而降低下载时间 两个流行的工具是JSMin 和YUI Compressor 它通过删除注释和空格来减少源码大小,同时它还可以对代码进行混淆处理。 作为混淆的一部分,函数名和变量名被替换成短的字符串,这使得代码更紧凑,同时也更难读,使得难于被反向工程 Dojo Compressor (ShrinkSafe)是最常见的混淆工具 内嵌的脚本代码也应该被最小化 避免重定向 重定向功能是通过301和302这两个HTTP状态码完成的 在 Apache 下,可以通过Alias,mod_rewrite或 DirectorySlash 等方式来解决该问题 删除重复的脚本文件 在一个页面中包含重复的JS脚本文件会影响性能,即它会建立不必要的HTTP请求和额外的JS执行 一个避免重复的脚本文件的方式是使用模板系统来建立脚本管理模块。。 除了防止 重复的脚本文件外,该模块还可以实现依赖性检查和增加版本号到脚本文件名中,从而实现超长的过期时间 配置 ETags ETags 是用于确定浏览器缓存中元素是否与 Web server 中的元素相匹配的机制, 它是比 last-modified date 更灵活的元素验证机制 如果您未用到 ETags 系统提供的灵活的验证机制,最好删除 ETag。删除 ETag会减少 http response 及后续请求的 HTTP 头的大小 缓存 Ajax 性能优化法则同样适用于web 2.0 应用。提高Ajax的性能最重要的方式是使得其response 可缓存 总结说实话，以上的十四条，有些是我没看懂的，例如Expires Header和配置 ETags，先记录在这里，其实依照我对Web前端开发的理解，也总结出一些优化原则，也可能与上面的有些重复，但可能会更好理解一些 我的优化原则HTML 避免使用table，因为table要等其中内容完全下载之后才显示，显然是比div+css慢的 css 提取css，分离到单独的页面 当需要设置的样式有很多时，设置className而不是直接操作style 删除多余的选择器 利用工具最小化css文件，删除多余空格、符号等 css文件一般放在头部，link中 js 提取js，分离到单独的页面 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 多次使用的DOM节点的结果，要变量本地化，减少IO读取操作 尽量少用全局变量 删除多余的脚本 删除多余的变量、函数等 利用工具最小化js文件，删除多余空格、符号等 一般脚本放在页面底部 图片处理 可以使用icon字体图标代替的图片尽量使用icon字体图标 尽量用css3代替， 比如说要实现修饰效果，如半透明、边框、圆角、阴影、渐变等 优化图片格式为常用格式 精灵图 用CSS或JavaScript实现预加载 在保证最不失真的情况下尽可能压缩图像文件的大小 网络加速 CDN托管]]></content>
      <tags>
        <tag>雅虎十四条性能优化原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中sessionStorage 、localStorage 和 Cookie]]></title>
    <url>%2Fjavascript%E4%B8%ADsessionStorage-%E3%80%81localStorage-%E5%92%8C-cookie%2F</url>
    <content type="text"><![CDATA[javascript中sessionStorage 、localStorage 和 Cookie 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 参考文章：JS 详解 Cookie、 LocalStorage 与 SessionStorage 下面是个人总结内容： 相同点 用于浏览器端存储的缓存数据 不同点 特性 Cookie localStorage sessionStorage 数据的生命期 可设置的失效时间，到达时间自动过期 除非被清除，否则永久保存 仅用于当前会话，浏览器关闭，立即被清除 存放数据大小 4K左右 一般为5MB 一般为5MB 与服务器端通信 携带在HTTP头中，数据会发送到服务器端，可能造成宽带浪费 只在客户端，不参与和服务端的通信 只在客户端，不参与和服务端的通信 易用性 需程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 应用场景Cookie： 1. 最好精简，因为本身存放数据大小很小 2. 常用于判断用户登录，对于登录过的用户，浏览器会插入一个唯一的标识，当下次用户需要登录，只要读取到这个值，就能判断当前用户是否登录了 localStorage: 1. 购物车管理工作，一些产生的本地数据用以完成数据持久化 sessionStorage： 多页面表单，按步骤引导用户填写 安全性 Cookie、localStorage 和 sessionStorage三者，只要打开控制台，都能看到这三者存放的数据的，并且能够随意修改，所以会产生风险 而sessionStorage使用了session加密，这样用户看到的数据都是经过加密处理过的，会难以获取正确的标识 但是对于localStorage或者Cookie的数据，就可以被肆意妄为的修改或者伪造了 上面是我个人的一些理解，文章中还提到了XSS注入的风险，关于XSS注入为此我专门查了些文档，推荐一篇自我感觉写的相当详细的Web安全测试之XSS Web Storage AND Cookie 前者存储空间更大 前者存储内容不会发送到服务器，防止造成宽带浪费 接口丰富 独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，避免造成数据混乱 每个特定的域名下最多生成20个cookie sessionStorage用于本地存储一个会话存储，关闭会话，随之销毁 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的 Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地存储数据而生 一些基本操作 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 setItem存储value 用于存储对象格式的数据 12sessionStorage.setItem("key", "value"); localStorage.setItem("site", "qqqww"); getItem获取value 获取指定关键字段key本地存储的值 12var value = sessionStorage.getItem("key"); var site = localStorage.getItem("site"); removeItem删除key 删除指定关键字段key本地存储的值 12sessionStorage.removeItem("key"); localStorage.removeItem("site"); clear清除所有的key/value 清除所有本地的key/value 12sessionStorage.clear(); localStorage.clear(); 其他操作方法：点操作和[ ] web Storage不但可以用自身的setItem`,getItem`等方便存取，也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储 12345var storage = window.localStoragestorage.key1 = "hello"storage["key2"] = "world" console.log(storage.key1)console.log(storage["key2"]) 遍历 localStorage和sessionStorage的key和length属性实现遍历 sessionStorage和localStorage提供的key()和length可以方便的实现存储的数据遍历 123456var storage = window.localStorage;for(var i=0, len=storage.length; i&lt;len;i++)&#123; var key = storage.key(i); var value = storage.getItem(key); console.log(key + "=" + value); &#125;]]></content>
      <tags>
        <tag>sessionStorage 、localStorage 和 cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typeof VS instanceof]]></title>
    <url>%2Fjavascript%E4%B8%ADtypeof%E4%B8%8Einstanceof%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[typeof VS instanceof 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的 区别：前者判断数据类型较多，后者判断一个变量是否属于某个对象实例 typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。 细节： typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined typeof 来获取一个变量是否存在，如if(typeof a!=&quot;undefined&quot;){alert(&quot;ok&quot;)}，而不要去使用 if(a)因为如果a不存在（未声明）则会出错。 对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。 Instanceof定义和用法：instanceof用于判断一个变量是否属于某个对象的实例。 实例演示： 123var a = new Array(); alert(a instanceof Array); // truealert(a instanceof Object) // true 如上，会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为Array 是 object 的子类 123function test()&#123;&#125;;var a = new test();alert(a instanceof test) // true]]></content>
      <tags>
        <tag>typeof  VS  instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中跨域问题]]></title>
    <url>%2Fjavascript%E4%B8%AD%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[javascript中跨域问题 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域 产生跨域的情况 网络协议不同，如http协议访问https协议 端口不同，如80端口访问8080端口 域名不同，如qqqww.com访问baidu.com 子域名不同，如abc.qqqww.com访问def.qqqww.com 域名和域名对应ip，如www.qqqww.com访问192.168.0.112 跨域请求资源的方法proxy代理定义和用法： proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。 实现方法：通过nginx代理 注意： 如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功 CORS定义和用法：CORS (Cross-Origin Resource Sharing) 是现代浏览器支持跨域资源请求的一种最常用的方式。 使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下： 123456res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html; charset=UTF-8&quot;, &quot;Access-Control-Allow-Origin&quot;:&apos;http://localhost&apos;, &apos;Access-Control-Allow-Methods&apos;: &apos;GET, POST, OPTIONS&apos;, &apos;Access-Control-Allow-Headers&apos;: &apos;X-Requested-With, Content-Type&apos;&#125;); jsonp定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下） 特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。 实例： 1234567891011&lt;script&gt; function testjsonp(data) &#123; console.log(data.name); // 获取返回的结果 &#125;&lt;/script&gt;&lt;script&gt; var _script = document.createElement('script'); _script.type = "text/javascript"; _script.src = "http://localhost:8888/jsonp?callback=testjsonp"; document.head.appendChild(_script);&lt;/script&gt; 缺点： 1、这种方式无法发送post请求（这里） 2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的闭包]]></title>
    <url>%2Fjavascript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[javascript中的闭包 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包 实例 根据作用域链的规则，底层作用域没有声明的变量，会向上一级查找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined，这里明显count 是函数内部的flag2 的那个count 1234567891011var count = 10 //全局作用域 标记为flag1function add () &#123; var count = 0 //函数全局作用域 标记为flag2 return function()&#123; count += 1 //函数的内部作用域 alert(count) &#125;&#125;var s = add()s() //输出1s() //输出2 ##变量的作用域 变量的作用域分类：全局变量和局部变量 特点： 函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量 函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量 使用闭包的注意点： 滥用闭包，会造成内存泄漏：由于标识为flag2的count被闭包所引用，所以在内存中不会被回收，造成内存泄漏 会改变父函数内部变量的值：所以，如果把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值]]></content>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中数组操作]]></title>
    <url>%2Fjavascript%E4%B8%AD%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[javascript中Array相关的属性和方法 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ Array 对象属性constructor : 返回对创建此对象的数组函数的引用 1234var test=new Array()if (test.constructor==Array)&#123; document.write("This is an Array")&#125; length 设置或返回数组中元素的数目。 prototype 可以向构造函数的原型对象添加属性和方法 Array对象方法concat()连接两个或更多的数组，并返回结果 1234var arr = [1,2,3,4];var arr2 = [5,6,7,8];var arr3 = arr.concat(arr2);console.log(arr3); // 连接之后返回的数组为：[1, 2, 3, 4, 5, 6, 7, 8] join()把数组的所有元素放入一个字符串，元素通过指定的分隔符进行分隔 123var arr = ['xiao','lin','qiqi','mingtian'];var arr2 = arr.join(',');console.log(arr2); // 根据','隔开返回的字符串为："xiao,lin,qiqi,mingtian" pop() 删除并返回数组的最后一个元素 1234var arr = [2,3,4,5];var arr2 = arr.pop();console.log(arr2); // 删除的数组的最后一个元素为：5console.log(arr); // 删除元素之后的数组为：[2, 3, 4] shift()删除并返回数组的第一个元素 1234var arr = [2,3,4,5];var arr2 = arr.shift();console.log(arr2); // 删除的数组的第一个元素为：2console.log(arr); // 删除元素之后的数组为：[3, 4，5] push()向数组的末尾添加一个或更多元素，并返回新的长度 1234var arr = [2,3,4,5];var arr2 = arr.push(6);console.log(arr2); // 返回的数组长度：5 console.log(arr); // [2, 3, 4, 5, 6] unshift()向数组的开头添加一个或更多元素，并返回新的长度 1234var arr = ['xiao','ming','qiqi','aiming'];var arr1 = arr.unshift('lang');console.log(arr1); // 返回的数组的长度： 5console.log(arr); //向数组开头添加元素返回的结果：["lang", "xiao", "ming", "qiqi", "aiming"] reverse()颠倒数组中元素的顺序 123var arr = [2,3,4,5];arr.reverse();console.log(arr); // [5, 4, 3, 2] slice()从某个已有的数组返回选定的元素 1234var arr = [2,3,4,5];var arr2 = arr.slice(1,3);console.log(arr2); // 截取区间返回的数组为：[3, 4]console.log(arr); // [2, 3, 4, 5] sort()对数组的元素进行排序 1234567891011121314151617// 借助排序函数，实现数值由小到大排序function sortNumber(a,b)&#123; return a - b&#125;var arr = [23,30,42,5];var arr2 = arr.sort(sortNumber);console.log(arr2); // [5, 23, 30, 42]console.log(arr); // [5, 23, 30, 42]// 借助排序函数，实现数值由大到小排序function sortNumber(a,b)&#123; return b - a&#125;var arr = [23,30,42,5];var arr2 = arr.sort(sortNumber);console.log(arr2); // [42, 30, 23, 5]console.log(arr); // [42, 30, 23, 5] splice()删除元素，并向数组添加新元素。 123456789// 创建一个新数组，并向其添加一个元素var arr = [1,2,3,4];arr.splice(2,0,5);console.log(arr); // [1, 2, 5, 3, 4]// 删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素：var arr = [1,2,3,4];arr.splice(2,1,5);console.log(arr); // [1, 2, 5, 4] toSource()返回该对象的源代码 123456789101112// 浏览器支持// 只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。&lt;script type="text/javascript"&gt;function employee(name,job,born)&#123; this.name=name; this.job=job; this.born=born;&#125;var bill = new employee("Bill Gates","Engineer",1985);document.write(bill.toSource());&lt;/script&gt;// 输出：(&#123;name:"Bill Gates", job:"Engineer", born:1985&#125;) toString()把数组转换为字符串，并返回结果 123var arr = ['xiao','ming','qiqi','aiming'];arr.toString();console.log(arr); // ["xiao", "ming", "qiqi", "aiming"] toLocaleString()把数组转换为本地数组，并返回结果 123var arr = ['xiao','ming','qiqi','aiming'];arr.toLocaleString();console.log(arr); // ["xiao", "ming", "qiqi", "aiming"] valueOf()返回数组对象的原始值 123var arr = ['xiao','ming','qiqi','aiming'];arr.valueOf('lang');console.log(arr); // ["xiao", "ming", "qiqi", "aiming"] Array部分方法实现数组元素去重方法一： 思路： 1. 定义一个 json 对象 2. 遍历数组，将 arr[i] 作为 json 的键 3. 若 不重复，则给对应 arr[i] 的键值为 1 作为后面判断的标识，并 push 到新数组 arr1 中，若重复，则删除 123456789var arr = [1, 2, 3, 2, 1, 5, 6, 3, 3, 2, 1, 7, 9, 8,6] var arr1 = [] var json = &#123;&#125; for (var i = 0; i &lt; arr.length; i++) &#123; if (!json[arr[i]]) &#123; json[arr[i]] = 1 arr1.push(arr[i]) &#125; &#125; 方法二： 思路： 定义一个新数组 arr1 如果这个新数组中没有这个元素，则 push 1234567var arr = [1, 2, 3, 2, 1, 5, 6, 3, 3, 2, 1, 7, 9, 8,6] var arr1 = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (arr1.indexOf(arr[i]) &lt; 0) &#123; arr1.push(arr[i]) &#125; &#125; 方法三：filter filter的接收回调，可以有多个参数回调可以接收三个参数，第一个是数组中的元素，第二个是位置，第三个是数组本身 利用filter过滤器，总是返回元素第一个位置 去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了 12345var arr = [1, 2, 3, 2, 1, 5, 6, 3, 3, 2, 1, 7, 9, 8,6] var arr1 = arr.filter(function(ele, index, self) &#123; return self.indexOf(ele) === index &#125;) console.log(arr1) 数组最值方法一：Math.max.apply And Math.min.apply 1234567方法一：Math.max.apply var iMax = 0 var iMin = 0 var arr = [1, 268, 5, 4, 9, 0, 68] iMax = Math.max.apply(null, arr) iMin = Math.min.apply(null, arr) console.log(iMax, iMin) 方法二：：Math.max.call And Math.min.call 123456var iMax = 0 var iMin = 0 var arr = [1, 268, 5, 4, 9, 0, 68] iMax = Math.max.call(null, 1, 268, 5, 4, 9, 0, 68) iMin = Math.min.call(null, 1, 268, 5, 4, 9, 0, 68) console.log(iMax, iMin) 方法三：循环比较 123456789101112var iMax = 0var iMin = 0var arr = [1, 268, 5, 4, 9, 0, 68]for (var i = 0; i &lt; arr.length; i++) &#123; if (iMax &lt; arr[i]) &#123; iMax = arr[i] &#125; if (iMin &gt; arr[i]) &#123; iMin = arr[i] &#125;&#125;console.log(iMax, iMin) 数组排序sort原理：在不带参数的情况下sort()方法默认会将数组元素当作string类型来升序排序,根据它们的unicode码从小到大依次排列，如果想按照自己的条件进行排序，需要传一个比较函数 1234567891011var arr = [1, 268, 5, 4, 9, 0, 68] // 从小到大 arr.sort(function (a, b) &#123; return a - b &#125;) console.log(arr) // 从大到小 arr.sort(function (a, b) &#123; return b - a &#125;) console.log(arr) 冒泡排序思路：每次比较相邻的两个数，如果后一个比前一个小，换位置。如果要实现由大到小排序，使用reverse()即可； 1234567891011121314var a = [1, 268, 5, 4, 9, 0, 68, 67, 69, 96, 14, 78, 100, 25, 42, 23, 32, 68, 89, 98, 1] var temp = 0 for (var i = 0; i &lt; a.length; i++) &#123; for (var j = 0; j &lt; a.length - i; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; temp = a[j] a[j] = a[j + 1] a[j + 1] = temp &#125; &#125; &#125; var b = a.reverse() console.log(a) 快速排序思路：采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边。 1234567891011121314151617181920var arr = [1, 268, 5, 4, 9, 0, 68, 67, 69, 96, 14, 78, 100, 25, 42, 23, 32, 68, 89, 98, 1]function quickSort(arr) &#123; if(arr.length == 0) &#123; return []; // 返回空数组 &#125; var arrL = [] var arrR = [] var index = Math.floor(arr.length / 2) var arrM = arr.splice(index, 1) // 返回被删除的数 for (var i = 0; i &lt; arr.length; i++) &#123; if (arrM &gt; arr[i]) &#123; arrL.push(arr[i]) &#125; else &#123; arrR.push(arr[i]) &#125; &#125; // console.log(arrL.concat(arrR)) return quickSort(arrL).concat(arrM, quickSort(arrR))&#125;console.log(quickSort(arr)) 数组翻转(非reverse)方法一： 删除数组最后一个元素并返回被删除的元素 12345678var arr = [1,2,3,4];var arr2 = [];while(arr.length) &#123; var num = arr.pop(); //删除数组最后一个元素并返回被删除的元素 arr2.push(num);&#125;console.log(arr2);// [4, 3, 2, 1] 方法二： 删除数组第一个元素并返回被删除的元素 1234567var arr = [1,2,3,4];var arr2 = [];while(arr.length)&#123; var num = arr.shift(); //删除数组第一个元素并返回被删除的元素 arr2.unshift(num);&#125;console.log(arr2);]]></content>
      <tags>
        <tag>Array相关的属性和方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中字符串操作]]></title>
    <url>%2Fjavascript%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[javascript中字符串操作 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ String : 1. javascript检测字符串 2. javascript去除字符串空格 3. URL中查询字符串中的参数 4. javascript字符串的常用函数 检测string类型方法一：typeof 123function isString (str) &#123; return typeof (str) === 'string' ? true : false&#125; 方法二：constructor 123function isString (str) &#123; return str.constructor === String ? true : false&#125; 去除字符串空格方法一：replace() 使用replace匹配正则，\s匹配任何空白字符,包括空格、制表符、换页符等等 12345var str = ' aaaa bcs dsda 'str = str.replace(/\s*/g, '') // 去除所有空格str = str.replace(/^\s|\s$/g, '') // 去除两头空格str = str.replace(/^\s/g, '') // 去除左空格str = str.replace(/\s$/g, '') // 去除右空格 方法二：trim() 局限：无法去除中间的空格 12var str = ' aaaa bcs dsda 'str = str.trim() // aaaa bcs dsda 获取URL中查询字符串参数split 测试地址为：http://www.runoob.com/jquery/misc-trim.html?channelid=12333&amp;name=xiaoming&amp;age=23 123456// window.location.href = "http://www.runoob.com/jquery/misc-trim.html?channelid=12333&amp;name=xiaoming&amp;age=23"var a = window.location.hrefvar b = a.split('?') // b[1] = "channelid=12333&amp;name=xiaoming&amp;age=23"var c = b[1].split('&amp;')for (var i = 0; i &lt; c.length; i++) &#123; console.log(c[i].split('=')) &#125;// 此时可遍历出 ? 后面参数的每一项 其他常用字符串函数 concat() – 将两个或多个字符的文本组合起来，返回一个新的字符串。 indexOf() – 返回字符串中一个子串第一处出现的索引。如果没有匹配项，返回 -1 。 charAt() – 返回指定位置的字符。 lastIndexOf() – 返回字符串中一个子串最后一处出现的索引，如果没有匹配项，返回 -1 。 match() – 检查一个字符串是否匹配一个正则表达式。 substr() 函数 – 返回从string的startPos位置，长度为length的字符串 substring() – 返回字符串的一个子串。传入参数是起始位置和结束位置。 slice() – 提取字符串的一部分，并返回一个新字符串。 replace() – 用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 search() – 执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。 split() – 通过将字符串划分成子串，将一个字符串做成一个字符串数组。 length – 返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。 toLowerCase() – 将整个字符串转成小写字母。 toUpperCase() – 将整个字符串转成大写字母。 看下面控制台输出结果：]]></content>
      <tags>
        <tag>javascript字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中call与apply的区别]]></title>
    <url>%2Fjavascript%E4%B8%ADcall%E4%B8%8Eapply%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[javascript中call与apply的区别 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为： 12345/*apply()方法*/function.apply(thisObj[, argArray])/*call()方法*/function.call(thisObj[, arg1[, arg2[, [,...argN]]]]); 它们各自的定义apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。 call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。 ##它们的共同之处： 都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。 它们的不同之处apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。 call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。 示例（1）基本用法 12345678910111213function add(a,b)&#123; return a+b; &#125;function sub(a,b)&#123; return a-b; &#125;var a1 = add.apply(sub,[4,2]); //sub调用add的方法var a2 = sub.apply(add,[4,2]);alert(a1); //6 alert(a2); //2/*call的用法*/var a1 = add.call(sub,4,2); （2）实现继承 12345678910111213141516function Animal(name)&#123; this.name = name; this.showName = function()&#123; alert(this.name); &#125; &#125;function Cat(name)&#123; Animal.apply(this,[name]); &#125;var cat = new Cat("咕咕");cat.showName();/*call的用法*/Animal.call(this,name); （3）多重继承 12345678910111213141516171819202122function Class10()&#123; this.showSub = function(a,b)&#123; alert(a - b); &#125; &#125;function Class11()&#123; this.showAdd = function(a,b)&#123; alert(a + b); &#125; &#125;function Class12()&#123; Class10.apply(this); Class11.apply(this); // Class10.call(this); //Class11.call(this); &#125;var c2 = new Class12();c2.showSub(3,1); //2c2.showAdd(3,1); //4 apply的一些其他巧妙用法（1）Math.max 可以实现得到数组中最大的一项 因为Math.max不支持Math.max([param1,param2])也就是数组，但是它支持Math.max(param1,param2...)，所以可以根据apply的特点来解决 var max=Math.max.apply(null,array)，这样就轻易的可以得到一个数组中的最大项（apply会将一个数组转换为一个参数接一个参 数的方式传递给方法） 这块在调用的时候第一个参数给了null，这是因为没有对象去调用这个方法，我只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个null过去。 用这种方法也可以实现得到数组中的最小项：Math.min.apply(null,array) （2）Array.prototype.push可以实现两个数组的合并 同样push方法没有提供push一个数组，但是它提供了push(param1,param2...paramN)，同样也可以用apply来转换一下这个数组，即： 123var arr1=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);var arr2=new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;);Array.prototype.push.apply(arr1,arr2); //得到合并后数组的长度，因为push就是返回一个数组的长度 也可以这样理解，arr1调用了push方法，参数是通过apply将数组转换为参数列表的集合 通常在什么情况下，可以使用apply类似Math.max等之类的特殊用法： 一般在目标函数只需要n个参数列表，而不接收一个数组的形式，可以通过apply的方式巧妙地解决这个问题 其实看上面两张图打印的结果不难发现，我们的apply和call的第一个参数位置就是调用者，假如arr1在第一个参数位置，就是arr1调用了xxxx,那么相当于arr1此时拥有了xxx的方法，我们举个例子，例如Array.prototype.push.apply(arr1,arr2)就是arr1调用了Array.prototype.push方法]]></content>
      <tags>
        <tag>call与apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript对象冒充实现继承]]></title>
    <url>%2Fjavascript%E5%AF%B9%E8%B1%A1%E5%86%92%E5%85%85%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[javascript中的继承 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 面向对象的基本特征有：封闭、继承、多态 在JavaScript中实现继承的方法： 原型链（prototype chaining） call()、apply() 混合方式(prototype和call()/apply()结合) 对象冒充 javascript对象冒充实现继承本质上就是改变this指向 对象冒充原理: 构造函数使用this关键字给所有属性和方法赋值.因为构造函数只是一个函数,所以可使ClassA的构造方法称为ClassB的方法,然后调用它. ClassB就会收到ClassA的构造方法中定义的属性和方法. 例子: 1234567891011121314151617181920function ClassA(name)&#123; this.name=name; this.getName=function()&#123; return this.name; &#125;&#125;function ClassB(name,password)&#123; this.ClassA=ClassA; this.ClassA(name); delete this.ClassA; this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125;var b =new ClassB('wwww','1123');document.write(b.getName()); 经过调试,我们可以看到: 变量b中已经包含了ClassA中定义的方法. 代码理解: 在ClassB中,this.ClassA(name)等价于以下代码: 1234this.name=name; this.getName=function()&#123; return this.name; &#125; 所以将ClassA函数中的代码复制过来,即:ClassB中的代码如下: 123456789101112131415function ClassB(name,password)&#123; this.ClassA=ClassA; this.name=name; this.getName=function()&#123; return this.name; &#125; delete this.ClassA; this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125; 然后通过delete this.ClassA之后,ClassB中的实际代码如下: 1234567891011function ClassB(name,password)&#123; this.name=name; this.getName=function()&#123; return this.name; &#125; this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125; 从而实现了对象冒充. 注意: 对象冒充可以支持多重继承,也就是说一个类可以继承多个类.例子如下: 123456789function ClassC()&#123; this.ClassX=ClassX; this.ClassX(); delete this.ClassX; this.ClassY=ClassY; this.ClassY(); delete this.ClassY;&#125; 这样就ClassC就实现了继承自ClassX,ClassY.但此处存在一个弊端: 若ClassX和ClassY中存在两个同名的变量或方法,则ClassY会覆盖ClassX中的变量或方法. 此外: 我们还可以通过call()和apply()方法实现对象冒充. call方法 它的第一个参数用做this的对象,其他参数都直接传递给函数自身.我们来看下面这个小例子: 1234567891011function ShowColor(param1,param2)&#123; this.getColor=function()&#123; document.write(this.color+"&lt;br/&gt;Two Params : "+param1+" ; "+param2); &#125;&#125;var obj = new Object;obj.color='Red';ShowColor.call(obj,"pm1",'pm2');obj.getColor(); 运行此段代码后,我们发现页面上显示为: 解释: ShowColor方法是在对象外定义的,调用call时,它将第一个参数,也就是将ClassA的this指向了obj,将后面的参数”pm1”传递给了param1,’pm2’传递给了param2. 123var obj = new Object;obj.color='Red';ShowColor.call(obj,"pm1",'pm2'); 也就实现了以下效果: 我们将上面代码中的obj.color=’Red’给注释起来,再运行代码,结果如下: 原因是obj并没有color属性,而obj.getColor()方法中需要this.color,即obj.color,所以会出现undefined的结果. 我们再来看如何利用call来实现对象冒充,继续以刚才的ClassA,ClassB为例: 1234567891011121314151617181920function ClassA(name)&#123; this.name=name; this.getName=function()&#123; return this.name; &#125; &#125;function ClassB(name,password)&#123; //this.ClassA=ClassA; //this.ClassA(name); //delete this.ClassA; ClassA.call(this,name); this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125;var b = new ClassB('www','111');b.getPassword(); 调试效果: 解释: 此处的ClassA.call(this,name); 即将ClassA的this指向了ClassB的this.从而实现了对象冒充. apply方法 apply方法有两个参数,用作this的对象和要传传递给函数的参数的数组. 例子: 1234567891011function ShowColor(param1,param2)&#123; this.getColor=function()&#123; document.write(this.color+"&lt;br/&gt;Two Params : "+param1+" ; "+param2); &#125;&#125;var obj = new Object;obj.color='Red';ShowColor.apply(obj,new Array("pm1",'pm2'));obj.getColor(); 此方法可以被用于对象冒充: 123456789101112131415161718192021function ClassA(name)&#123; this.name=name; this.getName=function()&#123; return this.name; &#125; &#125;function ClassB(name,password)&#123; //this.ClassA=ClassA; //this.ClassA(name); //delete this.ClassA; ClassA.apply(this,new Array(name)); this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125;var b = new ClassB('www','111');b.getPassword(); 调试效果: 原型继承 Javascript对象的创建和继承使用了一套特别的模式,称作原型式继承. 原理是:对象的构造函数可以从其他对象中继承方法,它创建出一个原型对象后,所有其他的新对象都可以基于这个原型对象来构建. 原型本身并不会从其他原型或者构造函数中继承属性,而属性都是从实际对象那里继承过来的. 例1: 1234567891011121314151617function Person(name)&#123; this.name=name;&#125;Person.prototype.GetName=function()&#123; return this.name;&#125;function User(name,password)&#123; this.name = name; this.password = password;&#125;User.prototype = new Person();User.prototype.GetPassword=function()&#123; return this.password;&#125; 解释: User.prototype = new Person();这句话如何理解呢?User是对User对象构造函数的引用,new Person()使用person构造函数创建了一个Person对象,然后把Person对象的原型置为这个操作的结果.也就是说,当每次new User()时,得到的新User对象都会带有Person对象的所有方法]]></content>
      <tags>
        <tag>冒充对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript垃圾回收机制与内存管理]]></title>
    <url>%2Fjavascript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[垃圾回收机制与内存管理 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ Js具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。 什么是垃圾回收机制 垃圾回收机制（GC:Garbage Collection）： JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码在执行环境过程中使用的内存。垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性的执行这一操作。 垃圾回收机制的作用内存释放： 将某个不再被使用的变量所占用的内存释放掉，是为了不让内存总是被消耗而被没有释放，导致整个系统无法支持更为庞大的运算 垃圾回收机制不是总是那么高效，其不是总在运行，因此有时需要我们人为的释放被占用的内存，从而使程序能够支持更为庞大的运算，能够接受更为巨量的数据运算。 垃圾回收机制的原理垃圾收集机制的原理： 找出那些不再继续使用的变量，然后释放其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行 实例123456789101112131415function fn1 () &#123; var obj = &#123; name: 'zhangsan', age: 10 &#125;&#125;function fn2 () &#123; var obj = &#123; name: 'lisi', age: 11 &#125; return obj&#125;var a = fn1() var b = fn2() fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放 垃圾回收机制的标记策略 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略：标记清除、引用计数。 标记清除 1. 当变量进入环境时，将其标记为“进入环境”，当变量离开环境时，将其标记为“离开环境”（常用） 2. 某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量 3. 到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同 引用计数 跟踪记录每个值被引用的次数 当声明一个变量a并将一个引用类型的值赋给该变量时，这个值引用次数就是1 如果同一个引用类型的值又被赋给另一个变量b，则该值的引用次数加1，相反，如果包含这个值引用的变量a又取得了另一个值（也就是前面的引用被覆盖，不再引用前面那个值），则这个值的引用次数减1。 当这个值的引用次数变成0时，则说明没有办法再访问这个值，因而就可以将其占用的内存空间回收回来 少见，几乎不用，除了早版IE的元素JS，因为会出现循环引用的问题 1`var` `a = obj1;``var` `b = boj1;``//这是obj1的引用次数应该为2``var` `a = obj2;``//这是obj1的引用次数为1，obj2的引用次数也为1` 垃圾回收机制与内存管理 垃圾回收器是周期运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。触发方式的改善很重要 堆和栈 堆和栈空间分配区别： 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈 堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表 堆和栈空间存放数据类型的区别： 栈：基本类型是：Undefined/Null/Boolean/Number/String，基本类型的值存在内存中，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副 堆：引用类型：object，Array，function等，引用类型的值是对象类型，保存在堆内存中 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象 js操作对象就是在操作对象的引用，而不是在操作实际的对象 堆和栈缓存方式区别： 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放 堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些 堆和栈数据结构区别： 堆（数据结构）：堆可以被看成是一棵树，如：堆排序 栈（数据结构）：一种先进后出的数据结构 管理内存 虽然说使用具备垃圾回收机制的语言写程序，开发人员一般不必操心内存管理的问题。但是JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同的，其中最主要的问题之一，就是出于对安全方面考虑，防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃，所以分配给Web浏览器的内存数量通常比分配给桌面应用的程序少 内存泄漏 虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏 那么什么情况会引起内存泄漏呢？ 意外的全局变量引起的内存泄漏 123function fn () &#123; fn1 = 'xxxxxx';//fn 成为一个全局变量，不会被回收&#125; 原因：全局变量不会被回收 解决：使用严格模式(因为严格模式定义的变量都有其单独的作用域) 闭包引起的内存泄漏 123456var fn = (function()&#123; var fn1 = 'xxxxxx'; // 被闭包所引用，不会被回收 return function()&#123; console.log(fn1); &#125;&#125;)() 原因：闭包可以维持函数内部局部变量，使其得不到释放 解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对DOM的引用 DOM清空或删除时，事件未清除导致的内存泄漏 案例一： 12&lt;div id="container"&gt; &lt;/div&gt; 123$('#container').bind('click', function()&#123; console.log('click');&#125;).remove(); 案例二： 123&lt;div id="myDiv"&gt; &lt;input type="button" value="Click me" id="myBtn"&gt;&lt;/div&gt; 1234var btn = document.getElementById("myBtn");btn.onclick = function()&#123; document.getElementById("myDiv").innerHTML = "Processing...";&#125; 原因：虽然DOM被清空或者删除了，但是对象中还存在对DOM的引用 解决一：zepto 和 原生 js 下，#container dom 元素，还在内存里 jquery 的 empty 和 remove 会帮助开发者避免这个问题 123$('#container').bind('click', function()&#123; console.log('click');&#125;).off('click').remove(); 解决二：手动删除 12345var btn = document.getElementById("myBtn");btn.onclick = function()&#123; btn.onclick = null; document.getElementById("myDiv").innerHTML = "Processing...";&#125; 子元素存在引用引起的内存泄漏 原因：上图 黄色是指直接被 js变量所引用，在内存里 红色是指间接被 js变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的 子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除 解决：手动删除 被遗忘的定时器或者回调引起的内存泄漏 原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom 解决：手动删除定时器 总结 占用最少的内存可以让页面获得更好的性能，而优化内存占用最佳方式，就是执行中的代码只保留必要的数据（占用必要的内存）。 一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动解除引用。 解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾回收器下次运行时将其回收 12345678function getPerson (name) &#123; var privatePerson = new Object() privatePerson.name = name return privatePerson&#125;var globalPerson = getPerson('zhangsan')// 此时调用了函数getPerson，使得返回的对象privatePerson会被全局变量globalPerson所指向，所以该块内存并不会被释放，可以手动`globalPerson = null`来释放内存]]></content>
      <tags>
        <tag>垃圾回收机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github上contributions统计错误]]></title>
    <url>%2Fgithub%E4%B8%8Acontributions%E7%BB%9F%E8%AE%A1%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[为什么你的github上contributions那么少或者不更新 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 前段时间还没注意，今天去看了下我的contributions，结果令我惊讶，统计的只有20个，然后我去查了什么会产生contributions,结果更匪夷所思，上面明确室友写到自己的仓库自己的commit是会产生contributions的，这么一想，我仅仅commit了也至少几百次吧，怎么就只有20呢？下面是研究和解决问题过程~~ 详情见官网https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/，如果对官网纯英文理解不深，请看我本篇人类的语言 基本概念想必能搜到这文章的老铁们，大概是对github已经有一定的了解了，那么什么是contributions呢？ 下面来自官网的官方说法： Your GitHub profile shows off your pinned repositories as well as a graph of your repository contributions over the past year. 人类的语言： 就是在github库（repository）中所做的贡献统计，那么怎么才能有贡献呢？ 什么操作会统计在contributionsIssues 和 pull requests 需要满足： 1. 一年之内 2. 独立的仓库，不能是`fork`来的 commits 需要满足： 一年之内 commits使用的email地址是与你的Github账号相关联的 独立仓库，不是fork来的 这些commits是在 默认分支（通常是master） 在gh-pages分支(包含 Project Pages sites 的仓库) Contributions未被Github计入的几个常见原因 进行Commits的用户没有被关联到你的Github帐号中，可能是github邮箱设置错误，或者commit用的邮箱和github主邮箱不一致 不是在这个版本库的默认分支进行的Commit 仓库是Fork仓库，不是独立仓库 排查这里以邮箱错误为例，因为我的也是这个原因，直接把处理过程写上了 查询commit的邮箱 将你的没有统计commits到contributions中的仓库版本历史记录都克隆到本地，并cd到本地仓库根目录下，git log查询历史记录邮箱 123git clone --bare "这里写你的仓库地址"cd 克隆到本地的文件夹的名字（一般是xxx.git）git log // 查询以前commit的时候用的邮箱 去github个人资料中看自己的主邮箱 登录，右上角头像点击有个菜单，菜单里有个settings点击，左边找到Emails,看下图中英文 Primary email address formanW@aliyun.com will be used for account-related notifications and for web-based GitHub operations (e.g. edits and merges). 翻译成汉语： 主电子邮件地址 formanW@aliyun.com将用于与帐户相关的通知和基于网络的GitHub操作(例如编辑和合并)。 比对下你commit的邮箱和主电子邮箱是否一样，不一样的话，就是这原因无疑了 解决方案 在你刚才克隆下来的仓库中新建一个文件script.sh，将如下代码粘贴进去 12345678910111213141516#!/bin/shgit filter-branch --env-filter 'OLD_EMAIL="旧的Email地址"CORRECT_NAME="正确的用户名"CORRECT_EMAIL="正确的邮件地址"if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]then export GIT_COMMITTER_NAME="$CORRECT_NAME" export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"fiif [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]then export GIT_AUTHOR_NAME="$CORRECT_NAME" export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"fi' --tag-name-filter cat -- --branches --tags 直接在本地仓库中，双击这个script.sh脚本运行，会弹出来一个控制面板，上面就是更新的历史记录 完成2步骤之后，在本地仓库根目录中运行以下命令上传正确的历史记录到giehub 1git push --force --tags origin 'refs/heads/*' 删掉刚才克隆的下来的本地仓库 至此，去你的github contributions看看，统计的数量就正常了 正确设置github邮箱和用户名12git config --global user.email "你的邮件地址"git config --global user.name "你的Github用户名" 设置之后，就可以开心的进行以后的github提交了，妈妈再也不担心github没贡献了]]></content>
      <tags>
        <tag>contributions统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次hexo生成静态文件报错]]></title>
    <url>%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1hexo%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[hexo常见错误 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ hexo d 生成HTML文件报错###错误代码： FATAL Something&#39;s wrong. Maybe you can find the solution here: http://hexo.io/do cs/troubleshooting.html Template render error: (unknown path) [Line 1, Column 12] unexpected token: }} 问题原因：看到其中有一句Template render error，模板渲染错误 看到渲染错误，我的md文档中不就有渲染的语法嘛，}}双大括号就是做渲染的语法，可能有冲突吧，有文章说有代码块包含就可以，那么我试试 12// 有包含&#123;&#123;&#125;&#125; 果然，hexo g试验了一下，果然是没有报错的，而我没有使用代码块包含双大括号的时候，就会报上面的错误代码 解决办法： 双大括号我把我那篇包含渲染语法的文档，双大括号都改成了汉字，有些必须的用代码块包含了起来，这样果然就醒了 总结： 1. hexo渲染html静态文件的时候是个渲染过程，会和渲染语法冲突，避免一下 2. `}}` 被代码块包含起来是不会有错的，但没包含的会报错]]></content>
      <tags>
        <tag>hexo生成html报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序学习笔记]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[微信小程序 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 关于此学习的测试项目都暂时保存在https://github.com/ForeManWang/wxapp-study微信小程序账号与工具在线文档：https://mp.weixin.qq.com/debug/wxadoc/dev/ 小程序开发者账号注册微信公众平台：https://mp.weixin.qq.com/ 小程序开发者账号注册：https://mp.weixin.qq.com/wxopen/waregister?action=step1 微信开发者工具微信开发者工具：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html 小程序在线Demo 微信小程序文件结构主体文件结构主体部分由三个文件组成，必须放在项目的根目录，如下： 文件 必填 作用 app.js 是 小程序逻辑 app.json 是 配置文件——小程序公共设置，主要界面外观设置 app.wxss 否 小程序公共样式表 页面文件结构 通过开发者工具快速创建了一个 QuickStart 项目。可以留意到这个项目里边生成了不同类型的文件: .json 后缀的 JSON 配置文件 .wxml 后缀的 WXML(Wei Xin Markup Language) 模板文件 .wxss 后缀的 WXSS(Wei Xin Style Sheets) 样式文件 .js 后缀的 JS 脚本逻辑文件 接下来我们分别看看这4种文件的作用。 页面由四个文件组成，分别是： 文件类型 必填 作用 js 是 页面逻辑 ( 微信小程序没有window和document对象 ) wxml 是 页面结构 ( XML语法，不是HTML语法 ) wxss 否 页面样式表 ( 拓展了rpx尺寸单位，微信专属响应式像素 ) json 否 页面配置 ( 不能写注释，否则编译报错 ) 微信小程序全局配置app.json 配置项列表 app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。可以看到生成的app.json配置内容如下： 123456789&#123; "pages": ["pages/index/index", "pages/logs/logs"], "window": &#123; "backgroundTextStyle": "light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle": "black" &#125;&#125; app.json配置各项的含义 属性 类型 必填 描述 最低版本 pages String Array 是 描述当前小程序所有页面路径，通常文件名和页面各文件名都相同 window Object 否 定义小程序所有页面的顶部背景颜色，文字颜色定义等。 tabBar Object 否 底部 tab 栏的表现 networkTimeout Object 否 网络超时时间 debug Boolean 否 是否开启 debug 模式，默认关闭 functionalPages Boolean 否 是否启用插件功能页，默认关闭 2.1.0 subpackages Object Array 否 分包结构配置 1.7.3 workers String 否 Worker 代码放置的目录 1.9.90 requiredBackgroundModes String Array 否 需要在后台使用的能力，如「音乐播放」 plugins Object 否 使用到的插件 1.9.6 preloadRule Object 否 分包预下载规则 2.3.0 resizable Boolean 否 iPad 小程序是否支持屏幕旋转，默认关闭 2.3.0 navigateToMiniProgramAppIdList String Array 否 需要跳转的小程序列表，详见 wx.navigateToMiniProgram 2.4.0 usingComponents Object 否 全局自定义组件配置 开发者工具 1.02.1810190 permission Object 否 小程序接口权限相关设置 微信客户端 7.0.0 pages 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径+文件名 信息。文件名不需要写文件后缀，框架会自动去寻找对于位置的 .json, .js, .wxml, .wxss 四个文件进行处理。 例如app.json中,此时数组中第一项为默认首页，即index是首页 123&#123; "pages": ["pages/index/index", "pages/logs/logs"]&#125; window 用于设置小程序的状态栏、导航条、标题、窗口背景色。 注意：页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键。 属性 类型 默认值 描述 最低版本 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle String white 导航栏标题颜色，仅支持 black / white navigationBarTitleText String 导航栏标题文字内容 navigationStyle String default 导航栏样式，仅支持以下值： default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮。参见注2。 微信客户端 6.6.0 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light backgroundColorTop String #ffffff 顶部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16 backgroundColorBottom String #ffffff 底部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16 enablePullDownRefresh Boolean false 是否开启当前页面的下拉刷新。 详见 Page.onPullDownRefresh onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 Page.onReachBottom pageOrientation String portrait 屏幕旋转设置，仅支持 auto / portrait 详见 响应显示区域变化 微信客户端 6.7.3 注1：HexColor（十六进制颜色值），如”#ff00ff” 注2：关于navigationStyle 客户端 7.0.0 以下版本，navigationStyle 只在 app.json 中生效。 客户端 6.7.2 版本开始，navigationStyle: custom 对 组件无效 开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用）可方便切到旧视觉 如 app.json ： 123456789&#123; "window": &#123; "navigationBarBackgroundColor": "#ffffff", "navigationBarTextStyle": "black", "navigationBarTitleText": "微信接口功能演示", "backgroundColor": "#eeeeee", "backgroundTextStyle": "light" &#125;&#125; 微信接口功能演示 tabBar 如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 属性 类型 必填 默认值 描述 最低版本 color HexColor 是 tab 上的文字默认颜色，仅支持十六进制颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色，仅支持十六进制颜色 backgroundColor HexColor 是 tab 的背景色，仅支持十六进制颜色 borderStyle String 否 black tabbar上边框的颜色， 仅支持 black / white list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom tabBar的位置，仅支持 bottom / top custom Boolean 否 false 自定义 tabBar，见详情 2.5.0 tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 属性说明： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 示例： 1234567891011121314151617181920212223242526272829303132&#123; "pages":[ "pages/index/index", "pages/logs/logs" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle":"black", &#125;, "debug": true, "tabBar": &#123; "color": "#444", "backgroundColor": "#e0e0e0", "SelectedColor": "#219be3", "boderStyle": "black", "position": "bottom", "list": [ &#123; "text": "Home", "PagePath": "pages/index/index", "iconPath": "icons/grid-01.png" &#125;, &#123; "text": "logs", "PagePath": "pages/logs/logs", "iconPath": "icons/grid-02.png" &#125; ] &#125;&#125; 图示： networkTimeout 各类网络请求的超时时间，单位均为毫秒。 属性 类型 必填 默认值 说明 request Number 否 60000 wx.request 的超时时间，单位：毫秒。 connectSocket Number 否 60000 wx.connectSocket 的超时时间，单位：毫秒。 uploadFile Number 否 60000 wx.uploadFile 的超时时间，单位：毫秒。 downloadFile Number 否 60000 wx.downloadFile 的超时时间，单位：毫秒。 debug 可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发等。可以帮助开发者快速定位一些常见的问题。 functionalPages 基础库 2.1.0 开始支持，低版本需做兼容处理。 启用插件功能页时，插件所有者小程序需要设置其 functionalPages 为 true。 subpackages 微信客户端 6.6.0 ，基础库 1.7.3 及以上版本支持。 启用分包加载时，声明项目分包结构。 写成 subPackages 也支持。 workers 基础库 1.9.90 开始支持，低版本需做兼容处理。 使用 Worker 处理多线程任务时，设置 Worker 代码放置的目录。 requiredBackgroundModes 微信客户端 6.7.2 及以上版本支持。 申明需要后台运行的能力，类型为数组。目前支持以下项目： audio: 后台音乐播放 如： 1234&#123; &quot;pages&quot;: [&quot;pages/index/index&quot;], &quot;requiredBackgroundModes&quot;: [&quot;audio&quot;]&#125; 注：在此处申明了后台运行的接口，开发版和体验版上可以直接生效，正式版还需通过审核。 plugins 基础库 1.9.6 开始支持，低版本需做兼容处理。 声明小程序需要使用的插件。 preloadRule 基础库 2.3.0 开始支持，低版本需做兼容处理。 声明分包预下载的规则。 resizable 基础库 2.3.0 开始支持，低版本需做兼容处理。 在 iPad 上运行的小程序可以设置支持屏幕旋转。 navigateToMiniProgramAppIdList 基础库 2.4.0 开始支持，低版本需做兼容处理。 当小程序需要使用 wx.navigateToMiniProgram 接口跳转到其他小程序时，需要先在配置文件中声明需要跳转的小程序 appId 列表，最多允许填写 10 个。 usingComponents 开发者工具 1.02.1810190 及以上版本支持。 在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。 permission 微信客户端 7.0.0 及以上版本支持 小程序接口权限相关设置。字段类型为 Object，结构为： 属性 类型 必填 默认值 描述 scope.userLocation PermissionObject 否 位置相关权限声明 PermissionObject 结构 属性 类型 必填 默认值 说明 desc string 是 小程序获取权限时展示的接口用途说明。最长30个字符 如： 12345678&#123; &quot;pages&quot;: [&quot;pages/index/index&quot;], &quot;permission&quot;: &#123; &quot;scope.userLocation&quot;: &#123; &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot; &#125; &#125;&#125; 微信小程序页面配置 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 配置示例1234567&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;&#125; 页面配置项列表 属性 类型 默认值 描述 最低版本 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle String white 导航栏标题颜色，仅支持 black / white navigationBarTitleText String 导航栏标题文字内容 navigationStyle String default 导航栏样式，仅支持以下值： default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮 微信客户端 7.0.0 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light enablePullDownRefresh Boolean false 是否全局开启下拉刷新。 详见 Page.onPullDownRefresh onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 Page.onReachBottom disableScroll Boolean false 设置为 true 则页面整体不能上下滚动。 只在页面配置中有效，无法在 app.json中设置 disableSwipeBack Boolean false 禁止页面右滑手势返回 微信客户端 7.0.0 页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个属性。 逻辑层App Service 小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。 逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。 逻辑层的JavaScript 小程序不是运行在Web的浏览器中，所以没有BOM和DOM对象，就意味着没有document和window 在小程序中有一些额外的全局成员 App 方法，用于定义应用实例对象 Page 方法，用于定义页面对象 getApp方法，用于获取全局应用程序实例对象 getCurrentPages方法，用于获取当前页面的调用栈， 说明：历史栈指的是当前调用的页面和历史页面的栈，尝试打印console.log(getCurrentPage())打印出来是一个数组，意味着返回值是一个数组，然后this指向当前的页面，是当前页面的调用栈 wx对象：丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力 每个页面有独立的作用域，并提供模块化能力。 小程序的JS是支持CommonJS规范的，也就是说可以通过require载入模块，通过module.exports导出模块，但不支持exports.xxx 视图层View 框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。 将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。 WXML(WeiXin Markup language) 用于描述页面的结构。 WXS(WeiXin Script) 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 WXSS(WeiXin Style Sheet) 用于描述页面的样式。 组件(Component)是视图的基本组成单元。 WXML WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。 数据绑定将数据动态渲染到页面中 简单数据绑定 数据在哪？ data：页面的初始数据，给页面供数据的，就是界面和逻辑之间的桥梁 示例 123456789Page(&#123; ... data: &#123; ... message: "hello wxxcx", ... &#125; ...&#125;) 绑定到哪？ 通过双大括号的形式，绑定数据到想要输出的位置 &lt;text&gt;&lt;/text&gt; 简单数据绑定 绑定给页面中的text文本节点 绑定给class，为元素添加样式或者拼接样式 以字面量的形式或者简单的逻辑运算符（简单的运算或者三元表达式等）直接输出 双大括号的语法 innerHTML上 元素的属性上 不能用在标签名和属性名上 注意：若判断布尔类型时，要将true或者false包裹在双大括号内进行解析，防止被JS误解为字符串 列表渲染将数组中的数据在页面中循环渲染 去index.js文件的data中定义一个数组，数组中的每一个成员都是一个对象 在index.wxml中利用wx:for=&quot;&quot;遍历输出，注意这里的wx:for中间不能有空格 12345person: [ &#123; name: 'zhangsan', age: 18, adult: true &#125;, &#123; name: 'wangwu', age: 20, adult: true &#125;, &#123; name: 'zhaoliu', age: 16, adult: false &#125; ] 1234&lt;view wx:for="&#123;&#123; person &#125;&#125;"&gt; &lt;checkbox checked='&#123;&#123; item.adult &#125;&#125;'&gt;&lt;/checkbox&gt; &lt;text&gt;&#123;&#123; item.name &#125;&#125;&lt;/text&gt;&lt;/view&gt; 如果全局属性中有一个item关键词，解决方法可以直接在循环的属性后面加上wx:for-item=&quot;项目名称缩写&quot;，那么下面遍历的时候也需要用你起的别名进行遍历，看下面示例 1234&lt;view wx:for="&#123;&#123; person &#125;&#125;" wx:for-item="wx"&gt; &lt;checkbox checked='&#123;&#123; wx.adult &#125;&#125;'&gt;&lt;/checkbox&gt; &lt;text&gt;&#123;&#123; wx.name &#125;&#125;&lt;/text&gt;&lt;/view&gt; 用 拿序号，但若关键字冲突，可以通过wx:for-index=&quot;i&quot;去拿，那么下面拿序号的时候，就要用拿 12345&lt;view wx:for="&#123;&#123; person &#125;&#125;" wx:for-item="wx" wx:for-index="i"&gt; &lt;text&gt;&#123;&#123; i &#125;&#125;&lt;/text&gt; &lt;checkbox checked='&#123;&#123; wx.adult &#125;&#125;'&gt;&lt;/checkbox&gt; &lt;text&gt;&#123;&#123; wx.name &#125;&#125;&lt;/text&gt;&lt;/view&gt; 另外wx:for的值在下面是可以点出来legth值的，我在代码中试了试 123456&lt;view wx:for="&#123;&#123; person &#125;&#125;" wx:for-item="wx" wx:for-index="i"&gt; &lt;text&gt;&#123;&#123; i &#125;&#125;&lt;/text&gt; &lt;checkbox checked='&#123;&#123; wx.adult &#125;&#125;'&gt;&lt;/checkbox&gt; &lt;text&gt;&#123;&#123; wx.name &#125;&#125;&lt;/text&gt; &lt;text&gt;&#123;&#123; person.length &#125;&#125;&lt;/text&gt;&lt;/view&gt; wx:for 也可以嵌套，下边是一个九九乘法表 ，我们将这个乘法口诀代码粘贴到自己的测试项目中看一下 12345&lt;view wx:for="&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;" wx:for-item="i"&gt; &lt;view wx:for="&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;" wx:for-item="j"&gt; &lt;view wx:if="&#123;&#123;i &lt;= j&#125;&#125;"&gt;&#123;&#123;i&#125;&#125; * &#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 渲染一个包含多节点的结构块: 可以将 wx:for 用在&lt;block/&gt;标签上 1234&lt;block wx:for="&#123;&#123;[1, 2, 3]&#125;&#125;"&gt; &lt;view&gt;&#123;&#123;index&#125;&#125;:&lt;/view&gt; &lt;view&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;&lt;/block&gt; 使用 wx:key 来指定列表中项目的唯一的标识符 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如&lt;input&gt;中的输入内容，&lt;switch&gt;的选中状态） wx:key 的值以两种形式提供 作用：当数据发生改变时，快速定位更新的值，防止顺序错乱 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字 ，如当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率 如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 示例： 123456789101112131415161718192021222324252627282930313233343536373839Page(&#123; data: &#123; objectArray: [ &#123;id: 5, unique: 'unique_5'&#125;, &#123;id: 4, unique: 'unique_4'&#125;, &#123;id: 3, unique: 'unique_3'&#125;, &#123;id: 2, unique: 'unique_2'&#125;, &#123;id: 1, unique: 'unique_1'&#125;, &#123;id: 0, unique: 'unique_0'&#125;, ], numberArray: [1, 2, 3, 4] &#125;, switch(e) &#123; const length = this.data.objectArray.length for (let i = 0; i &lt; length; ++i) &#123; const x = Math.floor(Math.random() * length) const y = Math.floor(Math.random() * length) const temp = this.data.objectArray[x] this.data.objectArray[x] = this.data.objectArray[y] this.data.objectArray[y] = temp &#125; this.setData(&#123; objectArray: this.data.objectArray &#125;) &#125;, addToFront(e) &#123; const length = this.data.objectArray.length this.data.objectArray = [&#123;id: length, unique: 'unique_' + length&#125;].concat(this.data.objectArray) this.setData(&#123; objectArray: this.data.objectArray &#125;) &#125;, addNumberToFront(e) &#123; this.data.numberArray = [this.data.numberArray.length + 1].concat(this.data.numberArray) this.setData(&#123; numberArray: this.data.numberArray &#125;) &#125;&#125;) 12345678910&lt;switch wx:for="&#123;&#123;objectArray&#125;&#125;" wx:key="unique" style="display: block;"&gt; &#123;&#123;item.id&#125;&#125;&lt;/switch&gt;&lt;button bindtap="switch"&gt;Switch&lt;/button&gt;&lt;button bindtap="addToFront"&gt;Add to the front&lt;/button&gt;&lt;switch wx:for="&#123;&#123;numberArray&#125;&#125;" wx:key="*this" style="display: block;"&gt; &#123;&#123;item&#125;&#125;&lt;/switch&gt;&lt;button bindtap="addNumberToFront"&gt;Add to the front&lt;/button&gt; 注意：当wx:for=&quot;string&quot;的时候，会把字符串解析为数组，例如下面两个等价的代码 123&lt;view wx:for="hello"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;// 等同于&lt;view wx:for="&#123;&#123; ['h', 'e', 'l', 'l', 'o'] &#125;&#125;"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; ​2. 注意：花括号和引号之间如果有空格，将最终被解析成为字符串 123&lt;view wx:for="&#123;&#123;[1,2,3]&#125;&#125; "&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;// 等同于&lt;view wx:for="&#123;&#123;[1,2,3] + ' '&#125;&#125;"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; 条件渲染 当判断是否需要去渲染一个代码块的时候，就需要用到wx:if , 当需要判断是否添加一个代码块的时候，要用到wx:elif或者wx:else 示例：用在wx:for章节的代码，跟着后面添加了几句判断 123&lt;view wx:if="&#123;&#123; person.length &gt; 5 &#125;&#125;"&gt;2&lt;/view&gt;&lt;view wx:elif="&#123;&#123; person.length &lt; 5 &#125;&#125;"&gt;3&lt;/view&gt;&lt;view wx:else&gt;1&lt;/view&gt; 如果要一次性判断多个组件标签，可以使用一个 &lt;block/&gt; 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。 1234&lt;block wx:if="&#123;&#123;true&#125;&#125;"&gt; &lt;view&gt;view1&lt;/view&gt; &lt;view&gt;view2&lt;/view&gt;&lt;/block 注意： &lt;block/&gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 wx:ifVShidden 因为 wx:if 之中的模板也可能包含数据绑定，所以当 wx:if 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。 同时 wx:if 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。 相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。 一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。 模板 WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。 定义模板 使用 name 属性，作为模板的名字。然后在&lt;template/&gt;内定义代码片段，如： 1234567891011&lt;!-- index: int msg: string time: string--&gt;&lt;template name="msgItem"&gt; &lt;view&gt; &lt;text&gt;&#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125;&lt;/text&gt; &lt;text&gt;Time: &#123;&#123;time&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt; 使用模板 使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入，如： 1&lt;template is="msgItem" data="&#123;&#123;...item&#125;&#125;" /&gt; 123456789Page(&#123; data: &#123; item: &#123; index: 0, msg: 'this is a template', time: '2016-09-15' &#125; &#125;&#125;) is 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板： 12345678910&lt;template name="odd"&gt; &lt;view&gt;odd&lt;/view&gt;&lt;/template&gt;&lt;template name="even"&gt; &lt;view&gt;even&lt;/view&gt;&lt;/template&gt;&lt;block wx:for="&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;"&gt; &lt;template is="&#123;&#123;item % 2 == 0 ? 'even' : 'odd'&#125;&#125;" /&gt;&lt;/block&gt; 模板的作用域 模板拥有自己的作用域，只能使用 data 传入的数据以及模板定义文件中定义的 &lt;wxs /&gt; 模块 事件 事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。 事件对象可以携带额外信息，如 id, dataset, touches 事件的使用方式 在组件中绑定事件处理函数 123&lt;view class="container"&gt; &lt;button bindtap='buttonTap'&gt;点击我哦&lt;/button&gt;&lt;/view&gt; 1234567Page(&#123; ... buttonTap() &#123; console.log('123') &#125;, ...&#125;) 给buttonTap函数传参，但是微信开发中绑定事件函数的时候，明确的规定不能直接在后面加括号传参的，不然会报错，这时候和H5开发的时候一样，需要给元素添加自定义属性data-xxx，在逻辑层通过dataset拿到数据 1&lt;button bindtap='buttonTap' data-hello='事件传参'&gt;点击我哦&lt;/button&gt; 12345678Page(&#123; ... buttonTap(e) &#123; console.log(e) console.log(e.target) &#125;, ...&#125;) 可以看到e对象里面有很多属性和方法方便以后使用 看到e.target对象是这样的 事件分类 事件分为冒泡事件和非冒泡事件： 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。 WXML的冒泡事件列表： 类型 触发条件 最低版本 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 1.5.0 longtap 手指触摸后，超过350ms再离开（推荐使用longpress事件代替） transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发 animationstart 会在一个 WXSS animation 动画开始时触发 animationiteration 会在一个 WXSS animation 一次迭代结束时触发 animationend 会在一个 WXSS animation 动画完成时触发 touchforcechange 在支持 3D Touch 的 iPhone 设备，重按时会触发 1.9.90 注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如的submit事件，的input事件，的scroll事件，(详见各个组件) 事件绑定和冒泡 事件绑定的写法同组件的属性，以 key、value 的形式 : key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtouchstart。自基础库版本 1.5.0 起，在非原生组件中，bind和catch后可以紧跟一个冒号，其含义不变，如bind:tap、catch:touchstart value 是一个字符串，需要在对应的 Page 中定义同名的函数，不然当触发事件的时候会报错 1234567&lt;view id="outer" style='width: 200px; height: 200px; background-color:red' bindtap="handleTap1"&gt; 我是他爷爷 &lt;view id="middle" style='width: 100px; height: 100px; background-color:yellow' bindtap="handleTap2"&gt; 我是他爸爸 &lt;view id="inner" style='width: 50px; height: 50px; background-color:blue' bindtap="handleTap3"&gt;我是他儿子&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213Page(&#123; ... handleTap1() &#123; console.log('我是他爷爷') &#125;, handleTap2() &#123; console.log('我是他爸爸') &#125;, handleTap3() &#123; console.log('我是他儿子') &#125;, ...&#125;) 实际上熟悉JS事件冒泡的对于这个都不难理解，就是子元素的事件会向上冒泡给相同事件的父元素 阻止事件冒泡cstch + xxx阻止冒泡 将上面的案例中的其中一个父元素绑定一下阻止冒泡的事件，观察下 1234567&lt;view id="outer" style='width: 200px; height: 200px; background-color:red' bindtap="handleTap1"&gt; 我是他爷爷 &lt;view id="middle" style='width: 100px; height: 100px; background-color:yellow' catchtap="handleTap2"&gt; 我是他爸爸 &lt;view id="inner" style='width: 50px; height: 50px; background-color:blue' bindtap="handleTap3"&gt;我是他儿子&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 这样的话，事件冒泡到我是他爸爸这个盒子之后就不会再冒泡了 事件捕获 自基础库版本 1.5.0 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段。 在下面的代码中，点击 inner view 会先后调用handleTap2、handleTap4、handleTap3、handleTap1 1234&lt;view id="outer" style='width: 200px; height: 200px; background-color:red' bind:tap="handleTap1" capture-bind:tap="handleTap2"&gt; 我是他爸爸 &lt;view id="middle" style='width: 100px; height: 100px; background-color:yellow' bind:tap="handleTap3" capture-bind:tap="handleTap4"&gt; 我是我自己&lt;/view&gt; &lt;/view&gt; 12345678910111213141516Page(&#123; ... handleTap1() &#123; console.log('我是handleTap1') &#125;, handleTap2() &#123; console.log('我是handleTap2') &#125;, handleTap3() &#123; console.log('我是handleTap3') &#125;, handleTap4() &#123; console.log('我是handleTap4') &#125;, ...&#125;) 如果将上面代码中的第一个capture-bind改为capture-catch，将只触发handleTap2 事件对象 如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象 BaseEvent 基础事件对象属性列表： 属性 类型 说明 type String 事件类型 timeStamp Integer 事件生成时的时间戳 target Object 触发事件的组件的一些属性值集合 currentTarget Object 当前组件的一些属性值集合 CustomEvent 自定义事件对象属性列表（继承 BaseEvent）： 属性 类型 说明 detail Object 额外的信息 TouchEvent 触摸事件对象属性列表（继承 BaseEvent）： 属性 类型 说明 touches Array 触摸事件，当前停留在屏幕中的触摸点信息的数组 changedTouches Array 触摸事件，当前变化的触摸点信息的数组 特殊事件： 中的触摸事件不可冒泡，所以没有 currentTarget。 type 代表事件的类型 timeStamp 页面打开到触发事件所经过的毫秒数 target 触发事件的源组件 属性 类型 说明 id String 事件源组件的id tagName String 当前组件的类型 dataset Object 事件源组件上由data-开头的自定义属性组成的集合 currentTarget 事件绑定的当前组件 属性 类型 说明 id String 当前组件的id tagName String 当前组件的类型 dataset Object 当前组件上由data-开头的自定义属性组成的集合 说明： target 和 currentTarget 可以参考前面的例子 dataset 这个在前面传参中也有提到过 在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.currentTarget.dataset 中会将连字符转成驼峰elementType 示例： 123&lt;view data-alpha-beta=&quot;1&quot; data-alphaBeta=&quot;2&quot; bindtap=&quot;bindViewTap&quot;&gt; DataSet Test&lt;/view&gt; 123456Page(&#123; bindViewTap(event) &#123; event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法 event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写 &#125;&#125;) touches touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点 Touch 对象 属性 类型 说明 identifier Number 触摸点的标识符 pageX, pageY Number 距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴 clientX, clientY Number 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴 CanvasTouch 对象 属性 类型 说明 特殊说明 identifier Number 触摸点的标识符 x, y Number 距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为X轴，纵向为Y轴 changedTouches changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel） detail 自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义 点击事件的detail 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离 引用 WXML 提供两种文件引用方式import和include import import可以在该文件中使用目标文件定义的template，如： 在 item.wxml 中定义了一个叫item的template： 1234&lt;!-- item.wxml --&gt;&lt;template name=&quot;item&quot;&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt; 在 index.wxml 中引用了 item.wxml，就可以使用item模板： 12&lt;import src=&quot;item.wxml&quot; /&gt;&lt;template is=&quot;item&quot; data=&quot;&#123;&#123;text: &apos;forbar&apos;&#125;&#125;&quot; /&gt; import 的作用域 import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template 如：C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template。 1234&lt;!-- A.wxml --&gt;&lt;template name=&quot;A&quot;&gt; &lt;text&gt;A template&lt;/text&gt;&lt;/template&gt; 12345&lt;!-- B.wxml --&gt;&lt;import src=&quot;a.wxml&quot; /&gt;&lt;template name=&quot;B&quot;&gt; &lt;text&gt;B template&lt;/text&gt;&lt;/template&gt; 12345&lt;!-- C.wxml --&gt;&lt;import src=&quot;b.wxml&quot; /&gt;&lt;template is=&quot;A&quot; /&gt;&lt;!-- Error! Can not use tempalte when not import A. --&gt;&lt;template is=&quot;B&quot; /&gt; include include 可以将目标文件除了 &lt;template/&gt; &lt;wxs/&gt; 外的整个代码引入，相当于是拷贝到 include 位置，如： 12345678&lt;!-- index.wxml --&gt;&lt;include src=&quot;header.wxml&quot; /&gt;&lt;view&gt;body&lt;/view&gt;&lt;include src=&quot;footer.wxml&quot; /&gt;&lt;!-- header.wxml --&gt;&lt;view&gt;header&lt;/view&gt;&lt;!-- footer.wxml --&gt;&lt;view&gt;footer&lt;/view&gt; 单向数据流由于微信小程序框架中没有像Angular中的ngMoudel或者Vue中的v-model的双向数据绑定，所以默认微信小程序中的数据流只有单向数据流 123456789101112Page(&#123; ... inputHandle(e) &#123; // console.log(e.detail.value) // console.log(this.data.message) // this.data.message = e.detail.value this.setData(&#123; message: e.detail.value &#125;) &#125;, ...&#125;) 12&lt;input value='&#123;&#123; message &#125;&#125;' bindinput='inputHandle'&gt;&lt;/input&gt;&lt;text&gt;&#123;&#123; message &#125;&#125;&lt;/text&gt; 发现只有内存中的数据改变了，页面却不能跟随变化 双向数据绑定利用setData()这个内部方法进行双向数据绑定 123456789Page(&#123; ... inputHandle(e) &#123; // console.log(e.detail.value) // console.log(this.data.message) this.data.message = e.detail.value &#125;, ...&#125;) 这样实现内存和页面中数据同步更新 WXSS 样式WXSS(WeiXin Style Sheets)是一套样式语言。 与 CSS 相比，WXSS 扩展以下2个特性： 尺寸单位 rpx ( responsive pixel 响应式像素) ，750rpx充满屏幕 样式导入 @import “样式表路径”; 微信小程序组件(标签)组件文档：https://developers.weixin.qq.com/miniprogram/dev/component/ 常用布局标签12345&lt;view&gt;&lt;/view&gt; 视图容器，相当于 &lt;div&gt;&lt;/div&gt;&lt;text&gt;&lt;/text&gt; 相当于 &lt;span&gt;&lt;/span&gt; &lt;image&gt;&lt;/image&gt; 相当于 &lt;img /&gt;&lt;navigator&gt;&lt;/navigator&gt; 相当于 &lt;a&gt;&lt;/a&gt;&lt;block&gt;&lt;/block&gt; 区块标签，不会渲染到页面 注意：image组件默认宽度300px、高度225px，很多时候我们都不需要这个默认宽高，记得手动设置宽高 flex布局参考文档https://qqqww.com/Flex%E5%B8%83%E5%B1%80/ 页面间跳转（navigator）新建页面小技巧当我们新建页面的时候，自己去新建一个页面，每个页面还要新建好几个文件，很麻烦，这里其实不需要直接新建，在配置app.json的时候，微信开发者工具会自动帮我们创建好，看下图，我左侧是没有demo4这个页面的，但是右边配置中写上了&quot;pages/demo4/deom4&quot;，那么ctrl+s保存之后，可以看到，左边的页面以及需求的文件都被自动创建出来了 如何做页面跳转语法： 在当前页面设置跳转 1&lt;navigator url="想去到达页面的相对路径"&gt;&lt;/navigator&gt; 配置json，不然页面跳转无法显示 123&#123; "usingComponents": &#123;&#125;&#125; 页面间传值以往通过?或者请求体进行传值 在小程序中，页面间的传值，也可以利用?传参，在需要使用的传过来的数的时候，在该页面的js文件的onLoad生命周期的时候通过options去接受参数 123// demo1.wxml&lt;navigator url="../demo2/demo2?name=小明&amp;age=18"&gt;小明&lt;/navigator&gt;&lt;navigator url="../demo2/demo2?name=小红"&gt;小红&lt;/navigator&gt; 1234567891011121314151617181920// pages/demo2/demo2.jsPage(&#123; data:&#123;&#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 console.log(options) &#125;, onReady:function()&#123; // 页面渲染完成 &#125;, onShow:function()&#123; // 页面显示 &#125;, onHide:function()&#123; // 页面隐藏 &#125;, onUnload:function()&#123; // 页面关闭 &#125;&#125;) 页面导航模式通过redirect进行重定向，类型时布尔类型 12// demo1.wxml&lt;navigator url="../demo2/demo2" redirect&gt;跳转过去（不回来了）&lt;/navigator&gt; 导航元素点击高亮利用hover-class控制点击时添加自定义的高亮的类 123// demo1.wxml&lt;navigator hover-class="my-hover"&gt;点我点我&lt;/navigator&gt;&lt;navigator hover-class="none"&gt;点我点我&lt;/navigator&gt; 1234// demo1.wxss.my-hover &#123; color: red;&#125; cursor pointer 的方式是一个小技巧，可以让任何元素点击时高亮 12// demo1.wxml&lt;image class="hover-demo" src="../../images/poster.jpg"&gt;&lt;/image&gt; 1234// demo1.wxss.hover-demo &#123; cursor: pointer;&#125; 页面导航API可以利用wx.navigateTo进行跳转，并可以在url中添加链接，?后面接收参数 12// demo1.wxml&lt;button type="primary" bindtap="tapHandle"&gt;跳转过去&lt;/button&gt; 123456789101112131415// demo1.jsPage(&#123; tapHandle: function () &#123; // 当我们点击按钮 系统会自动执行这里的代码 // console.log(1111) wx.navigateTo(&#123; url: '../demo2/demo2?id=123' &#125;) // 相当于加上redirect的 navigator // wx.redirectTo(&#123; // url: '../demo2/demo2' // &#125;) &#125;&#125;) 基础内容 组件名 说明 icon 图标 text 文字，可以嵌套，支持换行 rich-text 富文本 progress 进度条 icon 属性名 类型 默认值 说明 type String icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear size Number / String 23px icon的大小，单位px（2.4.0起支持rpx） color Color icon的颜色，同css的color aria-label String 无障碍访问，（属性）元素的额外描述 2.5.0 属性type 用于定义图标类型，只能是规定范围的类型，除了这些内置图标，其他的图标必须通过图片的方式使用 1&lt;icon type="success"&gt;&lt;/icon&gt; 属性size size用于指定图标大小，默认是 23px 1&lt;icon type="success" size="60"&gt;&lt;/icon&gt; 属性color color用于指定图标颜色，取值和css取值一样 1&lt;icon type="success" size="60" color="red"&gt;&lt;/icon&gt; rich-text tip: nodes 不推荐使用 String 类型，性能会有所下降。 tip: rich-text 组件内屏蔽所有节点的事件。 tip: attrs 属性不支持 id ，支持 class 。 tip: name 属性大小写不敏感。 tip: 如果使用了不受信任的HTML节点，该节点及其所有子节点将会被移除。 tip: img 标签仅支持网络图片。 tip: 如果在自定义组件中使用 rich-text 组件，那么仅自定义组件的 wxss 样式对 rich-text 中的 class 生效。 123456789101112131415&lt;view class="page-body"&gt; &lt;view class="page-section"&gt; &lt;view class="page-section-title"&gt;传入html字符串&lt;/view&gt; &lt;view class="rich-text-wrp"&gt; &lt;rich-text nodes="&#123;&#123;html&#125;&#125;" bindtap="tap"&gt;&lt;/rich-text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="page-section"&gt; &lt;view class="page-section-title"&gt;传入节点列表&lt;/view&gt; &lt;view class="rich-text-wrp"&gt; &lt;rich-text nodes="&#123;&#123;nodes&#125;&#125;" bindtap="tap"&gt;&lt;/rich-text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526rich-text &#123; width: 700rpx; padding: 25rpx 0;&#125;.rich-text-wrp &#123; padding: 0 25rpx; background-color: #fff;&#125;.page-section&#123; width: 100%; margin-bottom: 60rpx;&#125;.page-section:last-child&#123; margin-bottom: 0;&#125;.page-section-title&#123; font-size: 28rpx; color: #999999; margin-bottom: 10rpx; padding-left: 30rpx; padding-right: 30rpx;&#125; 12345678910111213141516171819Page(&#123; data: &#123; html: '&lt;div class="div_class" style="line-height: 60px; color: red;"&gt;Hello&amp;nbsp;World!&lt;/div&gt;', nodes: [&#123; name: 'div', attrs: &#123; class: 'div_class', style: 'line-height: 60px; color: red;' &#125;, children: [&#123; type: 'text', text: 'Hello&amp;nbsp;World!' &#125;] &#125;] &#125;, tap() &#123; console.log('tap') &#125;&#125;) progress 这个直接写代码到页面上是不会出现进度条的，原因在于其父元素的设置了flex且align-item:center导致没有宽度，需要自己加宽度才能显示，看下图，修改了控制台内其父元素的样式之后就可以了 加上active属性，有一个从左到右的进度条动画 其他属性 属性名 类型 默认值 说明 最低版本 percent Float 无 百分比0~100 show-info Boolean false 在进度条右侧显示百分比 border-radius Number / String 0 圆角大小，单位px（2.4.0起支持rpx） 2.3.1 font-size Number / String 16 右侧百分比字体大小，单位px（2.4.0起支持rpx） 2.3.1 stroke-width Number / String 6 进度条线的宽度，单位px（2.4.0起支持rpx） color Color #09BB07 进度条颜色 （请使用 activeColor） activeColor Color 已选择的进度条的颜色 backgroundColor Color 未选择的进度条的颜色 active Boolean false 进度条从左往右的动画 active-mode String backwards backwards: 动画从头播；forwards：动画从上次结束点接着播 1.7.0 bindactiveend EventHandle 动画完成事件 2.4.1 aria-label String 无障碍访问，（属性）元素的额外描述 2.5.0 常用表单标签1234&lt;button&gt;&lt;/button&gt;&lt;input type="text" /&gt; &lt;checkbox /&gt;&lt;radio/&gt; buttonbutton参考文档 type有效值123&lt;button type='warn'&gt;这是一个红色按钮&lt;/button&gt;&lt;button type='primary'&gt;这是一个绿色按钮&lt;/button&gt;&lt;button type='default'&gt;这是一个白色按钮&lt;/button&gt; size有效值123&lt;button type='warn' size='default'&gt;这是一个红色按钮&lt;/button&gt;&lt;button type='primary' size='mini'&gt;这是一个小尺寸绿色按钮&lt;/button&gt;&lt;button type='default'&gt;这是一个白色按钮&lt;/button&gt; form-type 有效值 值 说明 submit 提交表单 reset 重置表单 hover-class当按钮按下去，将hover-class指向想要展示出来的类 1&lt;button hover-class='btn-active'&gt;hover-class&lt;/button&gt; 123.btn-active &#123; background: red;&#125; 演示图片： checkbox多选框 checkbox-group多项选择器，内部由多个checkbox组成。 属性名 类型 默认值 说明 bindchange EventHandle &lt;checkbox-group&gt;中选中项发生改变时触发 change 事件，detail = {value:[选中的checkbox的value的数组]} checkbox多选项目。 属性名 类型 默认值 说明 最低版本 value String 标识，选中时触发的 change 事件，并携带 的 value disabled Boolean false 是否禁用 checked Boolean false 当前是否选中，可用来设置默认选中 color Color checkbox的颜色，同css的color aria-label String 无障碍访问，（属性）元素的额外描述 2.5.0 演示图片： form类似于HTML的form，将一些需要在表单中呈现的元素框起来 区别： 这里的form事件绑定方式是通过：bindsubmit提交，和bindreset重置 注意： 表单，将组件内的用户输入的&lt;switch&gt;、&lt;input&gt;、&lt;checkbox&gt;、&lt;slider&gt;、&lt;radio&gt;、&lt;picker&gt;提交。 当点击&lt;form&gt;表单中 form-type 为 submit 的&lt;button&gt;组件时，会将表单组件中的 value 值进行提交，需要在表单组件中加上 name 来作为 key。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;form bindsubmit="formSubmit" bindreset="formReset"&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;switch&lt;/view&gt; &lt;switch name="switch" /&gt; &lt;/view&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;slider&lt;/view&gt; &lt;slider name="slider" show-value&gt;&lt;/slider&gt; &lt;/view&gt; &lt;view class="section"&gt; &lt;view class="section__title"&gt;input&lt;/view&gt; &lt;input name="input" placeholder="please input here" /&gt; &lt;/view&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;radio&lt;/view&gt; &lt;radio-group name="radio-group"&gt; &lt;label&gt; &lt;radio value="radio1" /&gt; radio1 &lt;/label&gt; &lt;label&gt; &lt;radio value="radio2" /&gt; radio2 &lt;/label&gt; &lt;/radio-group&gt; &lt;/view&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;checkbox&lt;/view&gt; &lt;checkbox-group name="checkbox"&gt; &lt;label&gt; &lt;checkbox value="checkbox1" /&gt; checkbox1 &lt;/label&gt; &lt;label&gt; &lt;checkbox value="checkbox2" /&gt; checkbox2 &lt;/label&gt; &lt;/checkbox-group&gt; &lt;/view&gt; &lt;view class="btn-area"&gt; &lt;button form-type="submit"&gt;Submit&lt;/button&gt; &lt;button form-type="reset"&gt;Reset&lt;/button&gt; &lt;/view&gt;&lt;/form&gt; 12345678Page(&#123; formSubmit(e) &#123; console.log('form发生了submit事件，携带数据为：', e.detail.value) &#125;, formReset() &#123; console.log('form发生了reset事件') &#125;&#125;) inputinput在线文档 和原生基本类似，体验 1&lt;input class='input1' placeholder='请输入...' placeholder-class='input-placeholder'&gt;&lt;/input&gt; 1234567.input1 &#123; border: 1px solid #c0c0c0;&#125;.input-placeholder &#123; color: red;&#125; label基本和HTML差不多 用来改进表单组件的可用性，使用for属性找到对应的id，或者将控件放在该标签下，当点击时，就会触发对应的控件。 for优先级高于内部控件，内部有多个控件的时候默认触发第一个控件。 目前可以绑定的控件有：[button checkbox radio switch 属性名 类型 说明 for String 绑定控件的 id picker支持滚动的选择器，类似下图这样 目前picker支持五类选择器，普通选择器，多列选择器，时间选择器（一天内的时间），日期选择器（年月日），省市选择器 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;view class="section"&gt; &lt;view class="section__title"&gt;普通选择器&lt;/view&gt; &lt;picker bindchange="bindPickerChange" value="&#123;&#123;index&#125;&#125;" range="&#123;&#123;array&#125;&#125;"&gt; &lt;view class="picker"&gt; 当前选择：&#123;&#123;array[index]&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;多列选择器&lt;/view&gt; &lt;picker mode="multiSelector" bindchange="bindMultiPickerChange" bindcolumnchange="bindMultiPickerColumnChange" value="&#123;&#123;multiIndex&#125;&#125;" range="&#123;&#123;multiArray&#125;&#125;"&gt; &lt;view class="picker"&gt; 当前选择：&#123;&#123;multiArray[0][multiIndex[0]]&#125;&#125;，&#123;&#123;multiArray[1][multiIndex[1]]&#125;&#125;，&#123;&#123;multiArray[2][multiIndex[2]]&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;时间选择器&lt;/view&gt; &lt;picker mode="time" value="&#123;&#123;time&#125;&#125;" start="09:01" end="21:01" bindchange="bindTimeChange"&gt; &lt;view class="picker"&gt; 当前选择: &#123;&#123;time&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;日期选择器&lt;/view&gt; &lt;picker mode="date" value="&#123;&#123;date&#125;&#125;" start="2015-09-01" end="2017-09-01" bindchange="bindDateChange"&gt; &lt;view class="picker"&gt; 当前选择: &#123;&#123;date&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;省市区选择器&lt;/view&gt; &lt;picker mode="region" bindchange="bindRegionChange" value="&#123;&#123;region&#125;&#125;" custom-item="&#123;&#123;customItem&#125;&#125;"&gt; &lt;view class="picker"&gt; 当前选择：&#123;&#123;region[0]&#125;&#125;，&#123;&#123;region[1]&#125;&#125;，&#123;&#123;region[2]&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt; 123456// 这里注意需要现在`lib`文件夹中放入`weui.wxss`的依赖文件@import "../lib/weui.wxss";.picker&#123; padding: 13px; background-color: #FFFFFF;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165Page(&#123; data: &#123; array: ['美国', '中国', '巴西', '日本'], objectArray: [ &#123; id: 0, name: '美国' &#125;, &#123; id: 1, name: '中国' &#125;, &#123; id: 2, name: '巴西' &#125;, &#123; id: 3, name: '日本' &#125; ], index: 0, multiArray: [['无脊柱动物', '脊柱动物'], ['扁性动物', '线形动物', '环节动物', '软体动物', '节肢动物'], ['猪肉绦虫', '吸血虫']], objectMultiArray: [ [ &#123; id: 0, name: '无脊柱动物' &#125;, &#123; id: 1, name: '脊柱动物' &#125; ], [ &#123; id: 0, name: '扁性动物' &#125;, &#123; id: 1, name: '线形动物' &#125;, &#123; id: 2, name: '环节动物' &#125;, &#123; id: 3, name: '软体动物' &#125;, &#123; id: 3, name: '节肢动物' &#125; ], [ &#123; id: 0, name: '猪肉绦虫' &#125;, &#123; id: 1, name: '吸血虫' &#125; ] ], multiIndex: [0, 0, 0], date: '2016-09-01', time: '12:01', region: ['广东省', '广州市', '海珠区'], customItem: '全部' &#125;, bindPickerChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; index: e.detail.value &#125;) &#125;, bindMultiPickerChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; multiIndex: e.detail.value &#125;) &#125;, bindMultiPickerColumnChange: function (e) &#123; console.log('修改的列为', e.detail.column, '，值为', e.detail.value); var data = &#123; multiArray: this.data.multiArray, multiIndex: this.data.multiIndex &#125;; data.multiIndex[e.detail.column] = e.detail.value; switch (e.detail.column) &#123; case 0: switch (data.multiIndex[0]) &#123; case 0: data.multiArray[1] = ['扁性动物', '线形动物', '环节动物', '软体动物', '节肢动物']; data.multiArray[2] = ['猪肉绦虫', '吸血虫']; break; case 1: data.multiArray[1] = ['鱼', '两栖动物', '爬行动物']; data.multiArray[2] = ['鲫鱼', '带鱼']; break; &#125; data.multiIndex[1] = 0; data.multiIndex[2] = 0; break; case 1: switch (data.multiIndex[0]) &#123; case 0: switch (data.multiIndex[1]) &#123; case 0: data.multiArray[2] = ['猪肉绦虫', '吸血虫']; break; case 1: data.multiArray[2] = ['蛔虫']; break; case 2: data.multiArray[2] = ['蚂蚁', '蚂蟥']; break; case 3: data.multiArray[2] = ['河蚌', '蜗牛', '蛞蝓']; break; case 4: data.multiArray[2] = ['昆虫', '甲壳动物', '蛛形动物', '多足动物']; break; &#125; break; case 1: switch (data.multiIndex[1]) &#123; case 0: data.multiArray[2] = ['鲫鱼', '带鱼']; break; case 1: data.multiArray[2] = ['青蛙', '娃娃鱼']; break; case 2: data.multiArray[2] = ['蜥蜴', '龟', '壁虎']; break; &#125; break; &#125; data.multiIndex[2] = 0; console.log(data.multiIndex); break; &#125; this.setData(data); &#125;, bindDateChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; date: e.detail.value &#125;) &#125;, bindTimeChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; time: e.detail.value &#125;) &#125;, bindRegionChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; region: e.detail.value &#125;) &#125;&#125;) 演示图片： picker-view和picker类似 radio单项选择器，用法同html slider滑动选择器 switch开关选择器 textarea多行输入框，和html一样 操作组件通过方法调用来呈现组件（交互操作组件必须通过调用API的方式来调用） 12345678910111213141516171819Page(&#123; data: &#123; &#125;, btnTodo() &#123; // 当点击按钮触发 // console.log('111') wx.showActionSheet(&#123; // 显示出来的项目列表 itemList: ['a', 'b', 'c'], // 成功回调 success: function (res) &#123; if(!res.cancel) &#123; console.log(res.tapIndex) &#125; &#125; &#125;) &#125;&#125;) 1&lt;button type='primary' bindtap='btnTodo'&gt;你要点击我哦&lt;/button&gt; 另外模态框和上面用法一致…. 轮播图组件12345678&lt;swiper indicator-dots="是否显示面板指示点" autoplay="是否自动切换" interval="自动切换时间间隔" duration="滑动动画时长"&gt; &lt;swiper-item&gt; &lt;image src="图片路径1" width="375" height="150"/&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="图片路径2" width="375" height="150"/&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; 探索：实现无缝轮播怎么办？ 总结 组件的基本用法： 组件的语法问题 组件得使用是类似于HTML的方式，但是又有不同，组件使用的是严格的XML标准（例如结束标签问题要注意） 组件的分类 功能型组件（progress、checkbox、radio等具有具体功能的） 布局类型组件，用来完成页面结构 API类型组件，例如wx.showModal，通过调用API来使用 微信小程序页面函数生命周期函数1234567891011121314151617181920Page(&#123; /** 页面的初始数据 */ data: &#123; &#125;, /** 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, /** 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;&#125;) 页面相关事件处理函数123456789/** 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125; WXS 脚本 WXS（WeiXin Script）是小程序的一套脚本语言，功能类似&lt;script&gt;标签，用于在视图层定义函数(比较少用) 12345678910&lt;!--wxml--&gt;&lt;wxs module="foo"&gt;var sum = function(a,b)&#123; return a+b&#125;// 这里可以导出一个对象，这个对象可以直接在界面上使用 module.exports.sum = sum&lt;/wxs&gt;&lt;view&gt; &#123;&#123;foo.sum&#125;&#125; &lt;/view&gt;]]></content>
      <tags>
        <tag>微信小程序学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局的语法和案例]]></title>
    <url>%2Fflex%E5%B8%83%E5%B1%80%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Flex 布局 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 本文参考阮一峰老师的《Flex布局：语法篇》，在实践过程中，添加了一些案例，方便理解 详细参考Flex 布局教程：语法篇 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 1234&gt; .box&#123;&gt; display: flex;&gt; &#125;&gt; 行内元素也可以使用 Flex 布局。 1234&gt; .box&#123;&gt; display: inline-flex;&gt; &#125;&gt; Webkit 内核的浏览器，必须加上-webkit前缀。 12345&gt; .box&#123;&gt; display: -webkit-flex; /* Safari */&gt; display: flex;&gt; &#125;&gt; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 案例当一个布局需要自适应或者，一边固定宽度，其他自适应的情况下，使用flex布局 当想要使用flex布局的时候，找到其父元素，给父元素的类添加display:flex即可，在固定宽度的位置固定宽度，其他需要自适应的兄弟元素，分配flex，意思就是父盒子总宽度 - 固定宽度为剩余总宽度，把剩余需要自适应的兄弟元素按照需要的比例去分配剩余总宽度，案例代码如下： 案例一： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Flex布局1&lt;/title&gt; &lt;style type="text/css"&gt; /* 使用 flex 流程 1.设计 DOM 结构 2.将父盒子设置为伸缩盒子 display: flex; 3.固定一边宽度，另一边设置flex: 1;就实现了 */ html, body &#123; height: 100%; &#125; .root &#123; /*padding-left: 100px;*/ display: flex; border: 2px solid #c0c0c0; height: 100%; &#125; .sidebar &#123; width: 100px; background-color: yellow; &#125; .content &#123; /*width: 100%;*/ flex: 1; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="root"&gt; &lt;div class="sidebar"&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 案例二： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Flex2&lt;/title&gt; &lt;style type="text/css"&gt; .container &#123; display: flex; width: 400px; height: 300px; &#125; .item &#123; flex: 1; /*每一项占一份*/ &#125; .item:nth-child(even) &#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 案例三：音乐播放器主界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// index.wxml&lt;view class="root"&gt; &lt;!-- 标签栏的页签 固定高度 --&gt; &lt;view class="tabs"&gt; &lt;view class="item active"&gt; &lt;text&gt;个性推荐&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;text&gt;歌单&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;text&gt;主播电台&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;text&gt;排行榜&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 内容区域 自适应高度 --&gt; &lt;scroll-view class="content" scroll-y&gt; &lt;swiper class="slide" autoplay indicator-dots&gt; &lt;swiper-item&gt; &lt;image src="../../images/slide.png"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../images/slide.png"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../images/slide.png"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;view class="portals"&gt; &lt;view class="item"&gt; &lt;image src="../../images/04.png"&gt;&lt;/image&gt; &lt;text&gt;私人FM&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/05.png"&gt;&lt;/image&gt; &lt;text&gt;每日歌曲推荐&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/06.png"&gt;&lt;/image&gt; &lt;text&gt;云音乐新歌榜&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="list"&gt; &lt;view class="title"&gt; &lt;text&gt;推荐歌单&lt;/text&gt; &lt;/view&gt; &lt;view class="inner"&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;!-- 播放控制条条 固定高度 --&gt; &lt;view class="player"&gt; &lt;view class="poster"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="info"&gt; &lt;text class="title"&gt;一生中最爱&lt;/text&gt; &lt;text class="artist"&gt;谭咏麟&lt;/text&gt; &lt;/view&gt; &lt;view class="controls"&gt; &lt;image src="../../images/01.png"&gt;&lt;/image&gt; &lt;image src="../../images/02.png"&gt;&lt;/image&gt; &lt;image src="../../images/03.png"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// index.wxsspage &#123; height: 100%;&#125;.root &#123; display: flex; flex-direction: column; height: 100%; background-color: #f0f0f0;&#125;.tabs &#123; display: flex; background-color: pink;&#125;.tabs .item &#123; flex: 1; text-align: center; font-size: 12px; background-color: #222; color: #ccc; padding: 8px 0;&#125;.tabs .item.active &#123; color: #fff; border-bottom: 2px solid #e9232c;&#125;.content &#123; flex: 1; background-color: #111214; color: #ccc; overflow: hidden;&#125;.slide image &#123; width: 100%; height: 130px;&#125;.portals &#123; display: flex; margin-bottom: 15px;&#125;.portals .item &#123; flex: 1;&#125;.portals .item image &#123; width: 60px; height: 60px; display: block; margin: 10px auto;&#125;.portals .item text &#123; display: block; font-size: 12px; text-align: center;&#125;.list .title &#123; margin: 5px 10px; font-size: 14px;&#125;.list .inner &#123; display: flex; flex-wrap: wrap;&#125;.list .inner .item &#123; width: 33.33333333%;&#125;.list .inner .item image &#123; display: block; width: 120px; height: 120px; margin: 0 auto;&#125;.list .inner .item text &#123; font-size: 14px;&#125;.player &#123; display: flex; height: 50px; background-color: #17181A;&#125;.poster image &#123; width: 40px; height: 40px; margin: 5px;&#125;.info &#123; flex: 1; color: #888; font-size: 14px; margin: 5px;&#125;.info .title&#123; display: block; font-size: 16px; color: #ccc;&#125;.controls image &#123; width: 40px; height: 40px; margin: 5px 2px;&#125; 123456// index.json&#123; "navigationBarTitleText": "Music Player", "navigationBarBackgroundColor": "#333", "navigationBarTextStyle": "white"&#125; 三、各种属性 flex-direction调整主轴方向（默认为水平方向） justify-content调整主轴对齐 align-items调整侧轴对齐（子元素可以使用align-self覆盖） flex-wrap控制是否换行 align-content堆栈（由flex-wrap产生的独立行）对齐 flex-flow是flex-direction + flex-wrap的简写形式 flex是子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配 order控制子项目的排列顺序，正序方式排序，从小到大]]></content>
      <tags>
        <tag>flex布局语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git克隆失败和解决办法]]></title>
    <url>%2Fgit%E5%85%8B%E9%9A%86%E5%A4%B1%E8%B4%A5%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git clone 失败，解决办法：–depth 1 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 去github上面去clone一个项目，发现总是失败，网速太差？ 上网查了下原因，给我的git clone 项目地址后面加上--depth 1就好了 原因git clone 是克隆所有历史版本 而 –depth 1 是克隆最近一次的commit， 1 代表克隆深度]]></content>
      <tags>
        <tag>git克隆失败</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative豆瓣电影项目文档]]></title>
    <url>%2FReactNative%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[ReactNative豆瓣电影 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081**项目技能**：react，react-native，android环境**项目目的**：只做项目环境搭建和小部分功能以练习react-native基本功能和android上app的打包构建**项目地址：[ReactNative豆瓣电影](https://github.com/ForeManWang/ReactNative-douban)**## ReactNative项目环境搭建参考我这个文档[ReactNative项目环境搭建](https://qqqww.com/ReactNative%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/)## 首页`在进行这一步之前，先确认项目环境搭建并打包下载到手机上没有任何问题之后，进行之后的代码编写和调试`### 如何更改首页**知识点：`View组件`和`Text组件`****编写一个自己的首页**：根目录下创建`MyHomePage.js`作为自己的首页**注意：在 RN 中只能使用 .js 不能使用 .jsx**```javascript/** * 自己的首页 */// 导入 reactimport React, &#123; Component &#125; from &apos;react&apos;// 按需导入组件， View 组件就好比网页中的 div 元素import &#123; View, Text &#125; from &apos;react-native&apos;export default class MyHomePage extends Component &#123; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; // 1. 在 RN 中不能使用在网页中的所有标签 // 2. 如果想要实现布局，RN 提供了一个叫做 View 的组件，来实现布局， 想要使用，要先导入 return ( &lt;View&gt; &#123; /*3. 在 RN 中，所有的文本，必须使用 RN 提供的 Text 组件进行包裹，依然是按需导入*/ &#125; &lt;Text&gt;123456&lt;/Text&gt; &lt;/View&gt;) &#125;&#125;```在`index.js`中导入自己的组件```javascript// 导入自己的组件页面import MyHomePage from &apos;./MyHomePage.js&apos;// 当使用 AppRegistry 注册项目的时候，方法中的第一个参数不要改// 第二个参数表示要把哪个页面注册为首页AppRegistry.registerComponent(appName, () =&gt; MyHomePage);```## 组件的学习[ReactNative组件](https://qqqww.com/ReactNative组件/)## 正式开始豆瓣电影项目练习了上面一些组件和属性之后，着手去做一个豆瓣电影的小项目### Tabbar#### 基本结构使用组件`react-native-tab-navigator`**react-native-tab-navigator使用方法**：老套路，对照官方文档，装包=&gt;导入=&gt;使用这里的装包，不推荐使用`npm`，首先下载慢，其次如果是`npm5.X`在装新包的时候会把一些老包删除，可能会出现猝不及防的惊喜~ 我这里使用的是facebook开发的yarn装包 1yarn add react-native-tab-navigator // 默认是 --save 12// 导入 Tabbvar 相关组件import TabNavigator from 'react-native-tab-navigator' 1234567891011121314151617181920212223242526export default class MyHomePage extends Component &#123; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; // 1. 在 RN 中不能使用在网页中的所有标签 // 2. 如果想要实现布局，RN 提供了一个叫做 View 的组件，来实现布局， 想要使用，要先导入 return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TabNavigator&gt; &lt;TabNavigator.Item title="Home"&gt; // 放入组件 &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item title="Me"&gt; // 放入组件 &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt; &lt;/View&gt;); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1 &#125;&#125;); 这里的放入组件的位置是自己创建的组件，其他后面的自己创建的组件引入方式也是一样套路创建自己的组件=&gt;引入=&gt;使用 创建自己的新组件，components/tabars/Home.js和components/tabars/Me.js 两个组件都简单写下基本代码 12345678910import React, &#123; Component &#125; from 'react'import &#123; View, Text &#125; from 'react-native'export default class Search extends Component &#123; render() &#123; return &lt;View&gt; &lt;Text&gt;这是 Home 组件&lt;/Text&gt; &lt;/View&gt; &#125;&#125; 引入 12import Home from './components/tabbars/Home.js'import Me from './components/tabbars/Me.js' 使用 12345678910&lt;View style=&#123;styles.container&#125;&gt; &lt;TabNavigator&gt; &lt;TabNavigator.Item title="Home"&gt; &lt;Home&gt;&lt;/Home&gt; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item title="Me"&gt; &lt;Me&gt;&lt;/Me&gt; &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt;&lt;/View&gt;); 组件高亮和切换拿home组件举例子，官方文档上这两句加上就行了 12selected=&#123;this.state.selectedTab === 'home'&#125;onPress=&#123;() =&gt; this.setState(&#123; selectedTab: 'home' &#125;)&#125;&gt; Tab栏的四个组件都按照这样写完，就可以实现正常切换了 组件的图标用react-native-vector-icons的组件，安装=&gt;配置=&gt;导入=&gt;使用 安装1yarn add react-native-vector-icons 配置 在官方文档找到对应的手机平台配置，我这里应为开发的是Android，所以配置的是Android的 编辑 android/app/build.gradle( NOT android/build.gradle ) ,去这个文件中添加下面两行代码 12345project.ext.vectoricons = [ iconFontNames: [ 'MaterialIcons.ttf', 'EvilIcons.ttf', 'FontAwesome.ttf' ] // Name of the font files you want to copy]apply from: "../../node_modules/react-native-vector-icons/fonts.gradle" fonts文件找到自己的字体文件C:\Users\wanggongtou\Desktop\douban\node_modules\react-native-vector-icons\Fonts下面的所有文件全部复制放到android/app/src/main/assets/fonts，下面没有assets/fonts就手动创建一个，再复制进来 将下面两行代码放到android/settings.gradle下合适的位置，并把前面的+去掉 12+ include ':react-native-vector-icons'+ project(':react-native-vector-icons').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-vector-icons/android') 编辑 android/app/build.gradle ，找到dependencies的大括号内部加上compile project(&#39;:react-native-vector-icons&#39;) 1234dependencies &#123; ... compile project(':react-native-vector-icons')&#125; 编辑android\app\src\main\java\com\douban\MainApplication.java在package com.douban; 这句代码下面添加import com.oblador.vectoricons.VectorIconsPackage;这句代码，在同一个文件中，找到protected List&lt;ReactPackage&gt; getPackages()在其内部，加上, new VectorIconsPackage() 12345678910package com.douban;import com.oblador.vectoricons.VectorIconsPackage;@Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage() , new VectorIconsPackage() ); &#125; 注意：只要修改了Android里面的配置文件，要重新打包构建 重新打包构建1react-native run-android 这里可能会遇到两点问题： 问题一：提示没有licenses协议 解决方案：去配置Android的环境目录下，找到 Android SDK Manager 安装 Android SDK Build-tools 23.0.1 并接受其 license; 注意：这里的 Android SDK Build-tools 23.0.1 版本号需要和自己的构建工具版本号相对应 问题二：打包构建之后，发现手机上的app打开没有页面了 解决方案：关闭APP进程，重新打开一下就有了 导入1import Icon from 'react-native-vector-icons/FontAwesome' 使用可以去FontAwesome官网列表中查找对应组件需要的图标，Icon name=图标的名字就可以了 123456789&lt;TabNavigator&gt; &lt;TabNavigator.Item ... renderIcon=&#123;() =&gt; &lt;Icon name="home" size=&#123;25&#125; color="gray" /&gt;&#125; // 未选中状态下，展示的图标 renderSelectedIcon=&#123;() =&gt; &lt;Icon name="home" size=&#123;25&#125; color="#0079FF" /&gt;&#125; // 选中状态下展示的图标 ... &lt;Home&gt;&lt;/Home&gt; &lt;/TabNavigator.Item&gt;&lt;/TabNavigator&gt; 主页主页轮播图静态页面找组件react-native-swiper去官网看， 安装、导入、使用 1yarn add react-native-swiper 因为轮播图在主页，所以在主页的组件中进行导入 12// 导入轮播图组件import Swiper from 'react-native-swiper' 把对应的结构和样式全部都拷贝过来 123456789101112131415161718192021222324252627282930313233343536373839404142434445export default class Search extends Component &#123; render() &#123; return ( &lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125;&gt; &lt;View style=&#123;styles.slide1&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Hello Swiper&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide2&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Beautiful&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide3&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;And simple&lt;/Text&gt; &lt;/View&gt; &lt;/Swiper&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; wrapper: &#123; &#125;, slide1: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#9DD6EB', &#125;, slide2: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#97CAE5', &#125;, slide3: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#92BBD9', &#125;, text: &#123; color: '#fff', fontSize: 30, fontWeight: 'bold', &#125;&#125;) 这里轮播图就出来了，再设置自动轮播和轮播图高度，由于这里的轮播图默认充满全屏，所以可以给轮播图最外层套一个View，给它一个高度 123&lt;View style=&#123;&#123; height: 220 &#125;&#125;&gt; // 放轮播图代码&lt;/View&gt; 给Swiper盒子加上属性，自动轮播 123&lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125; autoplay=&#123;true&#125; loop=&#123;true&#125;&gt; ...&lt;/Swiper&gt; 渲染数据12345678910111213141516171819202122232425262728293031323334export default class Home extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; banner: [] // 轮播图数组 &#125; &#125; componentWillMount() &#123; fetch('http://www.liulongbin.top:3005/api/getlunbo') .then(res =&gt; res.json()) .then(data =&gt; &#123; // console.warn(JSON.stringify(data, null, ' ')) this.setState(&#123; banner: data.message &#125;) &#125;) &#125; render() &#123; return ( &lt;View style=&#123;&#123; height: 220 &#125;&#125;&gt; &lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125; autoplay=&#123;true&#125; loop=&#123;true&#125;&gt; &#123;this.state.banner.map((item, i) =&gt; &#123; return &lt;View key=&#123;i&#125;&gt; &lt;Image source=&#123;&#123;uri: item.img&#125;&#125; style=&#123;&#123;width: '100%', height: '100%'&#125;&#125;&gt;&lt;/Image&gt; &lt;/View&gt; &#125;)&#125; &lt;/Swiper&gt; &lt;/View&gt; ); &#125;&#125; 主页六宫格导入所需要的组件 1import &#123; AppRegistry, StyleSheet, View, Text, Image, TouchableHighlight &#125; from 'react-native' 12345678910// 六宫格区域&#123;/* 在 RN 中，默认，就已经为 所有的 View 启用了弹性和模型，同时，默认的主轴是 纵向的 */&#125; &lt;View style=&#123;&#123; flexDirection: 'row', flexWrap: 'wrap' &#125;&#125;&gt; &lt;View style=&#123;styles.box&#125;&gt; &lt;Image source=&#123;require('../../images/menu1.png')&#125; style=&#123;&#123; width: 60, height: 60 &#125;&#125;&gt;&lt;/Image&gt; &lt;Text&gt;新闻资讯&lt;/Text&gt; &lt;/View&gt; // ...这里根据需求可以增加主页的宫格数目，我这里是六个，上面代码复制六份就可以 &lt;/View&gt; 1234567var styles = StyleSheet.create(&#123; box: &#123; width: '33.33%', alignItems: 'center', marginTop: 15 &#125;&#125;) 热映电影Main.js 配置路由在项目根目录新建一个Main.js作为项目根组件，修改一下index.js中指向App.js的代码 12import Main from './Main.js'AppRegistry.registerComponent(appName, () =&gt; Main); 去编辑Main.js的代码 1234// Main 项目的根组件// 导入组件import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, ActivityIndicator &#125; from 'react-native' 安装一个配置路由规则的插件react-native-router-flux 1yarn add react-native-router-flux 在Main.js中导入 1import &#123; Router, Stack, Scene &#125; from 'react-native-router-flux' Router: 就相当于 HashRouterStack: 这是一个分组的容器，他不表示具体的路由，专门用来给路由分组的Scene：就表示一个具体的路由规则，好比 昨天学到的 Route 新建两个组件components/movie/MovieList.js和components/movie/MovieDetail.js作为电影列表组件和电影描述组件 而且由于更换了项目的根组件，所以需要在Main.js中导入App.js 1234// 导入组件import App from './App.js'import MovieList from './components/movie/MovieList.js'import MovieDetail from './components/movie/MovieDetail.js' 继续修改代码将App.js作为首页展示，在render渲染的时候，可以配置首页，并且一并配置其他页面路由 1234567891011121314render() &#123; return &lt;Router sceneStyle=&#123;&#123; backgroundColor: 'white' &#125;&#125;&gt; &lt;Stack key="root"&gt; &#123;/* 配置路由规则 */&#125; &#123;/* 注意，所有的路由规则，都应该写到这个位置 */&#125; &#123;/* 第一个 Scene 就是默认要展示的首页 */&#125; &#123;/* key 属性，表示路由的规则名称，将来可以使用这个 key ，进行编程式导航，每一个路由规则，都应该提供一个 唯一的key， key不能重复 */&#125; &lt;Scene key="app" component=&#123;App&#125; title="" hideNavBar=&#123;true&#125; /&gt; &#123;/* 电影列表的路由规则 */&#125; &lt;Scene key="movielist" component=&#123;MovieList&#125; title="热映电影列表" /&gt; &lt;Scene key="moviedetail" component=&#123;MovieDetail&#125; title="电影详情" /&gt; &lt;/Stack&gt; &lt;/Router&gt;&#125; 这个时候，依然是不能点击跳转的，是因为没有给Home.js内部的热映电影组件绑定点击事件，所以去帮顶下 用TouchableHighlight包裹Home.js中的热映电影的代码片段 1234567891011// 在使用前应该现在最前面导入该组件import &#123; AppRegistry, StyleSheet, View, Text, Image, TouchableHighlight &#125; from 'react-native' // 包裹 &lt;TouchableHighlight onPress=&#123;this.goMovieList&#125; underlayColor="white" style=&#123;styles.box&#125;&gt; &#123;/* 在 TouchableHighlight 内部，只能放置唯一的一个元素 */&#125; &lt;View&gt; &lt;Image source=&#123;require('../../images/menu5.png')&#125; style=&#123;&#123; width: 60, height: 60 &#125;&#125;&gt;&lt;/Image&gt; &lt;Text&gt;热映电影&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt;// goMovieList 方法在下面定义 导入Actions组件，实现编程式导航 123// 导入 Actions 组件，实现编程式导航// Actions 表示要进行 JS 操作了import &#123; Actions &#125; from 'react-native-router-flux' 写一个跳转方法,并去TouchableHighlight中绑定这个方法 123456render() &#123; ... goMovieList = () =&gt; &#123; Actions.movielist() &#125;&#125; 1&lt;TouchableHighlight onPress=&#123;this.goMovieList&#125; underlayColor="white" style=&#123;styles.box&#125;&gt; 这样就实现了基本的路由跳转 豆瓣热映电影列表基本页面123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, StyleSheet, ... &#125; from 'react-native'const styles = StyleSheet.create(&#123; ...&#125;)// 导入路由的组件import &#123; Actions &#125; from 'react-native-router-flux'export default class MovieList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; ... &#125; &#125; componentWillMount() &#123; ... &#125; render() &#123; return ... &#125; ...&#125; 豆瓣接口这里先说一下豆瓣接口，根据接口可以进行数据的获取 访问https://api.douban.com/v2/movie/in_theaters?start=0&amp;count=12可以看到豆瓣的电影数据，链接中的?后面的参数start表示开始页码，count表示每页显示的记录条数，可以根据需求修改，可以拷贝假数据用于测试，可以调用接口，用于测试方法成功之后进行动态数据的渲染 fetch获取电影列表数据 根据页码获取电影列表数据 渲染电影列表的方法测试 每项数据需要同步this.state中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default class MovieList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; movies: [], // 电影列表 nowPage: 1, // 当前的页码 totalPage: 0, // 总页数 pageSize: 15, // 每页显示的记录条数 isloading: true // 是否正在加载数据 &#125; &#125; componentWillMount() &#123; this.getMoviesByPage() &#125; render() &#123; return &lt;View&gt; &#123;this.renderList()&#125; &lt;/View&gt; &#125; // 根据页码获取电影列表 getMoviesByPage = () =&gt; &#123; const start = (this.state.nowPage - 1) * this.state.pageSize const url = `https://api.douban.com/v2/movie/in_theaters?start=$&#123;start&#125;&amp;count=$&#123;this.state.pageSize&#125;` /* fetch(url) .then(res =&gt; res.json()) .then(data =&gt; &#123; this.setState(&#123; isloading: false, movies: this.state.movies.concat(data.subjects), totalPage: Math.ceil(data.total / this.state.pageSize) &#125;) &#125;) */ /* 此代码用了拷贝的假数据用于测试 */ setTimeout(() =&gt; &#123; this.setState(&#123; isloading: false, movies: require('./test_list.json').subjects, totalPage: 1 &#125;) &#125;, 1000) &#125; // 渲染电影列表的方法,此处用于测试，若能获取电影条数则方法可以继续往下写 renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;View&gt; &lt;Text&gt;&#123;this.state.moives.length&#125;&lt;/Text&gt; &lt;/View&gt; &#125; ...&#125; 渲染电影列表数据12345678910111213141516171819202122232425// 渲染电影列表的方法 renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;FlatList data=&#123;this.state.movies&#125; keyExtractor=&#123;(item, i) =&gt; i&#125; // 解决 key 问题 renderItem=&#123;(&#123; item &#125;) =&gt; this.renderItem(item)&#125; // 调用方法，去渲染每一项 /&gt; &#125; // 渲染每项电影 renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight&gt; &lt;View&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#125; 美化布局相当于加一些样式，不然太丑了 123456789101112131415161718192021222324252627282930313233// 渲染电影列表的方法renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;FlatList data=&#123;this.state.movies&#125; keyExtractor=&#123;(item, i) =&gt; i&#125; // 解决 key 问题 renderItem=&#123;(&#123; item &#125;) =&gt; this.renderItem(item)&#125; // 调用方法，去渲染每一项 ItemSeparatorComponent=&#123;this.renderSeparator&#125; //渲染分割线的属性方法 onEndReachedThreshold=&#123;0.5&#125; // 距离底部还有多远的时候，触发加载更多的事件 onEndReached=&#123;this.loadNextPage&#125; // 当距离不足 0.5 的时候，触发这个方法，加载下一页数据 /&gt;&#125;// 渲染每项电影renderItem = (item) =&gt; &#123; return &lt;View style=&#123;&#123; flexDirection: 'row', padding: 10 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View style=&#123;&#123; justifyContent: 'space-around' &#125;&#125;&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt;&#125;// 渲染分割线renderSeparator = () =&gt; &#123; return &lt;View style=&#123;&#123; borderTopColor: '#ccc', borderTopWidth: 1, marginLeft: 10, marginRight: 10 &#125;&#125;&gt;&lt;/View&gt;&#125; 下拉加载更多利用官方文档的属性onEndReachedThreshold和onEndReached来控制 onEndReachedThreshold距离底部还有多远的时候，触发加载更多的事件 onEndReached:当距离不足 0.5 的时候，触发这个方法，加载下一页数据 123456789101112131415161718192021222324252627282930313233343536373839404142// 渲染电影列表的方法 renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;FlatList data=&#123;this.state.movies&#125; keyExtractor=&#123;(item, i) =&gt; i&#125; // 解决 key 问题 renderItem=&#123;(&#123; item &#125;) =&gt; this.renderItem(item)&#125; // 调用方法，去渲染每一项 ItemSeparatorComponent=&#123;this.renderSeparator&#125; //渲染分割线的属性方法 onEndReachedThreshold=&#123;0.5&#125; // 距离底部还有多远的时候，触发加载更多的事件 onEndReached=&#123;this.loadNextPage&#125; // 当距离不足 0.5 的时候，触发这个方法，加载下一页数据 /&gt; &#125; // 渲染每项电影 renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight underlayColor="#fff" onPress=&#123;() =&gt; &#123; Actions.moviedetail(&#123; id: item.id &#125;) &#125;&#125;&gt; &lt;View style=&#123;&#123; flexDirection: 'row', padding: 10 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View style=&#123;&#123; justifyContent: 'space-around' &#125;&#125;&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#125; // 加载下一页 loadNextPage = () =&gt; &#123; // 如果下一页的页码值，大于总页数了，直接return if ((this.state.nowPage + 1) &gt; this.state.totalPage) &#123; return &#125; this.setState(&#123; nowPage: this.state.nowPage + 1 &#125;, function () &#123; this.getMoviesByPage() &#125;) &#125; 提升体验写着写着，遇到了个问题，这时不时的访问不到服务，但是这好像和代码关系不大，因为我重连几次就可以了，我觉得和网速关系很大，我这网速太渣 所以我就加了几句提示错误的代码 123456789101112131415161718getMoviesByPage = () =&gt; &#123; const start = (this.state.nowPage - 1) * this.state.pageSize const url = `https://api.douban.com/v2/movie/in_theaters?start=$&#123;start&#125;&amp;count=$&#123;this.state.pageSize&#125;` fetch(url) .then(res =&gt; &#123; if (res.ok) &#123; return res.json() &#125; else &#123; console.error('服务器忙，请稍后重试' + res.status) &#125; &#125;) .then(data =&gt; &#123; ... &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) &#125; 豆瓣热映电影详情基本页面12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, ActivityIndicator, ScrollView &#125; from 'react-native'export default class MovieDetail extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; movieInfo: &#123;&#125;, // 电影信息 isloading: true &#125; &#125; componentWillMount() &#123; ... &#125; render() &#123; return &lt;View&gt; ... &lt;/View&gt; &#125; ...&#125; 同样的需要去Main.js配置路由规则，和配置MovieList组件的路由规则一个套路，这里由于我之前配置过了，不再配置 给MovieDetil在MovieList中的代码片段（就是渲染的每一部电影的代码片段）加上链接跳转，这里依然是要依靠TouchableHighlight组件 首先引入 1import &#123; View, Image, Text, ActivityIndicator, FlatList, StyleSheet, TouchableHighlight &#125; from 'react-native' 在获取每项电影的时候，代码片段用TouchableHighlight包裹起来 12345678910111213renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight underlayColor="#fff"&gt; &lt;View style=&#123;&#123; flexDirection: 'row', padding: 10 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View style=&#123;&#123; justifyContent: 'space-around' &#125;&#125;&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#125; 绑定点击事件，并导入Actions，实现编程式导航 12// 导入路由的组件import &#123; Actions &#125; from 'react-native-router-flux' 123456// 渲染每项电影renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight underlayColor="#fff" onPress=&#123;() =&gt; &#123; Actions.moviedetail(&#123; id: item.id &#125;) &#125;&#125;&gt; ... &lt;/TouchableHighlight&gt;&#125; 数据渲染在生命周期是componentWillMount()的时候从接口获取数据，再到this.state同步数据，然后去render()填充数据，这里为render()定义了一个方法，直接this.renderInfo()调用就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, ActivityIndicator, ScrollView &#125; from 'react-native'export default class MovieDetail extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; movieInfo: &#123;&#125;, // 电影信息 isloading: true &#125; &#125; componentWillMount() &#123; fetch('https://api.douban.com/v2/movie/subject/' + this.props.id) .then(res =&gt; res.json()) .then(data =&gt; &#123; this.setState(&#123; movieInfo: data, isloading: false &#125;) &#125;) &#125; render() &#123; return &lt;View&gt; &#123;this.renderInfo()&#125; &lt;/View&gt; &#125; renderInfo = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;ScrollView&gt; &lt;View style=&#123;&#123; padding: 4 &#125;&#125;&gt; &lt;Text style=&#123;&#123; fontSize: 25, textAlign: 'center', marginTop: 20, marginBottom: 20 &#125;&#125;&gt;&#123;this.state.movieInfo.title&#125;&lt;/Text&gt; &lt;View style=&#123;&#123; alignItems: 'center' &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: this.state.movieInfo.images.large &#125;&#125; style=&#123;&#123; width: 200, height: 280 &#125;&#125;&gt;&lt;/Image&gt; &lt;/View&gt; &lt;Text style=&#123;&#123; lineHeight: 30, marginTop: 20 &#125;&#125;&gt;&#123;this.state.movieInfo.summary&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/ScrollView&gt; &#125;&#125; 提示：各种接口数据最好借助Postman工具，先看一下接口数据里哪些属性要用，不然挺乱的，不过不借助Psotman工具的话也可以去该接口连接把json数据拷贝下来到编辑器中，自己整理下格式 小功能体验：拍照功能为Me.js添加一个拍照功能 调用插件react-native-image-picker该插件可以调用摄像头 安装包 1yarn add react-native-image-picker 导入包 123import &#123; View, Button, Image &#125; from 'react-native'// 导入拍照的包import ImagePicker from 'react-native-image-picker' 创建拍照时的配置对象 1234567891011121314var photoOptions = &#123; //底部弹出框选项 title: '请选择', cancelButtonTitle: '取消', takePhotoButtonTitle: '拍照', chooseFromLibraryButtonTitle: '选择相册', quality: 0.75, // 照片的质量 allowsEditing: true, // 允许被编辑 noData: false, // 拍照时候不附带日期 storageOptions: &#123; // 存储选项 skipBackup: true, // 在IOS平台中，会自动把 照片同步到 云端的存储，如果此项为 true，表示跳过 备份，不会把照片上传到 云端 path: 'images' &#125;&#125; 创建保存数据的容器 123456constructor(props) &#123; super(props); this.state = &#123; imgURL: 'https://qqqww.com/uploads/avatar.png' // 将来，拍摄的照片路径，会存到这里 &#125; &#125; 渲染 123456render() &#123; return &lt;View style=&#123;&#123; alignItems: 'center', paddingTop: 70 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: this.state.imgURL &#125;&#125; style=&#123;&#123; width: 200, height: 200, borderRadius: 100 &#125;&#125;&gt;&lt;/Image&gt; &lt;Button title="拍照" onPress=&#123;this.cameraAction&#125;&gt;&lt;/Button&gt; &lt;/View&gt; &#125; 定义一个拍照方法，在渲染的时候调用 12345678910111213cameraAction = () =&gt; &#123; ImagePicker.showImagePicker(photoOptions, (response) =&gt; &#123; console.log('response' + response); if (response.didCancel) &#123; // 点击了取消按钮，此时，用户没有拍照 return &#125; // 用户已经拍摄了一张照片了 this.setState(&#123; imgURL: response.uri &#125;); &#125;) &#125; 到这一步，在React-Native项目中的拍照功能就完成了，并且手机测试成功 发布安卓项目说明：这只是用于测试react-native的一部分功能的小demo，并不能用于实际作用 先保证配置了一个正确的RN环境 在 cmd 命令行中，运行这一句话keytool -genkey -v -keystore my-release-key2.keystore -alias my-key-alias2 -keyalg RSA -keysize 2048 -validity 10000生成签名 my-release-key.keystore 表示你一会儿要生成的那个 签名文件的 名称【很重要，包找个小本本记下来】 -alias 后面的东西，也很重要，需要找个小本本记下来，这个名称可以根据自己的需求改动my-key-alias 当运行找个命令的时候，需要输入一系列的参数，找个口令的密码，【一定要找个小本本记下来】 当生成了签名之后，这个签名，默认保存到了自己的用户目录下C:\Users\liulongbin\my-release-key2.keystore 将你的签名证书copy到 android/app目录下。 编辑 android -&gt; gradle.properties文件，在最后，添加如下代码： 1234MYAPP_RELEASE_STORE_FILE=your keystore filenameMYAPP_RELEASE_KEY_ALIAS=your keystore aliasMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** 编辑 android/app/build.gradle文件添加如下代码： 1234567891011121314151617181920...android &#123; ... defaultConfig &#123; ... &#125; + signingConfigs &#123; + release &#123; + storeFile file(MYAPP_RELEASE_STORE_FILE) + storePassword MYAPP_RELEASE_STORE_PASSWORD + keyAlias MYAPP_RELEASE_KEY_ALIAS + keyPassword MYAPP_RELEASE_KEY_PASSWORD + &#125; +&#125; buildTypes &#123; release &#123; ... + signingConfig signingConfigs.release &#125; &#125;&#125;... 进入项目根目录下的android文件夹，在当前目录打开终端，然后输入./gradlew assembleRelease开始发布APK的Release版； 第七步出了点小问题，报错信息是Execution failed for task ‘:app:validateSigningRelease’.后来看看原来是我的第五步里的MYAPP_RELEASE_KEY_ALIAS=your keystore alias这一块的签名写错了，忘了加后缀名，改了之后，又给了我一个响应超时的惊喜，不过我就重新运行了第二次就打包构建成功了 当发行完毕后，进入自己项目的android\app\build\outputs\apk目录中，找到app-release.apk，这就是我们发布完毕之后的完整安装包；安装到自己和朋友的手机上，测试成功，就可以上传到各大应用商店供用户使用啦。 注意：请记得妥善地保管好你的密钥库文件，不要上传到版本库或者其它的地方。 参考文章： ReactNative之Android打包APK方法（趟坑过程） React Native发布APP之签名打包APK]]></content>
      <tags>
        <tag>ReactNative豆瓣电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative组件]]></title>
    <url>%2FReactNative%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[ReactNative组件 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 该文档要配合项目文档地址ReactNative豆瓣电影看会更好 这里只写我在进行ReactNative豆瓣电影项目的时候去ReactNative官网研究过的组件 Platform: 用来提供平台检测功能的 StyleSheet: 样式相关的组件，专门用来创建样式的 Text: 文本节点，所有文本必须放到这个里面 View: 用来布局的，相当于 div TextInput: 文本框组件 Image: 图片组件 Button: 按钮组件 ActivityIndicator: 加载中的 loading 效果小圆圈 ScrollView: 滚动组件（默认，如果一个RN的页面非常长，超出了屏幕高度，这时候，不会像网页中那样自动提 供滚动条，如果需要让页面实现滚动的话，需要使用 ScrollView 把页面包裹起来） 基本都是导入组件，然后在首页中用render()渲染就可以了，真是超级无敌爆炸爽 1234// 导入 React 基础包，这个包，作用是创建 组件import React, &#123; Component &#125; from 'react'// 从 react-native 中导入系统开发需要的包import &#123;Platform, StyleSheet, Text, View ...&#125; from 'react-native' Platform用来提供平台检测功能 123456const instructions = Platform.select(&#123; ios: 'Press Cmd+R to reload,\n' + 'Cmd+D or shake for dev menu', android: 'Double tap R on your keyboard to reload,\n' + 'Shake or press menu button for dev menu',&#125;); StyleSheet使用 StyleSheet.create 创建样式表对象，可以为 create 传递一个配置对象，这个对象就是要创建的样式 123456789101112131415161718const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', // 一些文本类型的样式值，需要引号包裹起来 alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, welcome: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;, instructions: &#123; textAlign: 'center', color: '#333333', marginBottom: 5, &#125;,&#125;); 载入样式(和对象的操作一样，例如style.welcome) 12345678910export default class App extends Component&lt;Props&gt; &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt;Welcome to React Native!&lt;/Text&gt; ... &lt;/View&gt; ); &#125;&#125; Text文本节点，所有文本必须放到这个里面，在项目文档地址上面首页中有讲到 View用来布局的，相当于页面元素div，在项目文档地址上面首页中有讲到 TextInput文本框组件 这里刚开始输入框会特别窄，所以需要修改样式 在styles对象中添加一个一个键值对inputStyle: { width: &#39;100%&#39; } TextInput有很多属性选项，这里使用的几个练手,具体参考ReactNative官方文档 allowFontScaling控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。 类型 必填 bool No autoCapitalize控制TextInput是否要自动将特定字符切换为大写，This property is not supported by some keyboard types such as name-phone-pad. characters: 所有的字符。 words: 每个单词的第一个字符。 sentences: 每句话的第一个字符（默认）。 none: 不切换。 类型 必填 enum(‘none’, ‘sentences’, ‘words’, ‘characters’) No autoFocus如果为true，在componentDidMount后会获得焦点。默认值为false。 类型 必填 bool No defaultValue提供一个文本框中的初始值。当用户开始输入的时候，值就可以改变。在一些简单的使用情形下，如果你不想用监听消息然后更新value属性的方法来保持属性和状态同步的时候，就可以用defaultValue来代替。 类型 必填 string No keyboardType决定弹出的何种软键盘的，譬如numeric（纯数字键盘）。 这些值在所有平台都可用： default number-pad decimal-pad numeric email-address phone-pad 下面的值仅iOS可用： ascii-capable numbers-and-punctuation url name-phone-pad twitter web-search 下面的值仅Android可用： visible-password 类型 必填 enum(‘default’, ‘email-address’, ‘numeric’, ‘phone-pad’, ‘ascii-capable’, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’, ‘visible-password’) No maxLength限制文本框中最多的字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。 类型 必填 number No multiline如果为true，文本框中可以输入多行文字。默认值为false。注意安卓上如果设置multiline = {true}，文本默认会垂直居中，可设置textAlignVertical: &#39;top&#39;样式来使其居顶显示。 类型 必填 bool No onChange当文本框内容变化时调用此回调函数。回调参数为{ nativeEvent: { eventCount, target, text} }。 类型 必填 function No onChangeText当文本框内容变化时调用此回调函数。改变后的文字内容会作为参数传递。 类型 必填 function No placeholder如果没有任何文字输入，会显示此字符串。 类型 必填 string No placeholderTextColor占位字符串显示的文字颜色。 类型 必填 color No secureTextEntry如果为true，文本框会遮住之前输入的文字，这样类似密码之类的敏感文字可以更加安全。默认值为false。multiline={true}时不可用。 类型 必填 bool No Image图片组件 Image的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 style这里可以自定义样式，或者使用枚举 类型 必填 style 否 source图片源数据（远程 URL 地址或本地数据）。 目前原生支持的图片格式有png、jpg、jpeg、bmp、gif、webp (仅 Android)、psd (仅 iOS)。 类型 必填 ImageSourcePropType 否 Button按钮组件 Button的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 onPress用户点击此按钮时所调用的处理函数, 必须的 类型 必填 function 是 title按钮内显示的文本，必须的 类型 必填 string 是 accessibilityLabel用于给残障人士显示的文本（比如读屏应用可能会读取这一内容） 类型 必填 string 否 color文本的颜色(iOS)，或是按钮的背景色(Android) 类型 必填 color 否 disabled设置为 true 时此按钮将不可点击。 类型 必填 bool 否 testID用来在端到端测试中定位此视图。 类型 必填 string 否 ActivityIndicator加载中的 loading 效果小圆圈 ActivityIndicator的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 animating是否要显示指示器动画，默认为 true 表示显示，false 则隐藏。 类型 必填 bool 否 color滚轮的前景颜色（默认为灰色）。 类型 必填 color 否 size指示器的大小，默认为’small’。目前只能在 Android 上设定具体的数值。 类型 必填 enum(‘small’, ‘large’), number 否 ScrollView滚动组件（默认，如果一个RN的页面非常长，超出了屏幕高度，这时候，不会像网页中那样自动提 供滚动条，如果需要让页面实现滚动的话，需要使用 ScrollView 把页面包裹起来） ScrollView的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 horizontal当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。 类型 必填 bool 否 滚轮的前景颜色（默认为灰色）]]></content>
      <tags>
        <tag>ReactNative组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative项目环境搭建]]></title>
    <url>%2FReactNative%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[ReactNative项目环境搭建 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 项目地址：ReactNative豆瓣电影 看到github中ReactNative豆瓣电影的项目, 打算做一个基本功能的练练手，然后就项目基本配置中就遇到了不少坑，这里总结一下流程和遇到的一些坑，万一再遇到了，还能再来看解决方案 说明：ReactNative的项目建议由React开发经验的看会事半功效 ReactNative项目环境的搭建需要： android编译环境 手机设备能够正常连接电脑并通过adb devices指令测试连接正确 成功打包并安装到手机 基本开发环境首先，我是按照React Native中文网的方法，一步一步安装的，但并不成功，（错误信息大概描述的是android develepment or device安卓或者手机设备的问题，后面还有个fail connection连接失败）, 所以配合下面的android环境搭建和手机设备正确连接之后才成功，但是这些步骤在后续的环境搭建过程中肯定是有用到的 这里简述一下步骤： Chocolatey安装 Chocolatey是一个 Windows 上的包管理器，类似于 linux 上的yum和 apt-get。 你可以在其官方网站上查看具体的使用说明。一般的命令行安装步骤应该是下面这样： 1@powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 一般来说，使用 Chocolatey 来安装软件的时候，需要以管理员的身份来运行命令提示符窗口。译注：chocolatey 的网站可能在国内访问困难，导致上述安装命令无法正常完成。请使用稳定的翻墙工具。 如果你实在装不上这个工具，也不要紧。下面所需的 python2 和 nodejs 你可以分别单独去对应的官方网站下载安装即可。 Python 2安装 打开命令提示符窗口，使用 Chocolatey 来安装 Python 2. 1choco install python2 Node安装 打开命令提示符窗口，使用 Chocolatey 来安装 NodeJS。注意，目前已知 Node 7.1 版本在 windows 上无法正常工作，请避开这个版本！ 1choco install nodejs.install 安装完 node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！ 其实到这里我才知道为什么要安装另外一个包管理工具Chocolatey，原以为我安装过NodeJS的就不需要重新安装了（我以前使用cnpm安装的），但这个官方文档明显提到不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！所以我这里老老实实的又用choco指令安装了一遍Node 安装完 node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！ 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global Yarn、React Native 的命令行工具（react-native-cli） Yarn是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 1npm install -g yarn react-native-cli 安装完 yarn 后同理也要设置镜像源： 12yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 这里是官方提示的一个错误：但我的安装过程中没有遇到，先放到这 如果你遇到EACCES: permission denied权限错误，可以尝试运行下面的命令（限 linux 系统）： sudo npm install -g yarn react-native-cli. android环境搭建(Android Studio)1、这里是我是直接去官网下载的最新版Android Studio 下载下来就是这么个玩意： 2、一看到exe文件，直接安装嘛，这里建议不要随意安装到其他目录（因为第一次我就安装到了我自定义的我的个人dev目录中，就后面各种错误，后来卸载，重新开始），按照他默认的走，还有之后需要下载的插件选项，尽量他默认打钩的，不要去掉，然后再加上我建议的就行了 3、记住以上的钩都要选上，初步安装过程结束后，选择Custom选项 4、选择如下图的组件安装，都选上 5、这里遇到了这样一堆错误 1Preparing &quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot;.Downloading https://dl.google.com/android/repository/platform-tools_r28.0.0-windows.zip&quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot; ready.Installing Android SDK Platform-Tools in D:\Android\sdk\platform-tools&quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot; complete.&quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot; finished.Preparing &quot;Install Android Support Repository (revision: 47.0.0)&quot;.Downloading https://dl.google.com/android/repository/android_m2repository_r47.zipjava.io.IOException: Cannot download &apos;https://dl.google.com/android/repository/android_m2repository_r47.zip&apos;: SSL peer shut down incorrectly, response: 200 OKWarning: An error occurred while preparing SDK package Android Support Repository: Cannot download &apos;https://dl.google.com/android/repository/android_m2repository_r47.zip&apos;: SSL peer shut down incorrectly, response: 200 OK.&quot;Install Android Support Repository (revision: 47.0.0)&quot; failed.Preparing &quot;Install Android SDK Tools (revision: 26.1.1)&quot;.Downloading https://dl.google.com/android/repository/sdk-tools-windows-4333796.zipjava.io.IOException: Cannot download &apos;https://dl.google.com/android/repository/sdk-tools-windows-4333796.zip&apos;: Read timed out, response: 200 OKWarning: An error occurred while preparing SDK package Android SDK Tools: Cannot download &apos;https://dl.google.com/android/repository/sdk-tools-windows-4333796.zip&apos;: Read timed out, response: 200 OK.&quot;Install Android SDK Tools (revision: 26.1.1)&quot; failed.Preparing &quot;Install SDK Patch Applier v4 (revision: 1)&quot;.Downloading https://dl.google.com/android/repository/3534162-studio.sdk-patcher.zip.bakjava.io.IOException: Cannot download 没复制全，就大概讲的是插件安装失败，主要错误原因就是外国网站被墙或者网速实在太渣,为什么这样讲呢？因为我去网上查，都说是被墙，但我很确认我已经翻墙了啊，而且后面安装插件的过程中，一直重试，发现有些能成功，有些不能成功（这里要多看日志），所以我断定是网络过慢原因了，多重试，而且一定要开vpn 6、安装过程中，有一个选择主题的环节，一个白色的，一个黑色的，随便选一个，主题嘛，看着顺眼就行 下面就可以一直默认安装到最后有一个让你运行Android Studio ，然后直接运行，会到Android Studio的欢迎界面 ，它的有下角有个Configure, Configure下面有个SDK Manager,点击进去 7、在SDK Platforms窗口中，选择Show Package Details，然后在Android 6.0 (Marshmallow)中勾选Google APIs、Android SDK Platform 23、Intel x86 Atom System Image、Intel x86 Atom_64 System Image以及Google APIs Intel x86 Atom_64 System Image。这里遇到和6同样的问题，先看下面的第8步再apply 8、在SDK Tools窗口中，选择Show Package Details，然后在Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1（必须是这个版本）。然后还要勾选最底部的Android Support Repository.这里也遇到和6同样的问题 解决办法：两个 办法一：开VPN，我这里用的蓝灯 办法二：可以直接迅雷加速下载包到本地，然后一个一个放入该放的文件夹中，这里可以参考文档手动安装配置Android Studio，在本文后面我会把这里所需要的插件一整套，全部整理上传到我的百度云，这样从我的百度云下载应该就好多了，然后再参考前面的手动安装配置Android Studio文档手动配置也可以的 下面会有android环境依赖包、基本依赖包、vpn软件一整套的百度云链接 到这一步，Android Studio环境基本就配置好了 手机驱动安装手机驱动查看和安装这里要把手机连接到电脑上 前面android环境配置好之后，我又去测试了下，测试命令 1234// 初始化一个安卓仓库react-native init douban// 安装app到手机上react-native run-android 但是又发现报了一个错误设备不能连接或者是android环境问题 然后这里我去我的电脑=&gt;管理=&gt;设备管理器查看了下 我这里用驱动人生更新过了，所以红框中看起来一切正常，遇到设备问题一定要去电脑的驱动管理看看，看带!号的或者带?号的相关驱动去给更新下 到了这一步，然后我再来测试 手机设备的设置启用开发者模式这里拿我的小米手机举例 你的手机=&gt;设置=&gt;我的设备或者我的手机=&gt;全部参数=&gt;MIUI版本（其他手机找版本号就对了）=&gt;莲须点十几下基本上这时候就显示你已经处于开发者模式了 返回设置=&gt;更多设置=&gt;开发者选项=&gt;打开开发者选项和USB调试和USB安装和USB调试（安全设置） 由于到了这一步也翻了不少文档，我又多学了一条测试手机设备连接的指令 cmd命令行输入命令检测下 1adb devices 这是后命令行给到的结果就能显示成功连接了，下面再进行安卓环境初始化和打包安装到手机就可以成功了 1react-native init douban 安装成功这时候发现手机上多了一个叫douban的应用 回去node后台看看 这个窗口，就是React Native Packager 是帮我们实时编译项目源代码的，并把编译结果应用到手机上，可以让开发者随时查看最新的项目代码效果。 打开手机上刚安装的应用看看 就显示Welcome to React Native，这样就可以通过App.js入口文件进行开发和调试了 在手机上查看代码在Welcome to React Native界面常按左下角的菜单键，会弹出下图 android环境支持包百度云链接依赖包里有android环境依赖包、基本依赖包、vpn软件 链接：https://pan.baidu.com/s/1Oj2EUuuuNbKdQcoeUsc1AQ提取码：tbo6 参照文档搭建基本的开发环境 - 英文官网搭建基本的开发环境 - 中文]]></content>
      <tags>
        <tag>ReactNative豆瓣电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-虚拟DOM与Diff算法]]></title>
    <url>%2FReact-%E8%99%9A%E6%8B%9FDOM%2F</url>
    <content type="text"><![CDATA[虚拟DOM与Diff算法 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 虚拟DOM(Virtual Document Object Model)的模拟DOM树操作需要用到DIff算法，推荐先看这句话下面的文章内容 DOM的本质 浏览器中的概念，用JS对象来表示 页面上的元素，并提供了操作 DOM 对象的API React中的虚拟DOM 框架中的概念，是程序员 用JS对象来模拟 页面上的 DOM 和 DOM嵌套 实现虚拟DOM的目的 为了实现页面中， DOM 元素的高效更新 DOM和虚拟DOM的区别 DOM：浏览器中，提供的概念；用JS对象，表示页面上的元素，并提供了操作元素的API 虚拟DOM：是框架中的概念；而是开发框架的程序员，手动用JS对象来模拟DOM元素和嵌套关系 本质： 用JS对象，来模拟DOM元素和嵌套关系 目的：就是为了实现页面元素的高效更新 如何实现页面元素的高效更新利用虚拟DOM可以实现页面元素的高效更新，那么如何实现页面元素的高效更新呢？ 假如我有一个需求：点击列头，实现表格数据顺序的排序 数据来源：表格中的数据从数据库查询而来 存储：这些查询到的数据以数组的形式，存放到了浏览器的内存中 渲染： 方案一：手动for循环整个数据，手动拼接字符串str += &#39;&lt;tr&gt;123&lt;tr&gt;&#39; 方案二：使用模板引擎，类似art-template，比手动更方便点，其内部本质也是拼接了字符串 思考：对于上述方案，思考其缺陷和解决方案 如果用户点击了时间,想要按照时间从大到小的排序，其流程应当是： 触发点击事件，在事件中，把内存中的对象数组，重新排序 当排序完成之后，页面时旧的，但是内存中的顺序是最新的 把最新的数据顺序渲染到页面上 上述方案只是实现了把数据渲染到页面中，但是并没有把性能做到最优，这里的第三步，完全可以按需渲染页面(只重新渲染排序中需要更新的数据所对应的页面元素)，以提高性能 DOM树实现按需渲染： 什么是DOM树： DOM结构，类似下图1中的结构 一个网页的呈现过程： 浏览器请求服务器获取HTML代码 浏览器在内存中，解析DOM结构, 并在浏览器中内存中渲染出一棵DOM树 浏览器把DOM树呈现到页面上 怎么按需更新：获取内存中新旧两棵DOM树，得到需要被按需更新得DOM树 如何获取到新旧两棵DOM树： 浏览器并没有直接提供获取DOM树的相关API，因此无法拿到内存中的DOM树 可以自己手动模拟新旧两棵DOM树 那么怎么去模拟DOM树呢 模拟一个DOM元素，假如网页上有一个div元素，怎么模拟呢？用js以字面量赋值的形式进行模拟，看下图模拟DOM元素 当旧的DOM发生改变，对比两棵DOM树的标签和值，如果都相等，则不变，如果标签相同，值不同，则修改，这样的新旧两棵树就是模拟DOM树 总结：什么是虚拟DOM 用JS对象的形式，来模拟页面上的DOM嵌套关系，即虚拟DOM是以JS对象的形式存在的 React中虚拟DOM对象的本质和目的： 本质：用JS对象来模拟DOM元素的嵌套关系 目的：实现页面元素的高效更新 Diff算法 tree diff上图中新旧两棵DOM树每一层对比的过程叫做tree diff，当整棵DOM树逐层对比完毕，则所有的按需更新的元素必然能够找到 component diff在进行tree diff的时候，每一层中组件级别的对比，叫做component diff 如果对比前后，组件类型相同，则暂时认为不需要更新组件 如果对比前后，组件类型不同，则需要暂时移除旧组件，创建新组件，追加到页面上 element diff在进行组件对比的时候，如果两个组件类型相同，需要进行元素级别的对比，这叫做element diff]]></content>
      <tags>
        <tag>虚拟DOM与Diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-vuex]]></title>
    <url>%2Fvue-vuex%2F</url>
    <content type="text"><![CDATA[vuex 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 描述本文档对于有一定vue项目环境搭建和配置的相关经验的人会更轻松的理解 什么是 vuex vuex 是 Vue 配套的公共管理数据工具，他可以把一些共享的数据，保存到 vuex 中，方便整个程序中的任何组件直接获取或者修改公共数据 为什么要用vuex下面原始的传值和vuex的区别与优缺点 兄弟组件之间传值定义中间实例vm进行传值，逻辑过于复杂 父子组件之间传值子向父传值，通过事件调用机制，父给子传值通过属性绑定，但如果嵌套过深的传值，难免会产生复杂的逻辑 引入vuexvuex相当于是项目共享数据仓库，全局共享数据存储区域，方便各个组件直接拿来使用，这样就少了很多复杂的逻辑 vuex安装和使用 安装 1npm i vuex -S 导入包到文件 1import Vuex from 'vuex' 注册 1Vue.use(Vuex) 实例化，得到一个数据仓储对象 123456789101112var store = new Vuex.store(&#123; state: &#123; // 可以把 state 对比 vue 组件中的 data ，专门用来存储数据 count: 0 &#125;, mutations: &#123; &#125;, getters: &#123; &#125;&#125;) 将 vuex 创建的实例对象挂载到 vm 实例上 12345const vm = new Vue(&#123; ... // store: store store&#125;) 在需要共享数据的组件中想要去访问 vuex 实例中的数据，需要通过this.$store.count来访问 例子项目演示地址https://github.com/ForeManWang/vuex-study 可以先去这里下载项目下来，跟着例子操作 创建基本项目结构和搭建vue环境和配置，不多赘述了 下载下来项目之后，在根目录自行安装所有依赖插件 1npm i state这里就是相当于第六步，去components/amount.vue 去访问 vuex 实例中的数据 这时候打开后台，打开页面刷新，发现就已经能够访问 vuex 中的数据了 moutations 操作数据加法需求 去components/counter.vue的methods中写了一个add方法 1&lt;input type="button" value="增加" @click="add"&gt; 1234567add() &#123; // 千万不要这么用，不符合 vuex 的设计理念 // 这种操作数据的方法相当于是自己的组件操作数据，假如数据紊乱，会不知道是谁操作的数据导致了数据紊乱，所以不利于后期维护 // 所以将需求告诉一个 &lt;库管员&gt; 让 &lt;库管员&gt; 去操作 // 这里就是要 vuex 仓库中的 mutations 提供的方法去操作对应的数据，这样假如维护中出现数据紊乱的情况，可以快速定位错误的原因，利于后期维护 this.$store.state.count++; &#125;, 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit(‘方法名’) 所以在components/counter.vue内部就这样调用 12345add() &#123; // 千万不要这么用，不符合 vuex 的设计理念 // this.$store.state.count++; this.$store.commit("increment");&#125;, 减法需求 去components/counter.vue的methods中写了一个remove方法 1&lt;input type="button" value="减少" @click="remove"&gt; 在main.js的moutations中定义 123subtract(state, obj) &#123; state.count -= (obj.c + obj.d)&#125; 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数； 去components/counter.vue中调用，需要传参 12 这样减法就实现了，实现一次性减obj.c + obj.d getters 包装数据 这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations main.js 12345getters: &#123; optCount: function (state) &#123; return '当前最新的count值是: ' + state.count &#125;&#125; counter.vue 123456computed:&#123; fullname: &#123; get()&#123;&#125;, set()&#123;&#125; &#125;&#125; 经过回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者；其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值 总结 state中的数据，不能直接修改，如果想要修改，必须通过mutations 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.*** 如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit(&#39;方法的名称&#39;， 唯一的一个参数) 如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用getters, 如果需要使用 getters ,则用this.$store.getters.***]]></content>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-读取文件方法封装]]></title>
    <url>%2Fnode-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[node读取文件方法封装&amp;Promise 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 准备 一个空js文件和files文件里面放上三个文件，方便下面操作 载入核心模块 12const fs = require('fs')const path = require('path') 需求：封装一个方法，给你一个要读取文件的路径，你这个方法能帮我读取文件，并把内容返回给我 普通方式12345// 这是普通读取文件的方式 fs.readFile(path.join(__dirname, './files/1.txt'), 'utf-8', (err, dataStr) =&gt; &#123; if (err) throw err console.log(dataStr)&#125;) 但是这样达不到需求，所以就有了下面一种方式 简单封装一由于读取文件是异步操作，不能直接在函数内部return,所以没有接收到返回值，在外部调用就是undefined 所以用callback接收一下 简单封装二封装一个给定文件路径，返回读取到的内容的读取文件的异步方法 12345678910function getFileByPath (fpath, callback) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) throw err // console.log(data) callback(data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), (data) =&gt; &#123; console.log(data) // 111&#125;) 这样基本就达到需求了，但是依然不能知道读取文件数据到底成功还是失败，没有明确的标识 简单封装三所以可以给 callback 规定两个参数，一个失败结果，一个成功结果 同时我们规定，如果成功后，返回结果应该位于 callback 结果的第二个位置，此时第一个结果由于没有出错，所以放一个 null ，如果失败了，则第一个结果放置 error 对象，第二个位置放置一个 undefined 123456789101112function getFileByPath (fpath, callback) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) throw err // console.log(data) callback(null, data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), (err, data) =&gt; &#123; // console.log(data) // 111 if (err) return console.log(err.message) console.log(data)&#125;) 这种情况下，不管成功还是失败，共用的是一个参数（不是很好理解），可以拆分为两个，成功一个回调，失败一个回调，这样更好理解 简单封装四1234567891011function getFileByPath (fpath, succCb, errCb) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) errCb(err) succCb(data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), function (data) &#123; console.log(data + '成功了')&#125;, function (err) &#123; console.log(err.message + '失败了')&#125;) 这样就基本封装完成，达到需求，并提示失败和成功，提升体验 Promise解决回调地狱假如我们使用上一种封装方法，去按顺序读取三个文件files/1.txt、files/2.txt、files/3.txt这样就需要嵌套 1234567891011getFileByPath(path.join(__dirname, './files/1.txt'), function (data) &#123; console.log(data) getFileByPath(path.join(__dirname, './files/2.txt'), function (data) &#123; console.log(data) getFileByPath(path.join(__dirname, './files/3.txt'), function (data) &#123; console.log(data) &#125;) &#125;)&#125;) 假如以上的嵌套有很多，还不止这样三个嵌套呢？就会成这样 这样就形成了回调地狱，由于函数查找变量的规则需要由内至外一层一层去查找，这样难免造成大量的资源浪费 引入Promise来解决回调地狱的问题 Promise介绍Promise是ES6中的一个对象，用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。 在浏览器控制台输入console.dir(Promise)可以看到 我们看图片中两个红框，第一个红框，Promise是一个构造函数 第二个红框是两个回调函数，reject()表示失败执行，resolve()表示成功后执行 点开prototype:Promise发现一个then方法和catch()方法，而then和catch方法和在Promise的原型对象中，所以可以用promise直接调用 Promise解决回调地狱这样就可以封装一个基于Promise读取文件的函数 12345678910const fs = require('fs')function getFileByPath(fpath) &#123; return new Promise (function (resolve, reject) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) return reject(err) resolve(data) &#125;) &#125;)&#125; 12345678910111213141516171819202122// 如果 ，前面的 Promise 执行失败，我们不想让后续的Promise 操作被终止，可以为 每个 promise 指定 失败的回调 getFileByPath('./files/11.txt') .then(function (data) &#123; console.log(data) // 读取文件2 return getFileByPath('./files/2.txt') &#125;, function (err) &#123; console.log('这是失败的结果：' + err.message) // return 一个 新的 Promise return getFileByPath('./files/2.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;).then(function (data) &#123; console.log(data) &#125;) 当 我们有这样的需求： 哪怕前面的 Promise 执行失败了，但是，不要影响后续 promise 的正常执行，此时，我们可以单独为 每个 promise，通过 .then 指定一下失败的回调； 有时候，我们有这样的需求，个上面的需求刚好相反：如果 后续的Promise 执行，依赖于 前面 Promise 执行的结果，如果前面的失败了，则后面的就没有继续执行下去的意义了，此时，我们想要实现，一旦有报错，则立即终止所有 Promise的执行。 1234567891011121314151617getFileByPath('./files/1.txt') .then(function (data) &#123; console.log(data) return getFileByPath('./files/22.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;) .catch(function (err) &#123; // catch 的作用： 如果前面有任何的 Promise 执行失败，则立即终止所有 promise 的执行，并 马上进入 catch 去处理 Promise中 抛出的异常； console.log('这是自己的处理方式：' + err.message) &#125;)]]></content>
      <tags>
        <tag>函数封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime添加自定义代码段]]></title>
    <url>%2Fsublime%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[sublime添加自定义代码段 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 一：打来Sublime Text，在菜单栏找到“Tools（工具）”-&gt;”New Snippet（新代码段）” 二：Hello, ${1:this} is a ${2:snippet}.这块代码区域，可以直接删除，然后添加上你所需要的代码段进去，然后Ctrl + s保存，保存到默认文件夹，命名随意，假如你的命名是vuecode，那么你去书写你的代码时就需要通过vuecode来调用这个代码段 三：调用过程： Ctrl + Shift + P ======&gt; Snippet:vuecode =====&gt; enter 这时候代码段就自动添加到你需要的地方了]]></content>
      <tags>
        <tag>sublime添加自定义代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime安装插件&常用的sublime插件]]></title>
    <url>%2Fsublime%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[sublime安装插件&amp;常用的sublime插件 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 其实sublime安装插件并不难，几步操作就好了，关键插件安装过程中总出现各种各样的错误，而且比较好的插件都有哪些呢？ 安装步骤 第一步：下载一个sublime，正版不正版，汉化不汉化的那就按照你个人要求制定就行，网上也有相应教程，我用的是官网的，然后加的汉化包 sublime官网 第二步：打开你的sublime , Ctrl + ` 切换到sublime控制台，控制台一共两块内容区域，第一块区域时监控代码运行进程的，不用管，当然出错也可以从这里查找，第二块区域根据你自己的是sublime2还是sublime3来选择代码复制粘贴进去并运行 sublime3 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) sublime2 1import urllib2,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 第三步：安装完成后，按 Ctrl+Shift+p (Windows)/ Command+Shift+p (Mac), 输入Install Packages，之后Sublime会自动下载插件列表，然后弹出一个小的下拉菜单让你填写想要下载的插件名称。 常见错误这里是我遇到过的一些问题：欢迎大佬们补充 直接无法安装插件网上看了一些文档，说是GWF被墙问题 错误提示如下： 解决办法： 1、开代理自己翻墙 2、直接下载插件，将下载的文件解压到Sublime Text3的Installed Packages目录下 解析错误还有个问题是包解析错误，需要自己去发现错误翻译下看看是不是这一类问题，我忘记错误代码了，这一类问题可能是网络原因，我换了个网，能用了 常用插件推荐下面推荐我安装的一些插件，主要参照了博客sublime常用插件 本文参考博客Package Control]]></content>
      <tags>
        <tag>sublime安装插件&amp;常用的sublime插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Babel转码]]></title>
    <url>%2FES6-Babel%E8%BD%AC%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ES6-Babel转码 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ ES6的笔记参考ECMAScript 6 入门 部署进度 这里使用阮一峰老师写的一个工具 ES-Checker用来检查各种运行环境对 ES6 的支持情况。访问ruanyf.github.io/es-checker，可以看到您的浏览器支持 ES6 的程度。运行下面的命令，可以查看你正在使用的 Node 环境对 ES6 的支持程度 1234567$ npm install -g es-checker$ es-checker// 结果=========================================Passes 39 feature DetectionsYour runtime supports 92% of ECMAScript 6========================================= Babel转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 例子： 1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 Babel的配置文件.babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 1234567891011# 最新转码规则$ npm install --save-dev babel-preset-latest# react 转码规则$ npm install --save-dev babel-preset-react# 不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 然后，将这些规则加入.babelrc。 12345678&#123; &quot;presets&quot;: [ &quot;latest&quot;, &quot;react&quot;, &quot;stage-2&quot; ], &quot;plugins&quot;: []&#125; 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 本来这里想详细总结下各种转码，然后发现阮一峰老师写的是真的详细，请参见ECMAScript 6 入门]]></content>
      <tags>
        <tag>ES6-Babel转码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基本属性配置]]></title>
    <url>%2Fwebpack%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack 基本属性配置 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 1234567891011121314151617181920212223242526272829303132333435363738394041const path = require('path')module.exports = &#123; entry: &#123; // main是默认入口，也可以是多入口 main: './src/main.js' &#125;, // 出口 output: &#123; filename: './build.js', // 指定js路径 path: path.join(__dirname, '..', '', 'dist') // 最好是绝对路径 // 代表上一级的dist &#125;, module: &#123; // 一样的功能rules: webpack2.xx新加的 loaders: [ // require('./a.css||./a.js') &#123; test: /\.css$/, loader: 'style-loader!css=loader', //多个loader用!分割 //顺序是反过来的 2!1 多个loader &#125;, &#123; test: /\.(jpg|svg)$/, loaderL 'url-loader?limit=4096&amp;name=[name].[ext]', // limit=4096&amp;name=[name].[ext]' 多个参数之间用&amp;符号分割 //[name].[ext]内置提供的 options: &#123; limit: 4096, name: '[name].[ext]' &#125; &#125; ] &#125;, plugins: [ // 插件的执行顺序是依次执行的，和loader是反过来的 new htmlWebpackPlugin(&#123; template: './src/index.html', &#125;) // 将src下的template属性描述的文件根据当前配置的output.path，将文件移动到该目录。 // 在插件的执行过程中，它本身可以去拿当前所设置的webpack选项，便于对webpack选项的复用， ]&#125;]]></content>
      <tags>
        <tag>webpack配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 中全局变量与形参的赋值]]></title>
    <url>%2Fjavascript-%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BD%A2%E5%8F%82%E7%9A%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[javascript 中全局变量与形参的赋值 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 现象定义数组 12345678var arr1,arr2,arr3;var arr4 = [ &#123;name:'zhangsan',age:'18'&#125;, &#123;name:'lisi',age:'18'&#125;, &#123;name:'wangwu',age:'18'&#125;, &#123;name:'zhaoliu',age:'18'&#125;, &#123;name:'xiaoming',age:'18'&#125;]; 创建一个change函数 123456function change(params)&#123; for(var i = 0; i&lt;params.length;i++)&#123; params[i].name = params[i].name +'miaomiaomiao' &#125; return params &#125; 将arr4赋值给arr1、arr2、arr3并打印，观察打印结果 12345678arr1 = arr4arr2 = arr4arr3 = arr4console.log(change(arr1)) // 对任意一个数组执行change函数console.log(arr4)console.log(arr1)console.log(arr2)console.log(arr3) 以下是打印结果 可以发现，当其中任何一个数组改变时，其他的数组的值也会跟着改变 原因在计算机的内存中，系统对变量的声明在栈中，而值是在堆中 画图理解 arr1 = arr4; arr2 = arr4; arr3 = arr4 的赋值只是将arr4的值的地址指向了arr1，arr2，arr3；内存中并没有为其创建内容空间，这样就导致直接或间接的修改变量的值，那么原始值都将被修改。]]></content>
      <tags>
        <tag>全局变量与形参的赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 中局部变量和形参同名冲突问题]]></title>
    <url>%2Fjavascript-%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%BD%A2%E5%8F%82%E5%90%8C%E5%90%8D%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[javascript 中局部变量和形参同名冲突问题 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 新建一个数组 1234567var arr = [ &#123;name:'zhangsan',age:'18'&#125;, &#123;name:'lisi',age:'18'&#125;, &#123;name:'wangwu',age:'18'&#125;, &#123;name:'zhaoliu',age:'18'&#125;, &#123;name:'xiaoming',age:'18'&#125;] 局部变量和形参冲突的情况 12345678910function getList(i)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr[i].name == 'e')&#123; console.log('已遍历完整个数组') &#125; &#125; return arr[i]&#125;console.log(getList(1)) // undefined// 调用 getList(1)时，其结果并不是 &#123;tel:1234658,name:'b'&#125; , 而是 undefined 解决方法 将形参改变或者将循环体内变量改变一下 12345678910function getList(i) &#123; for(var j = 0; j &lt; arr.length; j++)&#123; if(arr[j].name == 'e')&#123; console.log('已遍历完整个数组') &#125; &#125; return arr[i]&#125;// console.log(getList(1)) // &#123; tel: 1234658, name: 'b' &#125;// 更改 循环体中 i 变量 为 j 结果就是想要的结果了]]></content>
      <tags>
        <tag>局部变量和形参同名冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将本地文件上传到github]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[将本地文件上传到github 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 文件上传 桌面打开git命令面板 新建Git仓库 1git init 添加文件到git 12git add . // 或者下面一种git add README.md 添加此次更新内容描述 12 将本地仓库关联到github上 1git remote add origin git@github.com:ForeManWang/letao.git // 最后面的地址需要填写你自己github的项目地址 将代码上传到github 1git push -u origin master 常见错误执行代码git remote add origin git@github.com:ForeManWang/letao.git时出现错误：fatal: remote origin already exists 解决办法 执行命令 12git remote rm origingit remote add origin git@github.com:ForeManWang/letao.git 这样就解决了，后面再上传项目到github 1git push -u origin master]]></content>
      <tags>
        <tag>本地文件上传到github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之seo优化]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8Bseo%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HEXO SEO 优化 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 最近用hexo搭建个人博客，但是去网上搜，搜什么都搜不到自己，这就很尴尬了，于是想到了seo优化，这里主要对google和baidu爬虫的优化 什么是 SEO SEO（Search Engine Optimization）:汉译为搜索引擎优化。是一种方式:利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是：为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力 =&gt;百度百科 建议: 最好一步一测，反正我遇到的坑无数个，由于之前没有一步一测，导致到后来错到哪都不知道，或者开启hexo debug服务命令，这样在本地站点根目会生成一个debug.log文件，就是你的错误日志，可以去查看，具体指令如下： 到站点目录下，开启git命令面板 1hexo s --debug 本地文章优化添加sitemap首先给你的文章生成sitemap文件 123npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎12 然后在站点配置文件_config.yml中添加以下代码(这里我在参考资料《HEXO SEO 高级优化》这篇博客中看到的配置，但是在我的配置里一应用就报错，所以我的没用到，我给注释起来了，具体配置和报错信息如下：) 1234567891011# 自动生成sitemap# sitemap:# path: sitemap.xml# baidusitemap:# path: baidusitemap.xml# 报错信息# =&gt; Error：FATAL duplicated mapping key at line 153, column 1:# ??path: baidusitemap.xml# ^# YAMLException: duplicated mapping key at line 153, column 1:# ??path: baidusitemap.xml 最后修改站点配置文件_config.yml 123456# URL 配置站点## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://qqqww.com # 这里应该更改为你自己的站点地址，我写的是我的root: /permalink: :title/ # 这里简化目录结构，后面也会讲到permalink_defaults: 每次hexo g后都会在/public目录下生成sitemap.xml和baidusitemap.xml，这就是你的站点地图，这里需要将站点地图提交到百度站长之家 添加 roborts.txt文件添加 roborts.txt文件到站点根目录source文件夹下 这里可以参照我的： 12345678910111213141516User-agent: *Allow: /Allow: /archives/Allow: /tags/Allow: /categories/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://qqqww.com/sitemap.xmlSitemap: http://qqqww.com/baidusitemap.xml 百度收录站点登录百度站长平台，在用户中心 =&gt; 站点管理添加你的站点网址 配置完站点属性后，进入最后一步：验证网站。有三种方式：文件验证、HTML标签验证、CNAME验证，文件验证和CNAME验证都比较简单，也有相对应的帮助文本，在此我选择的是HTML标签验证。 在主题的_config.yml文件中，设置：baidu_site_verification: true，如果没有该字段就手动添加。 在themes/next/layout/_partials/head.swig文件中添加下列代码 12345// 每个人的content值都不一致，请注意更换成你的content值&#123;% if theme.baidu_site_verification %&#125; &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;6K5YmdKWEx&quot; /&gt;&#123;% endif %&#125; 配置好后，重新发布站点，在百度站长页面完成验证。 百度链接提交 链接提交工具是网站主动向百度搜索推送数据的工具，本工具可缩短爬虫发现网站链接时间，网站时效性内容建议使用链接提交工具，实时向搜索推送数据。本工具可加快爬虫抓取速度，无法解决网站内容是否收录问题 主动推送 最为快速的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。 安装百度链接提交插件 1npm install hexo-baidu-url-submit --save 123456# 百度链接自动提交baidu_url_submit: count: 6 # 提交最新的链接数量 host: http://lianghuii.com # 在百度站长平台中注册的域名 token: # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 设置deploye 123456deploy: - type: git repo: github: git@github.com:MeanMouse/MeanMouse.github.io.git coding: git@git.coding.net:MeanMouse/blog.git - type: baidu_url_submitter 自动推送 是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。。 在主题配置文件将baidu_push设置为true 在路径themes\next\layout_scripts\下创建baidu_push.swig 文件，文件内容如下 12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) &#123; bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; &#125; else &#123; bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125; sitemap这里将之前生成的sitemap文件提交到百度站长 手动提交 如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度。 手动提交方式比较简单，按照官方提示就会使用 - -(这种方式确实好用，方便) 谷歌收录站点进行这个之前，首先友情提示下大佬们，最好开个vpn用，因为很多涉及谷歌服务，我这里用的是789vpn，网上有很多，可以去找，lantern也能用 打开 Google Search Console，添加博客地址。并进行相关验证,根据提示即可完成认证,认证成功如下： 认证方法其实这里方法和百度的类似，也有三种，我用的是直接下载文件，放到我的站点source目录下，然后我在git命令面板里输入以下指令（下面将这一套指令简称为更新并同步文件指令） 123hexo cleanhexo ghexo d 之后，我去google认证，发现并不能验证成功，后来去站点配置_config.yml下添加了一句代码，和百度的类似 1google-site-verification: true 这样就验证成功了，再去看看，验证成功吧的界面如下（这里用的是参考文档里验证成功的图片，其实都一样，下面发参考文档链接） 验证通过后点进入控制台测试robots.txt文件,没有错误和警告即可 提交 sitemap.xml 文件，点击右上角添加/测试站点地图输入 sitemap.xml 进行测试，测试无误后再提交文件 robots.txt验证和sitemap.xml验证通过，抓取网页，我这里给sitemap.xml和baidusitemap.xml都加进去了，虽然不知道是不是提交一个就可以了….. 输入框留空表示抓取首页，填入 about 表示抓取关于页面，抓取完成后,抓取因为验证原因,可能会有几种状态：完成、部分完成和已重定向等，直接提交就可以。 验证站点是否被收录 谷歌中输入：site:yousite，会有提示：(抓取需要时间。等几分钟) 以上就完成了百度和谷歌的搜索引擎抓取站点的功能 优化结构seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下： 123456# URL 配置站点## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://qqqww.comroot: /permalink: :title/permalink_defaults: 首页标题优化SEO最重要的是你的标题，一般搜索都是搜索你的标题。 更改index.swig文件(your-hexo-site\themes\next\layout); 将下面这段代码： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 这时候你的首页会更符合网站名称 - 网站描述这习惯。 进阶，做了seo优化，把关键词也显示在title标题里，可改成： 1&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125;&#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 注意：别堆砌关键字，整个标题一般不超过80个字符，可以通过chinaz的seo综合查询检查。 关键词与描述搜索引擎除了主要抓取标题外，页面的关键词和描述也会抓取。 在\scaffolds\post.md中添加如下代码，用于生成的文章中添加关键字和描述。 12keywords: description: 在\themes\next\layout_partials\head.swig有如下代码，用于生成文章的keywords。暂时还没找到生成description的位置。 1234567&#123;% if page.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; page.keywords &#125;&#125;&quot; /&gt;&#123;% elif page.tags and page.tags.length %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;&quot; /&gt;&#123;% elif theme.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; theme.keywords &#125;&#125;&quot; /&gt;&#123;% endif %&#125; 然后在\themes\next\layout_macro\post.swig中找到这个位置： 1&#123;% if post.description %&#125; 将以下代码去掉： 1234567&#123;% if post.description %&#125; &#123;&#123; post.description &#125;&#125; &lt;div class=&quot;post-more-link text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; 否则首页的文章摘要就会变成文章的description。 举个例子： 123456789101112---title: HEXO SEO优化方法总结copyright: truetop: 0date: 2018-07-19 21:17:42tags: SEOcategories: Debianpermalink:password:keywords: [HEXO,HEXO SEO优化]description: 总结一下使用Hexo搭建博客后，SEO优化方案的总结，后期会不定期更新。--- nofollow 标签给非友情链接的出站链接添加 “nofollow” 标签，nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 以hexo的NexT主题为例，需要修改两处 一：找到footer.swig，路径在your-hexo-site\themes\next\layout_partials，将下面代码 改成： 将下面代码： 1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; 改成： 1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt; 二：修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout_macro，将下面代码 1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 改成： 1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 将下面代码： 1&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt; 改成： 1&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt; 安装nofollow插件 减少出站链接能够有效防止权重分散，hexo有很方便的自动为出站链接添加nofollow的插件。 1npm install hexo-autonofollow --save 该插件会将博客中的出站链接自动加上nofollow属性，例外请在站点配置文件_config.xml中添加如下字段 1234nofollow: enable: true exclude: - https://qqqww.com // 友链地址 这样，例外的链接将不会被加上nofollow属性。 开启SEO优化选项hexo博客next提供了seo优化选项，在主题配置文件_config.yml中有个选项是seo，默认是false，改成true即开启了seo优化，会进行一些seo优化，如改变博文title等，然后相同文件下有个关键字选项keywords，填充上，写博文时最好每篇博文都加上keywords。 我用的是next的主题，把该主题的_config.yml的默认keyword改成你的网址关键词 12# Set default keywords (Use a comma to separate)keywords: &quot;wanggongtou&quot; 开启压缩文件因为hexo生成的文件是静态html，里面占用了大量的空白符。使用gulp进行压缩接口提高访问速度并且降低内存。 使用命令 1234npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --savenpm install gulp-concatnpm install gulp-imagemin 在hexo blog文件夹下创建gulpfile.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var gulp = require(&apos;gulp&apos;), uglify = require(&apos;gulp-uglify&apos;), cssmin = require(&apos;gulp-minify-css&apos;), imagemin = require(&apos;gulp-imagemin&apos;), htmlmin = require(&apos;gulp-htmlmin&apos;), htmlclean = require(&apos;gulp-htmlclean&apos;); concat = require(&apos;gulp-concat&apos;);//JS压缩gulp.task(&apos;uglify&apos;, function() &#123; return gulp.src([&apos;./public/js/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;])//只是排除min.js文件还是不严谨，一般不会有问题，根据自己博客的修改我的修改为return gulp.src([&apos;./public/**/*.js&apos;,&apos;!./public/zuoxi/**/*.js&apos;,,&apos;!./public/radio/**/*.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public/js&apos;));//对应修改为./public即可&#125;);//public-fancybox-js压缩gulp.task(&apos;fancybox:js&apos;, function() &#123; return gulp.src(&apos;./public/vendors/fancybox/source/jquery.fancybox.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public/vendors/fancybox/source/&apos;));&#125;);// 合并 JSgulp.task(&apos;jsall&apos;, function () &#123; return gulp.src(&apos;./public/**/*.js&apos;) // 压缩后重命名 .pipe(concat(&apos;app.js&apos;)) .pipe(gulp.dest(&apos;./public&apos;));&#125;);//public-fancybox-css压缩gulp.task(&apos;fancybox:css&apos;, function() &#123; return gulp.src(&apos;./public/vendors/fancybox/source/jquery.fancybox.css&apos;) .pipe(cssmin()) .pipe(gulp.dest(&apos;./public/vendors/fancybox/source/&apos;));&#125;);//CSS压缩gulp.task(&apos;cssmin&apos;, function() &#123; return gulp.src([&apos;./public/css/main.css&apos;,&apos;!./public/css/*min.css&apos;]) .pipe(cssmin()) .pipe(gulp.dest(&apos;./public/css/&apos;));&#125;);//图片压缩gulp.task(&apos;images&apos;, function() &#123; gulp.src(&apos;./public/uploads/*.*&apos;) .pipe(imagemin(&#123; progressive: false &#125;)) .pipe(gulp.dest(&apos;./public/uploads/&apos;));&#125;);// 压缩 public 目录 html文件 public/**/*.hmtl 表示public下所有文件夹中html，包括当前目录 gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;)) &#125;);gulp.task(&apos;build&apos;, [&apos;uglify&apos;, &apos;cssmin&apos;, &apos;fancybox:js&apos;, &apos;fancybox:css&apos;, &apos;jsall&apos;,&apos;images&apos;]);//, &apos;minify-html&apos; 在根目录下的package.json文件中生成写入scripts: 1&quot;scripts&quot;: &#123;&quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp build&quot;&#125; 这样每次输入npm run build就会自动清理上次生成的文件，然后生成新的文件，最后压缩文件。 站内优化这里就真正的涉及到SEO的相关知识了，对你的文章的结构，描述，关键词进行优化。 title优化搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。 1用法：&lt;title&gt;网站标题&lt;/title&gt; 注意点： 首页title写法：首页的title写法格式一般是“总标题-特别重要的关键词或者一句话含有特别重要关键词的描述”。注意这里的“-”是英文，要问我为什么呢?这个因为互联网不是我们国内开发的，汉语不是标准，计算机只对英语敏感性较高，而对汉语敏感性不太高。 栏目页title写法：栏目页title的写法有两种，关键词名称命名写法是“栏目名称-总名称”，非关键词命名写法是：“栏目名称 栏目关键词-总名称”。 分类列表页的title写法：用关键词为这个栏目起名，然后按照下列顺序填写便可了“分类列表页名称-栏目名称-总名称”。 注意事项： 每个标题应该是根据当前内容设置的独特不重复的。 字数限制。不能太长，要不然搜索引擎结果列表会显示不全。最好不超过 25 个中文字。最好是在 10~20 之间。 切勿堆砌关键词。这是很多人常犯的错误 关键词最好出现在最前面 标题有吸引力。毕竟有吸引力的标题才能让用户点击 连词符的使用。可以使用 |-&gt; 不要使用没有意义的句子 keywords优化主要作用是告诉搜索引擎，这个网站内容是什么。因为，好多站长在keywords堆砌关键词，所以好多搜索引擎不太重视keywords了。建议大家还是认真填写keywords，有的搜索引擎还是很重视的，由于现在词频和密度对于 SEO 影响不大，所以只要保持你的正文中出现 4~6 次关键词就可以了。千万不能堆砌关键词。 注意点： 首页keywords写法：首页keywords按照选定的栏目名称，在首页的keywords中加入总名称、栏目名称和一两个关键词。 栏目keywords写法：栏目的keywords其栏目下所有分类列表的名称列出，加上栏目关键字，写法是“栏目名称,栏目关键字,栏目分类列表名称” 分类列表页keywords写法：将你这个栏目中的主要关键字写入。 Description优化功能让搜索引擎是判断整个页面内容的，当中要写入的内容是你页面内容的简介。description一般不超过100个字符。对于个人站点而言，描述标签最好是一句通顺的句子，如果不能的话，则宁可不要。 注意点： 首页description写法：description的写法就是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍形式，不要只写关键词。 栏目description写法：将栏目的标题、关键字、分类列表名称，尽量的写入description中，仍是尽量写成介绍形式。 分类description写法：是将你这个栏目中的主要关键字写入。 H标签优化H 标签的重要性可能是仅次与页面标签。H1-&gt;H6 的重要性依次降低。 所以建议在页面的 H1 和 H2 标签中混入关键词 图片 ALT 文字优化插入图片的时候会提示输入文字，这个不能敷衍。图片 ALT 文字出现的关键词对页面相关性也有一定的影响。同样的，也不要在 ALT 上堆砌关键词。 内部链接及锚文字优化内部链接对于爬行和收录具有很重要的意义。内部链接对页面关键词相关性也有影响，最主要的就是在内部链接中使用锚文字。 锚文字是告诉搜索引擎被链接页面主题内容的最重要依据之一。我们有时候可能无法控制外部链接的锚文字，但是对于站内的内部链接锚文字我们可以控制。不过有几点需要注意： 适当出现匹配关键词的锚文字 锚文字不能集中导航或者页尾，要分散在正文中 本文参考文档以下三篇 HEXO SEO 高级优化 Hexo Seo优化让你的博客在google搜索排名第一 Hexo SEO设置]]></content>
      <tags>
        <tag>hexo seo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Git安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BGit%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[windows 环境下 Git 安装 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 一、安装：官网下载对应 exe 文件直接安装 我电脑是win10 64位的，这里讲的是在windows下安装的Git 下载地址 下载之后，一直next就可以了 二、配置：配置环境变量 win + r 打开windows运行面板 输入 sysdm.cpl 打开系统属性面板 选择系统属性面板上的高级 选择环境变量 双击path,添加一条你安装git的路径即可，我这里是E:\Develop\Git\Git\cmd 三、检测是否安装成功 到任意位置下，鼠标右键出现Git Bash Here和Git GUI Here即视为成功 四、整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>Git安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装逼路上的小插曲一：博客上传图片无法显示]]></title>
    <url>%2F%E8%A3%85%E9%80%BC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%B0%8F%E6%8F%92%E6%9B%B2%E4%B8%80%EF%BC%9A%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[博客上传图片无法显示 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 有些日子，不知不觉就过去了…… 有些坑，不知不觉就进了，我也很无奈啊 废话不说了，这里参照了————大佬的文档 简单总结下： 站点下配置文件_config.yml修改，找到post_asset_folder(如果没有，自己写一个)，默认值一般是false，修改为true。 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 1npm install https://github.com/CodeFalling/hexo-asset-image --save 安装后再站点根目录下执行命令hexo new &quot;我的测试博客&quot;，在hexo/source/_post文件夹下不仅会生成对应的.md文件，还有一个同名的文件夹，用于存放该文件相关的资源。 1npm new "我的测试博客" 这个时候在写.md文档的时候，只需要图片链接为我的测试博客/[图片名].png即可 这里是利用相对路径解决了这一问题，详细请参照大佬的博客 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>博客上传图片无法显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Github账号注册]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BGithub%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[GitHub账号注册 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 注册流程点击进入Github官网 注册之后，登录，创建一个测试项目可以点击右上角红框位置 点击Create repository之后就可以创建一个测试项目了 新建一个分支 分支是用来同时处理存储库不同版本的方法；默认情况下你的存储库会有一个分支master作为主分支 。 输入分支名称，enter即可 在分支上可以进行修改和提交，具体还可以使用Git指令进行项目的下载，修改和上传，如果没有Git的，请参照我同一个系列的另一篇文章，点击hexo搭建个人博客之Git安装 Git的一些指令 本地任意位置打开Git面板 1234Git init // 初始化一个Git仓库，后面可以跟仓库名Git pull git@github.com:ForeManWang/test.git // 上传文件到项目地址，指令后面跟的是项目地址，具体查看方法，下面有Git clone git@github.com:ForeManWang/test.git // 下载文件到本地，指令后面跟的是项目地址，具体查看方法，下面有...... Github项目地址：见下图 github上的概念说明仓库(Repository) 假如想在Github上面开源一个项目,那就必须的创建一个Repostitory,如果你开源的项目多了,就拥有了多个Repostitory 收藏(star) 右上角star数量，收藏该项目的人数 复制克隆项目(Fork) 将别人的开源项目复制一份到自己的仓库中(本质是在原有项目基础上打了一个分支)，可在复制的仓库中进行修改，修改成自己想要的样子 发起请求(Pull Request) 发起请求,这个是基于Fork的,相当于在Fork了别人的项目之后,自己做了一些修改,想要分享给更多的人,这个时候可以把代码提交(Pull Request)给原有的项目,若原有项目经过测试或者review代码确认后,原有项目就可拥有这些新的代码了. 关注(Watch) 关注，当关注了某个仓库，仓库发生变化，就会在邮箱等收到通知 事物卡片(issue) 发现bug，讨论时使用 Github主页 帐号创建成功或者点击点击导航栏图标可进入主页,该页面主要展示用户的动态以及关注的仓库的动态,右侧展示所有的git仓库. 仓库主页 仓库主页主要显示项目的信息,如:项目代码,版本,收藏/关注/fork等等各种情况. 个人主页 个人信息,头像,关注我的人,我关注的人,我关注的仓库,我的开源仓库. 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示 本文参考： （https://blog.csdn.net/lezaimemecha/article/details/84969353）]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Hexo安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[hexo搭建个人博客之Hexo安装 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 什么是hexo一个快速高效的博客框架 安装hexo安装hexo之前，先确认自己必须已经安装了NodeJs和Git和已经拥有了GitHub账号，可以参照以下三篇文章 Git详细安装教程————点击此处 GitHub账号注册详细教程————点击此处 NodeJs详细安装过程和环境配置————点击此处 如果以上步骤已经全部完成，去任意一个位置，右键打开Git面板，输入以下指令 1npm install -g hexo-cli 等待一会，安装之后，继续输入指令 1hexo -v // 有版本号则成功 成功安装之后，就可以创建一个博客了，详细请见hexo搭建个人博客总流程 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>hexo安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之NodeJs安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BNodeJs%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[NodeJs 安装与环境配置 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 安装这里只介绍windows环境下的NodeJs安装 这里是官网请点击 图片中左边稳定版，右边最新版 点击，下载，是一个msi文件，直接安装就可以，记住你的安装路径，后面做环境配置 安装之后就可以做配置了 配置不知道怎么做环境配置的点击这里查看,同样的道理 测试打开命令行面板，输入以下指令 1node -v npmnpm即包管理工具，一般安装完NodeJs之后，npm是附带安装上去的，所以，同样的执行命令行命令 1npm --version nvmnvm即版本管理工具，详细参考点击这里 整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>NodeJs安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客详细教程]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hexo个人博客 欢迎访问我的博客，祝码农同胞们早日走上人生巅峰，迎娶白富美~~~ 一 Git 安装及GitHub账号注册Git详细安装教程————点击此处 GitHub账号注册详细教程————点击此处 二 NodeJS 安装NodeJs详细安装过程和环境配置————点击此处 三 Hexo 安装Hexo基本框架搭建过程————点击此处 四 基本主题next开启GitPages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 登录Github，右上角创建一个项目，也可以参照我的另外一个同系列的文章 hexo搭建个人博客之Github账号注册 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。 点击Create Repository之后，选择settings 进入如下： 找到GitHub Pages找到choose theme 之后进入主题仓库,任意选择一个主题，这里我选择的是这个 此时再去查看settings,会发现GitHub Pages变化如下 现在，我们就可以使用https://UserName.github.io，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)： 备注：由于我的有一个服务已经在开着了，电脑太卡了，这里借用参考文档的图片 创建一个本地博客站点打开windows命令面板，输入以下指令 1hexo init myBlog 测试本地博客12hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 此时打开浏览器，输入 http://localhost:4000/，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)： 同步GitHub，允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地站点的配置_config.yml文件，修改deploy下的配置如下： 1234deploy: type: git // 类型为 git repository: git@github.com:ForeManWang/ForeManWang.github.io.git // 这里写仓库地址 branch: master 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 下载主题-Next(官网)安装Git部署插件12345npm install hexo-deployer-git --save // 有版本号即成功// 部署指令hexo clean // 每次同步之前操作，清理缓存hexo g //将md文档生成博客hexo d //同步到github 下载Next,参考安装包，或直接克隆1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在 Hexo 中有2份主要的配置文件，其名称都是_config.yml。一份是站点配置文件，在站点根目录下另一份是主题配置文件，在主题目录下，比如我们这里用到的是next主题，则在myHexoBlog\themes\next下 打开themes/next/下的_config.yml,查找scheme，可以看到四种不同的风格。去掉#注释，即启用对应的scheme，博主采用Gemini主题，大家可以依次测试效果，选择自己喜欢的scheme。打开根目录下的_config.yml，查找theme字段，将字段改为theme: next(冒号:之后要有空格分隔，否则无效) 之后通过hexo g和hexo s，再在浏览器中访问localhost:4000即可本地预览主题效果。 主题基础配置设置过程中，可运行在本地查看，步骤跟之前一样(注意所有的：后面都要空一格!!!)。 设置菜单找到主题next的_config.yml查找menu`，去掉#注释即可显示对应的菜单项。 设置网站基本信息和语言找到站点的_config.yml，找到Site如下设置。 设置个人信息找到主题next的_config.yml，找到social如下设置。 设置头像进入themes/next/source/uploads下，找到avatar.png，放入一张同样大小的图片替换名字。之后找到主题next的_config.yml，找到avatar如下设置。 更多美化next主题参考请点击next美化主题1-4 hexo seo优化整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示 本文参考文档Hexo搭建个人博客（一）——框架搭建 Hexo搭建个人博客网站详细流程 Hexo博客搭建]]></content>
      <tags>
        <tag>hexo搭建个人博客</tag>
      </tags>
  </entry>
</search>
