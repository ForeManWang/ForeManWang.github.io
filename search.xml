<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactNative组件]]></title>
    <url>%2FReactNative%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[#ReactNative组件 该文档要配合项目文档地址ReactNative豆瓣电影看会更好 这里只写我在进行ReactNative豆瓣电影项目的时候去ReactNative官网研究过的组件 Platform: 用来提供平台检测功能的 StyleSheet: 样式相关的组件，专门用来创建样式的 Text: 文本节点，所有文本必须放到这个里面 View: 用来布局的，相当于 div TextInput: 文本框组件 Image: 图片组件 Button: 按钮组件 ActivityIndicator: 加载中的 loading 效果小圆圈 ScrollView: 滚动组件（默认，如果一个RN的页面非常长，超出了屏幕高度，这时候，不会像网页中那样自动提 供滚动条，如果需要让页面实现滚动的话，需要使用 ScrollView 把页面包裹起来） 基本都是导入组件，然后在首页中用render()渲染就可以了，真是超级无敌爆炸爽 1234// 导入 React 基础包，这个包，作用是创建 组件import React, &#123; Component &#125; from 'react'// 从 react-native 中导入系统开发需要的包import &#123;Platform, StyleSheet, Text, View ...&#125; from 'react-native' ##Platform 用来提供平台检测功能 123456const instructions = Platform.select(&#123; ios: 'Press Cmd+R to reload,\n' + 'Cmd+D or shake for dev menu', android: 'Double tap R on your keyboard to reload,\n' + 'Shake or press menu button for dev menu',&#125;); ##StyleSheet 使用 StyleSheet.create 创建样式表对象，可以为 create 传递一个配置对象，这个对象就是要创建的样式 123456789101112131415161718const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', // 一些文本类型的样式值，需要引号包裹起来 alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, welcome: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;, instructions: &#123; textAlign: 'center', color: '#333333', marginBottom: 5, &#125;,&#125;); 载入样式(和对象的操作一样，例如style.welcome) 12345678910export default class App extends Component&lt;Props&gt; &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt;Welcome to React Native!&lt;/Text&gt; ... &lt;/View&gt; ); &#125;&#125; ##Text 文本节点，所有文本必须放到这个里面，在项目文档地址上面首页中有讲到 ##View 用来布局的，相当于页面元素div，在项目文档地址上面首页中有讲到 ##TextInput 文本框组件 这里刚开始输入框会特别窄，所以需要修改样式 在styles对象中添加一个一个键值对inputStyle: { width: &#39;100%&#39; } TextInput有很多属性选项，这里使用的几个练手,具体参考ReactNative官方文档 ###allowFontScaling 控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。 类型 必填 bool No ###autoCapitalize 控制TextInput是否要自动将特定字符切换为大写，This property is not supported by some keyboard types such as name-phone-pad. characters: 所有的字符。 words: 每个单词的第一个字符。 sentences: 每句话的第一个字符（默认）。 none: 不切换。 类型 必填 enum(‘none’, ‘sentences’, ‘words’, ‘characters’) No ###autoFocus 如果为true，在componentDidMount后会获得焦点。默认值为false。 类型 必填 bool No ###defaultValue 提供一个文本框中的初始值。当用户开始输入的时候，值就可以改变。在一些简单的使用情形下，如果你不想用监听消息然后更新value属性的方法来保持属性和状态同步的时候，就可以用defaultValue来代替。 类型 必填 string No ###keyboardType 决定弹出的何种软键盘的，譬如numeric（纯数字键盘）。 这些值在所有平台都可用： default number-pad decimal-pad numeric email-address phone-pad 下面的值仅iOS可用： ascii-capable numbers-and-punctuation url name-phone-pad twitter web-search 下面的值仅Android可用： visible-password 类型 必填 enum(‘default’, ‘email-address’, ‘numeric’, ‘phone-pad’, ‘ascii-capable’, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’, ‘visible-password’) No ###maxLength 限制文本框中最多的字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。 类型 必填 number No ###multiline 如果为true，文本框中可以输入多行文字。默认值为false。注意安卓上如果设置multiline = {true}，文本默认会垂直居中，可设置textAlignVertical: &#39;top&#39;样式来使其居顶显示。 类型 必填 bool No ###onChange 当文本框内容变化时调用此回调函数。回调参数为{ nativeEvent: { eventCount, target, text} }。 类型 必填 function No ###onChangeText 当文本框内容变化时调用此回调函数。改变后的文字内容会作为参数传递。 类型 必填 function No ###placeholder 如果没有任何文字输入，会显示此字符串。 类型 必填 string No ###placeholderTextColor 占位字符串显示的文字颜色。 类型 必填 color No ###secureTextEntry 如果为true，文本框会遮住之前输入的文字，这样类似密码之类的敏感文字可以更加安全。默认值为false。multiline={true}时不可用。 类型 必填 bool No ##Image 图片组件 Image的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 ###style 这里可以自定义样式，或者使用枚举 类型 必填 style 否 ###source 图片源数据（远程 URL 地址或本地数据）。 目前原生支持的图片格式有png、jpg、jpeg、bmp、gif、webp (仅 Android)、psd (仅 iOS)。 类型 必填 ImageSourcePropType 否 ##Button 按钮组件 Button的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 ###onPress 用户点击此按钮时所调用的处理函数, 必须的 类型 必填 function 是 ###title 按钮内显示的文本，必须的 类型 必填 string 是 ###accessibilityLabel 用于给残障人士显示的文本（比如读屏应用可能会读取这一内容） 类型 必填 string 否 ###color 文本的颜色(iOS)，或是按钮的背景色(Android) 类型 必填 color 否 ###disabled 设置为 true 时此按钮将不可点击。 类型 必填 bool 否 ###testID 用来在端到端测试中定位此视图。 类型 必填 string 否 ##ActivityIndicator 加载中的 loading 效果小圆圈 ActivityIndicator的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 ###animating 是否要显示指示器动画，默认为 true 表示显示，false 则隐藏。 类型 必填 bool 否 ###color 滚轮的前景颜色（默认为灰色）。 类型 必填 color 否 ###size 指示器的大小，默认为’small’。目前只能在 Android 上设定具体的数值。 类型 必填 enum(‘small’, ‘large’), number 否 ##ScrollView 滚动组件（默认，如果一个RN的页面非常长，超出了屏幕高度，这时候，不会像网页中那样自动提 供滚动条，如果需要让页面实现滚动的话，需要使用 ScrollView 把页面包裹起来） ScrollView的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 horizontal当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。 类型 必填 bool 否 滚轮的前景颜色（默认为灰色）]]></content>
      <tags>
        <tag>ReactNative组件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2FReactNative%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[title: ReactNative豆瓣电影项目copyright: truedate: 2019-01-09 09:00:29tags:keywords:description: ReactNative豆瓣电影项目技能：react，react-native，android环境 项目目的：只做项目环境搭建和小部分功能以练习react-native基本功能和android上app的打包构建 项目地址：ReactNative豆瓣电影 ReactNative项目环境搭建参考我这个文档ReactNative项目环境搭建 首页在进行这一步之前，先确认项目环境搭建并打包下载到手机上没有任何问题之后，进行之后的代码编写和调试 如何更改首页知识点：View组件和Text组件 编写一个自己的首页：根目录下创建MyHomePage.js作为自己的首页 注意：在 RN 中只能使用 .js 不能使用 .jsx 123456789101112131415161718192021222324/** * 自己的首页 */// 导入 reactimport React, &#123; Component &#125; from 'react'// 按需导入组件， View 组件就好比网页中的 div 元素import &#123; View, Text &#125; from 'react-native'export default class MyHomePage extends Component &#123; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; // 1. 在 RN 中不能使用在网页中的所有标签 // 2. 如果想要实现布局，RN 提供了一个叫做 View 的组件，来实现布局， 想要使用，要先导入 return ( &lt;View&gt; &#123; /*3. 在 RN 中，所有的文本，必须使用 RN 提供的 Text 组件进行包裹，依然是按需导入*/ &#125; &lt;Text&gt;123456&lt;/Text&gt; &lt;/View&gt;) &#125;&#125; 在index.js中导入自己的组件 12345// 导入自己的组件页面import MyHomePage from './MyHomePage.js'// 当使用 AppRegistry 注册项目的时候，方法中的第一个参数不要改// 第二个参数表示要把哪个页面注册为首页AppRegistry.registerComponent(appName, () =&gt; MyHomePage); 组件的学习ReactNative组件 正式开始豆瓣电影项目练习了上面一些组件和属性之后，着手去做一个豆瓣电影的小项目 Tabbar####基本结构 使用组件react-native-tab-navigator react-native-tab-navigator使用方法：老套路，对照官方文档，装包=&gt;导入=&gt;使用 这里的装包，不推荐使用npm，首先下载慢，其次如果是npm5.X在装新包的时候会把一些老包删除，可能会出现猝不及防的惊喜~~~~ 我这里使用的是facebook开发的yarn装包 1yarn add react-native-tab-navigator // 默认是 --save 12// 导入 Tabbvar 相关组件import TabNavigator from 'react-native-tab-navigator' 1234567891011121314151617181920212223242526export default class MyHomePage extends Component &#123; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; // 1. 在 RN 中不能使用在网页中的所有标签 // 2. 如果想要实现布局，RN 提供了一个叫做 View 的组件，来实现布局， 想要使用，要先导入 return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TabNavigator&gt; &lt;TabNavigator.Item title="Home"&gt; // 放入组件 &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item title="Me"&gt; // 放入组件 &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt; &lt;/View&gt;); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1 &#125;&#125;); 这里的放入组件的位置是自己创建的组件，其他后面的自己创建的组件引入方式也是一样套路创建自己的组件=&gt;引入=&gt;使用 创建自己的新组件，components/tabars/Home.js和components/tabars/Me.js 两个组件都简单写下基本代码 12345678910import React, &#123; Component &#125; from 'react'import &#123; View, Text &#125; from 'react-native'export default class Search extends Component &#123; render() &#123; return &lt;View&gt; &lt;Text&gt;这是 Home 组件&lt;/Text&gt; &lt;/View&gt; &#125;&#125; 引入 12import Home from './components/tabbars/Home.js'import Me from './components/tabbars/Me.js' 使用 12345678910&lt;View style=&#123;styles.container&#125;&gt; &lt;TabNavigator&gt; &lt;TabNavigator.Item title="Home"&gt; &lt;Home&gt;&lt;/Home&gt; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item title="Me"&gt; &lt;Me&gt;&lt;/Me&gt; &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt;&lt;/View&gt;); 组件高亮和切换拿home组件举例子，官方文档上这两句加上就行了 12selected=&#123;this.state.selectedTab === 'home'&#125;onPress=&#123;() =&gt; this.setState(&#123; selectedTab: 'home' &#125;)&#125;&gt; Tab栏的四个组件都按照这样写完，就可以实现正常切换了 组件的图标用react-native-vector-icons的组件，安装=&gt;配置=&gt;导入=&gt;使用 #####安装 1yarn add react-native-vector-icons #####配置 在官方文档找到对应的手机平台配置，我这里应为开发的是Android，所以配置的是Android的 编辑 android/app/build.gradle( NOT android/build.gradle ) ,去这个文件中添加下面两行代码 12345project.ext.vectoricons = [ iconFontNames: [ 'MaterialIcons.ttf', 'EvilIcons.ttf', 'FontAwesome.ttf' ] // Name of the font files you want to copy]apply from: "../../node_modules/react-native-vector-icons/fonts.gradle" fonts文件找到自己的字体文件C:\Users\wanggongtou\Desktop\douban\node_modules\react-native-vector-icons\Fonts下面的所有文件全部复制放到android/app/src/main/assets/fonts，下面没有assets/fonts就手动创建一个，再复制进来 将下面两行代码放到android/settings.gradle下合适的位置，并把前面的+去掉 12+ include ':react-native-vector-icons'+ project(':react-native-vector-icons').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-vector-icons/android') 编辑 android/app/build.gradle ，找到dependencies的大括号内部加上compile project(&#39;:react-native-vector-icons&#39;) 1234dependencies &#123; ... compile project(':react-native-vector-icons')&#125; 编辑android\app\src\main\java\com\douban\MainApplication.java在package com.douban; 这句代码下面添加import com.oblador.vectoricons.VectorIconsPackage;这句代码，在同一个文件中，找到protected List&lt;ReactPackage&gt; getPackages()在其内部，加上, new VectorIconsPackage() 12345678910package com.douban;import com.oblador.vectoricons.VectorIconsPackage;@Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage() , new VectorIconsPackage() ); &#125; 注意：只要修改了Android里面的配置文件，要重新打包构建 #####重新打包构建 1react-native run-android 这里可能会遇到两点问题： 问题一：提示没有licenses协议 解决方案：去配置Android的环境目录下，找到 Android SDK Manager 安装 Android SDK Build-tools 23.0.1 并接受其 license; 注意：这里的 Android SDK Build-tools 23.0.1 版本号需要和自己的构建工具版本号相对应 问题二：打包构建之后，发现手机上的app打开没有页面了 解决方案：关闭APP进程，重新打开一下就有了 导入1import Icon from 'react-native-vector-icons/FontAwesome' 使用可以去FontAwesome官网列表中查找对应组件需要的图标，Icon name=图标的名字就可以了 123456789&lt;TabNavigator&gt; &lt;TabNavigator.Item ... renderIcon=&#123;() =&gt; &lt;Icon name="home" size=&#123;25&#125; color="gray" /&gt;&#125; // 未选中状态下，展示的图标 renderSelectedIcon=&#123;() =&gt; &lt;Icon name="home" size=&#123;25&#125; color="#0079FF" /&gt;&#125; // 选中状态下展示的图标 ... &lt;Home&gt;&lt;/Home&gt; &lt;/TabNavigator.Item&gt;&lt;/TabNavigator&gt; 主页####主页轮播图 #####静态页面 找组件react-native-swiper去官网看， 安装、导入、使用 1yarn add react-native-swiper 因为轮播图在主页，所以在主页的组件中进行导入 12// 导入轮播图组件import Swiper from 'react-native-swiper' 把对应的结构和样式全部都拷贝过来 123456789101112131415161718192021222324252627282930313233343536373839404142434445export default class Search extends Component &#123; render() &#123; return ( &lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125;&gt; &lt;View style=&#123;styles.slide1&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Hello Swiper&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide2&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Beautiful&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide3&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;And simple&lt;/Text&gt; &lt;/View&gt; &lt;/Swiper&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; wrapper: &#123; &#125;, slide1: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#9DD6EB', &#125;, slide2: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#97CAE5', &#125;, slide3: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#92BBD9', &#125;, text: &#123; color: '#fff', fontSize: 30, fontWeight: 'bold', &#125;&#125;) 这里轮播图就出来了，再设置自动轮播和轮播图高度，由于这里的轮播图默认充满全屏，所以可以给轮播图最外层套一个View，给它一个高度 123&lt;View style=&#123;&#123; height: 220 &#125;&#125;&gt; // 放轮播图代码&lt;/View&gt; 给Swiper盒子加上属性，自动轮播 123&lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125; autoplay=&#123;true&#125; loop=&#123;true&#125;&gt; ...&lt;/Swiper&gt; #####渲染数据 12345678910111213141516171819202122232425262728293031323334export default class Home extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; banner: [] // 轮播图数组 &#125; &#125; componentWillMount() &#123; fetch('http://www.liulongbin.top:3005/api/getlunbo') .then(res =&gt; res.json()) .then(data =&gt; &#123; // console.warn(JSON.stringify(data, null, ' ')) this.setState(&#123; banner: data.message &#125;) &#125;) &#125; render() &#123; return ( &lt;View style=&#123;&#123; height: 220 &#125;&#125;&gt; &lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125; autoplay=&#123;true&#125; loop=&#123;true&#125;&gt; &#123;this.state.banner.map((item, i) =&gt; &#123; return &lt;View key=&#123;i&#125;&gt; &lt;Image source=&#123;&#123;uri: item.img&#125;&#125; style=&#123;&#123;width: '100%', height: '100%'&#125;&#125;&gt;&lt;/Image&gt; &lt;/View&gt; &#125;)&#125; &lt;/Swiper&gt; &lt;/View&gt; ); &#125;&#125; 主页六宫格导入所需要的组件 1import &#123; AppRegistry, StyleSheet, View, Text, Image, TouchableHighlight &#125; from 'react-native' 12345678910// 六宫格区域&#123;/* 在 RN 中，默认，就已经为 所有的 View 启用了弹性和模型，同时，默认的主轴是 纵向的 */&#125; &lt;View style=&#123;&#123; flexDirection: 'row', flexWrap: 'wrap' &#125;&#125;&gt; &lt;View style=&#123;styles.box&#125;&gt; &lt;Image source=&#123;require('../../images/menu1.png')&#125; style=&#123;&#123; width: 60, height: 60 &#125;&#125;&gt;&lt;/Image&gt; &lt;Text&gt;新闻资讯&lt;/Text&gt; &lt;/View&gt; // ...这里根据需求可以增加主页的宫格数目，我这里是六个，上面代码复制六份就可以 &lt;/View&gt; 1234567var styles = StyleSheet.create(&#123; box: &#123; width: '33.33%', alignItems: 'center', marginTop: 15 &#125;&#125;) 热映电影Main.js 配置路由在项目根目录新建一个Main.js作为项目根组件，修改一下index.js中指向App.js的代码 12import Main from './Main.js'AppRegistry.registerComponent(appName, () =&gt; Main); 去编辑Main.js的代码 1234// Main 项目的根组件// 导入组件import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, ActivityIndicator &#125; from 'react-native' 安装一个配置路由规则的插件react-native-router-flux 1yarn add react-native-router-flux 在Main.js中导入 1import &#123; Router, Stack, Scene &#125; from 'react-native-router-flux' Router: 就相当于 HashRouterStack: 这是一个分组的容器，他不表示具体的路由，专门用来给路由分组的Scene：就表示一个具体的路由规则，好比 昨天学到的 Route 新建两个组件components/movie/MovieList.js和components/movie/MovieDetail.js作为电影列表组件和电影描述组件 而且由于更换了项目的根组件，所以需要在Main.js中导入App.js 1234// 导入组件import App from './App.js'import MovieList from './components/movie/MovieList.js'import MovieDetail from './components/movie/MovieDetail.js' 继续修改代码将App.js作为首页展示，在render渲染的时候，可以配置首页，并且一并配置其他页面路由 1234567891011121314render() &#123; return &lt;Router sceneStyle=&#123;&#123; backgroundColor: 'white' &#125;&#125;&gt; &lt;Stack key="root"&gt; &#123;/* 配置路由规则 */&#125; &#123;/* 注意，所有的路由规则，都应该写到这个位置 */&#125; &#123;/* 第一个 Scene 就是默认要展示的首页 */&#125; &#123;/* key 属性，表示路由的规则名称，将来可以使用这个 key ，进行编程式导航，每一个路由规则，都应该提供一个 唯一的key， key不能重复 */&#125; &lt;Scene key="app" component=&#123;App&#125; title="" hideNavBar=&#123;true&#125; /&gt; &#123;/* 电影列表的路由规则 */&#125; &lt;Scene key="movielist" component=&#123;MovieList&#125; title="热映电影列表" /&gt; &lt;Scene key="moviedetail" component=&#123;MovieDetail&#125; title="电影详情" /&gt; &lt;/Stack&gt; &lt;/Router&gt;&#125; 这个时候，依然是不能点击跳转的，是因为没有给Home.js内部的热映电影组件绑定点击事件，所以去帮顶下 用TouchableHighlight包裹Home.js中的热映电影的代码片段 1234567891011// 在使用前应该现在最前面导入该组件import &#123; AppRegistry, StyleSheet, View, Text, Image, TouchableHighlight &#125; from 'react-native' // 包裹 &lt;TouchableHighlight onPress=&#123;this.goMovieList&#125; underlayColor="white" style=&#123;styles.box&#125;&gt; &#123;/* 在 TouchableHighlight 内部，只能放置唯一的一个元素 */&#125; &lt;View&gt; &lt;Image source=&#123;require('../../images/menu5.png')&#125; style=&#123;&#123; width: 60, height: 60 &#125;&#125;&gt;&lt;/Image&gt; &lt;Text&gt;热映电影&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt;// goMovieList 方法在下面定义 导入Actions组件，实现编程式导航 123// 导入 Actions 组件，实现编程式导航// Actions 表示要进行 JS 操作了import &#123; Actions &#125; from 'react-native-router-flux' 写一个跳转方法,并去TouchableHighlight中绑定这个方法 123456render() &#123; ... goMovieList = () =&gt; &#123; Actions.movielist() &#125;&#125; 1&lt;TouchableHighlight onPress=&#123;this.goMovieList&#125; underlayColor="white" style=&#123;styles.box&#125;&gt; 这样就实现了基本的路由跳转 豆瓣热映电影列表基本页面123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, StyleSheet, ... &#125; from 'react-native'const styles = StyleSheet.create(&#123; ...&#125;)// 导入路由的组件import &#123; Actions &#125; from 'react-native-router-flux'export default class MovieList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; ... &#125; &#125; componentWillMount() &#123; ... &#125; render() &#123; return ... &#125; ...&#125; 豆瓣接口这里先说一下豆瓣接口，根据接口可以进行数据的获取 访问https://api.douban.com/v2/movie/in_theaters?start=0&amp;count=12可以看到豆瓣的电影数据，链接中的?后面的参数start表示开始页码，count表示每页显示的记录条数，可以根据需求修改，可以拷贝假数据用于测试，可以调用接口，用于测试方法成功之后进行动态数据的渲染 fetch获取电影列表数据 根据页码获取电影列表数据 渲染电影列表的方法测试 每项数据需要同步this.state中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default class MovieList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; movies: [], // 电影列表 nowPage: 1, // 当前的页码 totalPage: 0, // 总页数 pageSize: 15, // 每页显示的记录条数 isloading: true // 是否正在加载数据 &#125; &#125; componentWillMount() &#123; this.getMoviesByPage() &#125; render() &#123; return &lt;View&gt; &#123;this.renderList()&#125; &lt;/View&gt; &#125; // 根据页码获取电影列表 getMoviesByPage = () =&gt; &#123; const start = (this.state.nowPage - 1) * this.state.pageSize const url = `https://api.douban.com/v2/movie/in_theaters?start=$&#123;start&#125;&amp;count=$&#123;this.state.pageSize&#125;` /* fetch(url) .then(res =&gt; res.json()) .then(data =&gt; &#123; this.setState(&#123; isloading: false, movies: this.state.movies.concat(data.subjects), totalPage: Math.ceil(data.total / this.state.pageSize) &#125;) &#125;) */ /* 此代码用了拷贝的假数据用于测试 */ setTimeout(() =&gt; &#123; this.setState(&#123; isloading: false, movies: require('./test_list.json').subjects, totalPage: 1 &#125;) &#125;, 1000) &#125; // 渲染电影列表的方法,此处用于测试，若能获取电影条数则方法可以继续往下写 renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;View&gt; &lt;Text&gt;&#123;this.state.moives.length&#125;&lt;/Text&gt; &lt;/View&gt; &#125; ...&#125; 渲染电影列表数据12345678910111213141516171819202122232425// 渲染电影列表的方法 renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;FlatList data=&#123;this.state.movies&#125; keyExtractor=&#123;(item, i) =&gt; i&#125; // 解决 key 问题 renderItem=&#123;(&#123; item &#125;) =&gt; this.renderItem(item)&#125; // 调用方法，去渲染每一项 /&gt; &#125; // 渲染每项电影 renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight&gt; &lt;View&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#125; 美化布局相当于加一些样式，不然太丑了 123456789101112131415161718192021222324252627282930313233// 渲染电影列表的方法renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;FlatList data=&#123;this.state.movies&#125; keyExtractor=&#123;(item, i) =&gt; i&#125; // 解决 key 问题 renderItem=&#123;(&#123; item &#125;) =&gt; this.renderItem(item)&#125; // 调用方法，去渲染每一项 ItemSeparatorComponent=&#123;this.renderSeparator&#125; //渲染分割线的属性方法 onEndReachedThreshold=&#123;0.5&#125; // 距离底部还有多远的时候，触发加载更多的事件 onEndReached=&#123;this.loadNextPage&#125; // 当距离不足 0.5 的时候，触发这个方法，加载下一页数据 /&gt;&#125;// 渲染每项电影renderItem = (item) =&gt; &#123; return &lt;View style=&#123;&#123; flexDirection: 'row', padding: 10 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View style=&#123;&#123; justifyContent: 'space-around' &#125;&#125;&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt;&#125;// 渲染分割线renderSeparator = () =&gt; &#123; return &lt;View style=&#123;&#123; borderTopColor: '#ccc', borderTopWidth: 1, marginLeft: 10, marginRight: 10 &#125;&#125;&gt;&lt;/View&gt;&#125; 下拉加载更多利用官方文档的属性onEndReachedThreshold和onEndReached来控制 onEndReachedThreshold：距离底部还有多远的时候，触发加载更多的事件 onEndReached:当距离不足 0.5 的时候，触发这个方法，加载下一页数据 123456789101112131415161718192021222324252627282930313233343536373839404142// 渲染电影列表的方法 renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;FlatList data=&#123;this.state.movies&#125; keyExtractor=&#123;(item, i) =&gt; i&#125; // 解决 key 问题 renderItem=&#123;(&#123; item &#125;) =&gt; this.renderItem(item)&#125; // 调用方法，去渲染每一项 ItemSeparatorComponent=&#123;this.renderSeparator&#125; //渲染分割线的属性方法 onEndReachedThreshold=&#123;0.5&#125; // 距离底部还有多远的时候，触发加载更多的事件 onEndReached=&#123;this.loadNextPage&#125; // 当距离不足 0.5 的时候，触发这个方法，加载下一页数据 /&gt; &#125; // 渲染每项电影 renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight underlayColor="#fff" onPress=&#123;() =&gt; &#123; Actions.moviedetail(&#123; id: item.id &#125;) &#125;&#125;&gt; &lt;View style=&#123;&#123; flexDirection: 'row', padding: 10 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View style=&#123;&#123; justifyContent: 'space-around' &#125;&#125;&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#125; // 加载下一页 loadNextPage = () =&gt; &#123; // 如果下一页的页码值，大于总页数了，直接return if ((this.state.nowPage + 1) &gt; this.state.totalPage) &#123; return &#125; this.setState(&#123; nowPage: this.state.nowPage + 1 &#125;, function () &#123; this.getMoviesByPage() &#125;) &#125; 提升体验写着写着，遇到了个问题，这时不时的访问不到服务，但是这好像和代码关系不大，因为我重连几次就可以了，我觉得和网速关系很大，我这网速太渣 所以我就加了几句提示错误的代码 123456789101112131415161718getMoviesByPage = () =&gt; &#123; const start = (this.state.nowPage - 1) * this.state.pageSize const url = `https://api.douban.com/v2/movie/in_theaters?start=$&#123;start&#125;&amp;count=$&#123;this.state.pageSize&#125;` fetch(url) .then(res =&gt; &#123; if (res.ok) &#123; return res.json() &#125; else &#123; console.error('服务器忙，请稍后重试' + res.status) &#125; &#125;) .then(data =&gt; &#123; ... &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) &#125; 豆瓣热映电影详情基本页面12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, ActivityIndicator, ScrollView &#125; from 'react-native'export default class MovieDetail extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; movieInfo: &#123;&#125;, // 电影信息 isloading: true &#125; &#125; componentWillMount() &#123; ... &#125; render() &#123; return &lt;View&gt; ... &lt;/View&gt; &#125; ...&#125; 同样的需要去Main.js配置路由规则，和配置MovieList组件的路由规则一个套路，这里由于我之前配置过了，不再配置 给MovieDetil在MovieList中的代码片段（就是渲染的每一部电影的代码片段）加上链接跳转，这里依然是要依靠TouchableHighlight组件 首先引入 1import &#123; View, Image, Text, ActivityIndicator, FlatList, StyleSheet, TouchableHighlight &#125; from 'react-native' 在获取每项电影的时候，代码片段用TouchableHighlight包裹起来 12345678910111213renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight underlayColor="#fff"&gt; &lt;View style=&#123;&#123; flexDirection: 'row', padding: 10 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View style=&#123;&#123; justifyContent: 'space-around' &#125;&#125;&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#125; 绑定点击事件，并导入Actions，实现编程式导航 12// 导入路由的组件import &#123; Actions &#125; from 'react-native-router-flux' 123456// 渲染每项电影renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight underlayColor="#fff" onPress=&#123;() =&gt; &#123; Actions.moviedetail(&#123; id: item.id &#125;) &#125;&#125;&gt; ... &lt;/TouchableHighlight&gt;&#125; 数据渲染在生命周期是componentWillMount()的时候从接口获取数据，再到this.state同步数据，然后去render()填充数据，这里为render()定义了一个方法，直接this.renderInfo()调用就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, ActivityIndicator, ScrollView &#125; from 'react-native'export default class MovieDetail extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; movieInfo: &#123;&#125;, // 电影信息 isloading: true &#125; &#125; componentWillMount() &#123; fetch('https://api.douban.com/v2/movie/subject/' + this.props.id) .then(res =&gt; res.json()) .then(data =&gt; &#123; this.setState(&#123; movieInfo: data, isloading: false &#125;) &#125;) &#125; render() &#123; return &lt;View&gt; &#123;this.renderInfo()&#125; &lt;/View&gt; &#125; renderInfo = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;ScrollView&gt; &lt;View style=&#123;&#123; padding: 4 &#125;&#125;&gt; &lt;Text style=&#123;&#123; fontSize: 25, textAlign: 'center', marginTop: 20, marginBottom: 20 &#125;&#125;&gt;&#123;this.state.movieInfo.title&#125;&lt;/Text&gt; &lt;View style=&#123;&#123; alignItems: 'center' &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: this.state.movieInfo.images.large &#125;&#125; style=&#123;&#123; width: 200, height: 280 &#125;&#125;&gt;&lt;/Image&gt; &lt;/View&gt; &lt;Text style=&#123;&#123; lineHeight: 30, marginTop: 20 &#125;&#125;&gt;&#123;this.state.movieInfo.summary&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/ScrollView&gt; &#125;&#125; 提示：各种接口数据最好借助Postman工具，先看一下接口数据里哪些属性要用，不然挺乱的，不过不借助Psotman工具的话也可以去该接口连接把json数据拷贝下来到编辑器中，自己整理下格式 小功能体验：拍照功能为Me.js添加一个拍照功能 调用插件react-native-image-picker该插件可以调用摄像头 安装包 1yarn add react-native-image-picker 导入包 123import &#123; View, Button, Image &#125; from 'react-native'// 导入拍照的包import ImagePicker from 'react-native-image-picker' 创建拍照时的配置对象 1234567891011121314var photoOptions = &#123; //底部弹出框选项 title: '请选择', cancelButtonTitle: '取消', takePhotoButtonTitle: '拍照', chooseFromLibraryButtonTitle: '选择相册', quality: 0.75, // 照片的质量 allowsEditing: true, // 允许被编辑 noData: false, // 拍照时候不附带日期 storageOptions: &#123; // 存储选项 skipBackup: true, // 在IOS平台中，会自动把 照片同步到 云端的存储，如果此项为 true，表示跳过 备份，不会把照片上传到 云端 path: 'images' &#125;&#125; 创建保存数据的容器 123456constructor(props) &#123; super(props); this.state = &#123; imgURL: 'https://qqqww.com/uploads/avatar.png' // 将来，拍摄的照片路径，会存到这里 &#125; &#125; 渲染 123456render() &#123; return &lt;View style=&#123;&#123; alignItems: 'center', paddingTop: 70 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: this.state.imgURL &#125;&#125; style=&#123;&#123; width: 200, height: 200, borderRadius: 100 &#125;&#125;&gt;&lt;/Image&gt; &lt;Button title="拍照" onPress=&#123;this.cameraAction&#125;&gt;&lt;/Button&gt; &lt;/View&gt; &#125; 定义一个拍照方法，在渲染的时候调用 12345678910111213cameraAction = () =&gt; &#123; ImagePicker.showImagePicker(photoOptions, (response) =&gt; &#123; console.log('response' + response); if (response.didCancel) &#123; // 点击了取消按钮，此时，用户没有拍照 return &#125; // 用户已经拍摄了一张照片了 this.setState(&#123; imgURL: response.uri &#125;); &#125;) &#125; 到这一步，在React-Native项目中的拍照功能就完成了，并且手机测试成功 发布安卓项目说明：这只是用于测试react-native的一部分功能的小demo，并不能用于实际作用 参考文章： ReactNative之Android打包APK方法（趟坑过程） React Native发布APP之签名打包APK 这里总结下： 先保证配置了一个正确的RN环境 在 cmd 命令行中，运行这一句话keytool -genkey -v -keystore my-release-key2.keystore -alias my-key-alias2 -keyalg RSA -keysize 2048 -validity 10000生成签名 my-release-key.keystore 表示你一会儿要生成的那个 签名文件的 名称【很重要，包找个小本本记下来】 -alias 后面的东西，也很重要，需要找个小本本记下来，这个名称可以根据自己的需求改动my-key-alias 当运行找个命令的时候，需要输入一系列的参数，找个口令的密码，【一定要找个小本本记下来】 当生成了签名之后，这个签名，默认保存到了自己的用户目录下C:\Users\liulongbin\my-release-key2.keystore 将你的签名证书copy到 android/app目录下。 编辑 android -&gt; gradle.properties文件，在最后，添加如下代码： 1234MYAPP_RELEASE_STORE_FILE=your keystore filenameMYAPP_RELEASE_KEY_ALIAS=your keystore aliasMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** 编辑 android/app/build.gradle文件添加如下代码： 1234567891011121314151617181920...android &#123; ... defaultConfig &#123; ... &#125; + signingConfigs &#123; + release &#123; + storeFile file(MYAPP_RELEASE_STORE_FILE) + storePassword MYAPP_RELEASE_STORE_PASSWORD + keyAlias MYAPP_RELEASE_KEY_ALIAS + keyPassword MYAPP_RELEASE_KEY_PASSWORD + &#125; +&#125; buildTypes &#123; release &#123; ... + signingConfig signingConfigs.release &#125; &#125;&#125;... 进入项目根目录下的android文件夹，在当前目录打开终端，然后输入./gradlew assembleRelease开始发布APK的Release版； 第七步出了点小问题，报错信息是Execution failed for task ‘:app:validateSigningRelease’.后来看看原来是我的第五步里的MYAPP_RELEASE_KEY_ALIAS=your keystore alias这一块的签名写错了，忘了加后缀名，改了之后，又给了我一个响应超时的惊喜，不过我就重新运行了第二次就打包构建成功了 当发行完毕后，进入自己项目的android\app\build\outputs\apk目录中，找到app-release.apk，这就是我们发布完毕之后的完整安装包；安装到自己和朋友的手机上，测试成功，就可以上传到各大应用商店供用户使用啦。 注意：请记得妥善地保管好你的密钥库文件，不要上传到版本库或者其它的地方。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ReactNative项目环境搭建]]></title>
    <url>%2FReactNative%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[ReactNative项目环境搭建看到github中ReactNative豆瓣电影的项目, 打算做一个基本功能的练练手，然后就项目基本配置中就遇到了不少坑，这里总结一下流程和遇到的一些坑，万一再遇到了，还能再来看解决方案 说明：ReactNative的项目建议由React开发经验的看会事半功效 ReactNative项目环境的搭建需要： android编译环境 手机设备能够正常连接电脑并通过adb devices指令测试连接正确 成功打包并安装到手机 基本开发环境首先，我是按照React Native中文网的方法，一步一步安装的，但并不成功，（错误信息大概描述的是android develepment or device安卓或者手机设备的问题，后面还有个fail connection连接失败）, 所以配合下面的android环境搭建和手机设备正确连接之后才成功，但是这些步骤在后续的环境搭建过程中肯定是有用到的 这里简述一下步骤： Chocolatey安装 Chocolatey是一个 Windows 上的包管理器，类似于 linux 上的yum和 apt-get。 你可以在其官方网站上查看具体的使用说明。一般的命令行安装步骤应该是下面这样： 1@powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 一般来说，使用 Chocolatey 来安装软件的时候，需要以管理员的身份来运行命令提示符窗口。译注：chocolatey 的网站可能在国内访问困难，导致上述安装命令无法正常完成。请使用稳定的翻墙工具。 如果你实在装不上这个工具，也不要紧。下面所需的 python2 和 nodejs 你可以分别单独去对应的官方网站下载安装即可。 Python 2安装 打开命令提示符窗口，使用 Chocolatey 来安装 Python 2. 1choco install python2 Node安装 打开命令提示符窗口，使用 Chocolatey 来安装 NodeJS。注意，目前已知 Node 7.1 版本在 windows 上无法正常工作，请避开这个版本！ 1choco install nodejs.install 安装完 node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！ 其实到这里我才知道为什么要安装另外一个包管理工具Chocolatey，原以为我安装过NodeJS的就不需要重新安装了（我以前使用cnpm安装的），但这个官方文档明显提到不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！所以我这里老老实实的又用choco指令安装了一遍Node 安装完 node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！ 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global Yarn、React Native 的命令行工具（react-native-cli） Yarn是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 1npm install -g yarn react-native-cli 安装完 yarn 后同理也要设置镜像源： 12yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 这里是官方提示的一个错误：但我的安装过程中没有遇到，先放到这 如果你遇到EACCES: permission denied权限错误，可以尝试运行下面的命令（限 linux 系统）： sudo npm install -g yarn react-native-cli. android环境搭建(Android Studio)1、这里是我是直接去官网下载的最新版Android Studio 下载下来就是这么个玩意： 2、一看到exe文件，直接安装嘛，这里建议不要随意安装到其他目录（因为第一次我就安装到了我自定义的我的个人dev目录中，就后面各种错误，后来卸载，重新开始），按照他默认的走，还有之后需要下载的插件选项，尽量他默认打钩的，不要去掉，然后再加上我建议的就行了 3、记住以上的钩都要选上，初步安装过程结束后，选择Custom选项 4、选择如下图的组件安装，都选上 5、这里遇到了这样一堆错误 1Preparing &quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot;.Downloading https://dl.google.com/android/repository/platform-tools_r28.0.0-windows.zip&quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot; ready.Installing Android SDK Platform-Tools in D:\Android\sdk\platform-tools&quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot; complete.&quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot; finished.Preparing &quot;Install Android Support Repository (revision: 47.0.0)&quot;.Downloading https://dl.google.com/android/repository/android_m2repository_r47.zipjava.io.IOException: Cannot download &apos;https://dl.google.com/android/repository/android_m2repository_r47.zip&apos;: SSL peer shut down incorrectly, response: 200 OKWarning: An error occurred while preparing SDK package Android Support Repository: Cannot download &apos;https://dl.google.com/android/repository/android_m2repository_r47.zip&apos;: SSL peer shut down incorrectly, response: 200 OK.&quot;Install Android Support Repository (revision: 47.0.0)&quot; failed.Preparing &quot;Install Android SDK Tools (revision: 26.1.1)&quot;.Downloading https://dl.google.com/android/repository/sdk-tools-windows-4333796.zipjava.io.IOException: Cannot download &apos;https://dl.google.com/android/repository/sdk-tools-windows-4333796.zip&apos;: Read timed out, response: 200 OKWarning: An error occurred while preparing SDK package Android SDK Tools: Cannot download &apos;https://dl.google.com/android/repository/sdk-tools-windows-4333796.zip&apos;: Read timed out, response: 200 OK.&quot;Install Android SDK Tools (revision: 26.1.1)&quot; failed.Preparing &quot;Install SDK Patch Applier v4 (revision: 1)&quot;.Downloading https://dl.google.com/android/repository/3534162-studio.sdk-patcher.zip.bakjava.io.IOException: Cannot download 没复制全，就大概讲的是插件安装失败，主要错误原因就是外国网站被墙或者网速实在太渣,为什么这样讲呢？因为我去网上查，都说是被墙，但我很确认我已经翻墙了啊，而且后面安装插件的过程中，一直重试，发现有些能成功，有些不能成功（这里要多看日志），所以我断定是网络过慢原因了，多重试，而且一定要开vpn 6、安装过程中，有一个选择主题的环节，一个白色的，一个黑色的，随便选一个，主题嘛，看着顺眼就行 下面就可以一直默认安装到最后有一个让你运行Android Studio ，然后直接运行，会到Android Studio的欢迎界面 ，它的有下角有个Configure, Configure下面有个SDK Manager,点击进去 7、在SDK Platforms窗口中，选择Show Package Details，然后在Android 6.0 (Marshmallow)中勾选Google APIs、Android SDK Platform 23、Intel x86 Atom System Image、Intel x86 Atom_64 System Image以及Google APIs Intel x86 Atom_64 System Image。这里遇到和6同样的问题，先看下面的第8步再apply 8、在SDK Tools窗口中，选择Show Package Details，然后在Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1（必须是这个版本）。然后还要勾选最底部的Android Support Repository.这里也遇到和6同样的问题 解决办法：两个 办法一：开VPN，我这里用的蓝灯 办法二：可以直接迅雷加速下载包到本地，然后一个一个放入该放的文件夹中，这里可以参考文档手动安装配置Android Studio，在本文后面我会把这里所需要的插件一整套，全部整理上传到我的百度云，这样从我的百度云下载应该就好多了，然后再参考前面的手动安装配置Android Studio文档手动配置也可以的 下面会有android环境依赖包、基本依赖包、vpn软件一整套的百度云链接 到这一步，Android Studio环境基本就配置好了 手机驱动安装###手机驱动查看和安装 这里要把手机连接到电脑上 前面android环境配置好之后，我又去测试了下，测试命令 1234// 初始化一个安卓仓库react-native init douban// 安装app到手机上react-native run-android 但是又发现报了一个错误设备不能连接或者是android环境问题 然后这里我去我的电脑=&gt;管理=&gt;设备管理器查看了下 我这里用驱动人生更新过了，所以红框中看起来一切正常，遇到设备问题一定要去电脑的驱动管理看看，看带!号的或者带?号的相关驱动去给更新下 到了这一步，然后我再来测试 手机设备的设置启用开发者模式这里拿我的小米手机举例 你的手机=&gt;设置=&gt;我的设备或者我的手机=&gt;全部参数=&gt;MIUI版本（其他手机找版本号就对了）=&gt;莲须点十几下基本上这时候就显示你已经处于开发者模式了 返回设置=&gt;更多设置=&gt;开发者选项=&gt;打开开发者选项和USB调试和USB安装和USB调试（安全设置） 由于到了这一步也翻了不少文档，我又多学了一条测试手机设备连接的指令 cmd命令行输入命令检测下 1adb devices 这是后命令行给到的结果就能显示成功连接了，下面再进行安卓环境初始化和打包安装到手机就可以成功了 1react-native init douban ####安装成功 这时候发现手机上多了一个叫douban的应用 回去node后台看看 这个窗口，就是React Native Packager 是帮我们实时编译项目源代码的，并把编译结果应用到手机上，可以让开发者随时查看最新的项目代码效果。 打开手机上刚安装的应用看看 就显示Welcome to React Native，这样就可以通过App.js入口文件进行开发和调试了 在手机上查看代码在Welcome to React Native界面常按左下角的菜单键，会弹出下图 android环境支持包百度云链接依赖包里有android环境依赖包、基本依赖包、vpn软件 链接：https://pan.baidu.com/s/1Oj2EUuuuNbKdQcoeUsc1AQ提取码：tbo6 参照文档搭建基本的开发环境 - 英文官网搭建基本的开发环境 - 中文]]></content>
      <tags>
        <tag>ReactNative豆瓣电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Diff算法]]></title>
    <url>%2FReact-Diff%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[React-虚拟DOM与Diff算法]]></title>
    <url>%2FReact-%E8%99%9A%E6%8B%9FDOM%2F</url>
    <content type="text"><![CDATA[虚拟DOM与Diff算法虚拟DOM(Virtual Document Object Model)的模拟DOM树操作需要用到DIff算法，推荐先看这句话下面的文章内容 DOM的本质 浏览器中的概念，用JS对象来表示 页面上的元素，并提供了操作 DOM 对象的API React中的虚拟DOM 框架中的概念，是程序员 用JS对象来模拟 页面上的 DOM 和 DOM嵌套 实现虚拟DOM的目的 为了实现页面中， DOM 元素的高效更新 DOM和虚拟DOM的区别 DOM：浏览器中，提供的概念；用JS对象，表示页面上的元素，并提供了操作元素的API 虚拟DOM：是框架中的概念；而是开发框架的程序员，手动用JS对象来模拟DOM元素和嵌套关系 本质： 用JS对象，来模拟DOM元素和嵌套关系 目的：就是为了实现页面元素的高效更新 如何实现页面元素的高效更新利用虚拟DOM可以实现页面元素的高效更新，那么如何实现页面元素的高效更新呢？ 假如我有一个需求：点击列头，实现表格数据顺序的排序 数据来源：表格中的数据从数据库查询而来 存储：这些查询到的数据以数组的形式，存放到了浏览器的内存中 渲染： 方案一：手动for循环整个数据，手动拼接字符串str += &#39;&lt;tr&gt;123&lt;tr&gt;&#39; 方案二：使用模板引擎，类似art-template，比手动更方便点，其内部本质也是拼接了字符串 思考：对于上述方案，思考其缺陷和解决方案 如果用户点击了时间,想要按照时间从大到小的排序，其流程应当是： 触发点击事件，在事件中，把内存中的对象数组，重新排序 当排序完成之后，页面时旧的，但是内存中的顺序是最新的 把最新的数据顺序渲染到页面上 上述方案只是实现了把数据渲染到页面中，但是并没有把性能做到最优，这里的第三步，完全可以按需渲染页面(只重新渲染排序中需要更新的数据所对应的页面元素)，以提高性能 DOM树实现按需渲染： 什么是DOM树： DOM结构，类似下图1中的结构 一个网页的呈现过程： 浏览器请求服务器获取HTML代码 浏览器在内存中，解析DOM结构, 并在浏览器中内存中渲染出一棵DOM树 浏览器把DOM树呈现到页面上 怎么按需更新：获取内存中新旧两棵DOM树，得到需要被按需更新得DOM树 如何获取到新旧两棵DOM树： 浏览器并没有直接提供获取DOM树的相关API，因此无法拿到内存中的DOM树 可以自己手动模拟新旧两棵DOM树 那么怎么去模拟DOM树呢 模拟一个DOM元素，假如网页上有一个div元素，怎么模拟呢？用js以字面量赋值的形式进行模拟，看下图模拟DOM元素 当旧的DOM发生改变，对比两棵DOM树的标签和值，如果都相等，则不变，如果标签相同，值不同，则修改，这样的新旧两棵树就是模拟DOM树 总结：什么是虚拟DOM 用JS对象的形式，来模拟页面上的DOM嵌套关系，即虚拟DOM是以JS对象的形式存在的 React中虚拟DOM对象的本质和目的： 本质：用JS对象来模拟DOM元素的嵌套关系 目的：实现页面元素的高效更新 Diff算法 tree diff上图中新旧两棵DOM树每一层对比的过程叫做tree diff，当整棵DOM树逐层对比完毕，则所有的按需更新的元素必然能够找到 component diff在进行tree diff的时候，每一层中组件级别的对比，叫做component diff 如果对比前后，组件类型相同，则暂时认为不需要更新组件 如果对比前后，组件类型不同，则需要暂时移除旧组件，创建新组件，追加到页面上 ###element diff 在进行组件对比的时候，如果两个组件类型相同，需要进行元素级别的对比，这叫做element diff]]></content>
      <tags>
        <tag>虚拟DOM与Diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-vuex]]></title>
    <url>%2Fvue-vuex%2F</url>
    <content type="text"><![CDATA[vuex描述本文档对于有一定vue项目环境搭建和配置的相关经验的人会更轻松的理解 什么是 vuex vuex 是 Vue 配套的公共管理数据工具，他可以把一些共享的数据，保存到 vuex 中，方便整个程序中的任何组件直接获取或者修改公共数据 为什么要用vuex下面原始的传值和vuex的区别与优缺点 兄弟组件之间传值定义中间实例vm进行传值，逻辑过于复杂 父子组件之间传值子向父传值，通过事件调用机制，父给子传值通过属性绑定，但如果嵌套过深的传值，难免会产生复杂的逻辑 引入vuexvuex相当于是项目共享数据仓库，全局共享数据存储区域，方便各个组件直接拿来使用，这样就少了很多复杂的逻辑 vuex安装和使用 安装 1npm i vuex -S 导入包到文件 1import Vuex from 'vuex' 注册 1Vue.use(Vuex) 实例化，得到一个数据仓储对象 123456789101112var store = new Vuex.store(&#123; state: &#123; // 可以把 state 对比 vue 组件中的 data ，专门用来存储数据 count: 0 &#125;, mutations: &#123; &#125;, getters: &#123; &#125;&#125;) 将 vuex 创建的实例对象挂载到 vm 实例上 12345const vm = new Vue(&#123; ... // store: store store&#125;) 在需要共享数据的组件中想要去访问 vuex 实例中的数据，需要通过this.$store.count来访问 例子####项目演示地址 git@github.com:ForeManWang/vuex-study.git 可以先去这里下载项目下来，跟着例子操作 创建基本项目结构和搭建vue环境和配置，不多赘述了 下载下来项目之后，在根目录自行安装所有依赖插件 1npm i state这里就是相当于第六步，去components/amount.vue 去访问 vuex 实例中的数据 这时候打开后台，打开页面刷新，发现就已经能够访问 vuex 中的数据了 moutations 操作数据加法需求 去components/counter.vue的methods中写了一个add方法 1&lt;input type="button" value="增加" @click="add"&gt; 1234567add() &#123; // 千万不要这么用，不符合 vuex 的设计理念 // 这种操作数据的方法相当于是自己的组件操作数据，假如数据紊乱，会不知道是谁操作的数据导致了数据紊乱，所以不利于后期维护 // 所以将需求告诉一个 &lt;库管员&gt; 让 &lt;库管员&gt; 去操作 // 这里就是要 vuex 仓库中的 mutations 提供的方法去操作对应的数据，这样假如维护中出现数据紊乱的情况，可以快速定位错误的原因，利于后期维护 this.$store.state.count++; &#125;, 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit(‘方法名’) 所以在components/counter.vue内部就这样调用 12345add() &#123; // 千万不要这么用，不符合 vuex 的设计理念 // this.$store.state.count++; this.$store.commit("increment");&#125;, 减法需求 去components/counter.vue的methods中写了一个remove方法 1&lt;input type="button" value="减少" @click="remove"&gt; 在main.js的moutations中定义 123subtract(state, obj) &#123; state.count -= (obj.c + obj.d)&#125; 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数； 去components/counter.vue中调用，需要传参 12 这样减法就实现了，实现一次性减obj.c + obj.d getters 包装数据 这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations main.js 12345getters: &#123; optCount: function (state) &#123; return '当前最新的count值是: ' + state.count &#125;&#125; counter.vue 123456computed:&#123; fullname: &#123; get()&#123;&#125;, set()&#123;&#125; &#125;&#125; 经过回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者；其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值 总结 state中的数据，不能直接修改，如果想要修改，必须通过mutations 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.*** 如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit(&#39;方法的名称&#39;， 唯一的一个参数) 如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用getters, 如果需要使用 getters ,则用this.$store.getters.***]]></content>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-读取文件方法封装]]></title>
    <url>%2Fnode-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[node读取文件方法封装&amp;Promise准备 一个空js文件和files文件里面放上三个文件，方便下面操作 载入核心模块 12const fs = require('fs')const path = require('path') 需求：封装一个方法，给你一个要读取文件的路径，你这个方法能帮我读取文件，并把内容返回给我 普通方式12345// 这是普通读取文件的方式 fs.readFile(path.join(__dirname, './files/1.txt'), 'utf-8', (err, dataStr) =&gt; &#123; if (err) throw err console.log(dataStr)&#125;) 但是这样达不到需求，所以就有了下面一种方式 简单封装一给一个路径参数fpath 12 由于读取文件是异步操作，不能直接在函数内部return,所以没有接收到返回值，在外部调用就是undefined 所以用callback接收一下 简单封装二封装一个给定文件路径，返回读取到的内容的读取文件的异步方法 12345678910function getFileByPath (fpath, callback) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) throw err // console.log(data) callback(data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), (data) =&gt; &#123; console.log(data) // 111&#125;) 这样基本就达到需求了，但是依然不能知道读取文件数据到底成功还是失败，没有明确的标识 简单封装三所以可以给 callback 规定两个参数，一个失败结果，一个成功结果 同时我们规定，如果成功后，返回结果应该位于 callback 结果的第二个位置，此时第一个结果由于没有出错，所以放一个 null ，如果失败了，则第一个结果放置 error 对象，第二个位置放置一个 undefined 123456789101112function getFileByPath (fpath, callback) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) throw err // console.log(data) callback(null, data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), (err, data) =&gt; &#123; // console.log(data) // 111 if (err) return console.log(err.message) console.log(data)&#125;) 这种情况下，不管成功还是失败，共用的是一个参数（不是很好理解），可以拆分为两个，成功一个回调，失败一个回调，这样更好理解 简单封装四1234567891011function getFileByPath (fpath, succCb, errCb) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) errCb(err) succCb(data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), function (data) &#123; console.log(data + '成功了')&#125;, function (err) &#123; console.log(err.message + '失败了')&#125;) 这样就基本封装完成，达到需求，并提示失败和成功，提升体验 Promise解决回调地狱假如我们使用上一种封装方法，去按顺序读取三个文件files/1.txt、files/2.txt、files/3.txt这样就需要嵌套 1234567891011getFileByPath(path.join(__dirname, './files/1.txt'), function (data) &#123; console.log(data) getFileByPath(path.join(__dirname, './files/2.txt'), function (data) &#123; console.log(data) getFileByPath(path.join(__dirname, './files/3.txt'), function (data) &#123; console.log(data) &#125;) &#125;)&#125;) 假如以上的嵌套有很多，还不止这样三个嵌套呢？就会成这样 这样就形成了回调地狱，由于函数查找变量的规则需要由内至外一层一层去查找，这样难免造成大量的资源浪费 引入Promise来解决回调地狱的问题 Promise介绍Promise是ES6中的一个对象，用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。 在浏览器控制台输入console.dir(Promise)可以看到 我们看图片中两个红框，第一个红框，Promise是一个构造函数 第二个红框是两个回调函数，reject()表示失败执行，resolve()表示成功后执行 点开prototype:Promise发现一个then方法和catch()方法，而then和catch方法和在Promise的原型对象中，所以可以用promise直接调用 Promise解决回调地狱这样就可以封装一个基于Promise读取文件的函数 12345678910const fs = require('fs')function getFileByPath(fpath) &#123; return new Promise (function (resolve, reject) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) return reject(err) resolve(data) &#125;) &#125;)&#125; 12345678910111213141516171819202122// 如果 ，前面的 Promise 执行失败，我们不想让后续的Promise 操作被终止，可以为 每个 promise 指定 失败的回调 getFileByPath('./files/11.txt') .then(function (data) &#123; console.log(data) // 读取文件2 return getFileByPath('./files/2.txt') &#125;, function (err) &#123; console.log('这是失败的结果：' + err.message) // return 一个 新的 Promise return getFileByPath('./files/2.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;).then(function (data) &#123; console.log(data) &#125;) 当 我们有这样的需求： 哪怕前面的 Promise 执行失败了，但是，不要影响后续 promise 的正常执行，此时，我们可以单独为 每个 promise，通过 .then 指定一下失败的回调； 有时候，我们有这样的需求，个上面的需求刚好相反：如果 后续的Promise 执行，依赖于 前面 Promise 执行的结果，如果前面的失败了，则后面的就没有继续执行下去的意义了，此时，我们想要实现，一旦有报错，则立即终止所有 Promise的执行。 1234567891011121314151617getFileByPath('./files/1.txt') .then(function (data) &#123; console.log(data) return getFileByPath('./files/22.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;) .catch(function (err) &#123; // catch 的作用： 如果前面有任何的 Promise 执行失败，则立即终止所有 promise 的执行，并 马上进入 catch 去处理 Promise中 抛出的异常； console.log('这是自己的处理方式：' + err.message) &#125;)]]></content>
      <tags>
        <tag>函数封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime添加自定义代码段]]></title>
    <url>%2Fsublime%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[sublime添加自定义代码段一：打来Sublime Text，在菜单栏找到“Tools（工具）”-&gt;”New Snippet（新代码段）” 二：Hello, ${1:this} is a ${2:snippet}.这块代码区域，可以直接删除，然后添加上你所需要的代码段进去，然后Ctrl + s保存，保存到默认文件夹，命名随意，假如你的命名是vuecode，那么你去书写你的代码时就需要通过vuecode来调用这个代码段 三：调用过程： Ctrl + Shift + P ======&gt; Snippet:vuecode =====&gt; enter 这时候代码段就自动添加到你需要的地方了]]></content>
      <tags>
        <tag>sublime添加自定义代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime安装插件&常用的sublime插件]]></title>
    <url>%2Fsublime%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[sublime安装插件&amp;常用的sublime插件其实sublime安装插件并不难，几步操作就好了，关键插件安装过程中总出现各种各样的错误，而且比较好的插件都有哪些呢？ 安装步骤 第一步：下载一个sublime，正版不正版，汉化不汉化的那就按照你个人要求制定就行，网上也有相应教程，我用的是官网的，然后加的汉化包 sublime官网 第二步：打开你的sublime , Ctrl + ` 切换到sublime控制台，控制台一共两块内容区域，第一块区域时监控代码运行进程的，不用管，当然出错也可以从这里查找，第二块区域根据你自己的是sublime2还是sublime3来选择代码复制粘贴进去并运行 sublime3 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) sublime2 1import urllib2,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 第三步：安装完成后，按 Ctrl+Shift+p (Windows)/ Command+Shift+p (Mac), 输入Install Packages，之后Sublime会自动下载插件列表，然后弹出一个小的下拉菜单让你填写想要下载的插件名称。 常见错误这里是我遇到过的一些问题：欢迎大佬们补充 直接无法安装插件网上看了一些文档，说是GWF被墙问题 错误提示如下： 解决办法： 1、开代理自己翻墙 2、直接下载插件，将下载的文件解压到Sublime Text3的Installed Packages目录下 解析错误还有个问题是包解析错误，需要自己去发现错误翻译下看看是不是这一类问题，我忘记错误代码了，这一类问题可能是网络原因，我换了个网，能用了 常用插件推荐下面推荐我安装的一些插件，主要参照了博客sublime常用插件 本文参考博客Package Control]]></content>
      <tags>
        <tag>sublime安装插件&amp;常用的sublime插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记一]]></title>
    <url>%2FES6%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ES6笔记一 ES6的笔记参考ECMAScript 6 入门 部署进度 这里使用阮一峰老师写的一个工具 ES-Checker用来检查各种运行环境对 ES6 的支持情况。访问ruanyf.github.io/es-checker，可以看到您的浏览器支持 ES6 的程度。运行下面的命令，可以查看你正在使用的 Node 环境对 ES6 的支持程度。 1234567$ npm install -g es-checker$ es-checker// 结果=========================================Passes 39 feature DetectionsYour runtime supports 92% of ECMAScript 6========================================= Babel转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 例子： 1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 Babel的配置文件.babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 1234567891011# 最新转码规则$ npm install --save-dev babel-preset-latest# react 转码规则$ npm install --save-dev babel-preset-react# 不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 然后，将这些规则加入.babelrc。 12345678&#123; &quot;presets&quot;: [ &quot;latest&quot;, &quot;react&quot;, &quot;stage-2&quot; ], &quot;plugins&quot;: []&#125; 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 本来这里想详细总结下各种转码，然后发现阮一峰老师写的是真的详细，请参见ECMAScript 6 入门]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基本属性配置]]></title>
    <url>%2Fwebpack%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack 基本属性配置1234567891011121314151617181920212223242526272829303132333435363738394041const path = require('path')module.exports = &#123; entry: &#123; // main是默认入口，也可以是多入口 main: './src/main.js' &#125;, // 出口 output: &#123; filename: './build.js', // 指定js路径 path: path.join(__dirname, '..', '', 'dist') // 最好是绝对路径 // 代表上一级的dist &#125;, module: &#123; // 一样的功能rules: webpack2.xx新加的 loaders: [ // require('./a.css||./a.js') &#123; test: /\.css$/, loader: 'style-loader!css=loader', //多个loader用!分割 //顺序是反过来的 2!1 多个loader &#125;, &#123; test: /\.(jpg|svg)$/, loaderL 'url-loader?limit=4096&amp;name=[name].[ext]', // limit=4096&amp;name=[name].[ext]' 多个参数之间用&amp;符号分割 //[name].[ext]内置提供的 options: &#123; limit: 4096, name: '[name].[ext]' &#125; &#125; ] &#125;, plugins: [ // 插件的执行顺序是依次执行的，和loader是反过来的 new htmlWebpackPlugin(&#123; template: './src/index.html', &#125;) // 将src下的template属性描述的文件根据当前配置的output.path，将文件移动到该目录。 // 在插件的执行过程中，它本身可以去拿当前所设置的webpack选项，便于对webpack选项的复用， ]&#125;]]></content>
      <tags>
        <tag>webpack配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 中全局变量与形参的赋值]]></title>
    <url>%2Fjavascript-%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BD%A2%E5%8F%82%E7%9A%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[javascript 中全局变量与形参的赋值现象定义数组 12345678var arr1,arr2,arr3;var arr4 = [ &#123;name:'zhangsan',age:'18'&#125;, &#123;name:'lisi',age:'18'&#125;, &#123;name:'wangwu',age:'18'&#125;, &#123;name:'zhaoliu',age:'18'&#125;, &#123;name:'xiaoming',age:'18'&#125;]; 创建一个change函数 123456function change(params)&#123; for(var i = 0; i&lt;params.length;i++)&#123; params[i].name = params[i].name +'miaomiaomiao' &#125; return params &#125; 将arr4赋值给arr1、arr2、arr3并打印，观察打印结果 12345678arr1 = arr4arr2 = arr4arr3 = arr4console.log(change(arr1)) // 对任意一个数组执行change函数console.log(arr4)console.log(arr1)console.log(arr2)console.log(arr3) 以下是打印结果 可以发现，当其中任何一个数组改变时，其他的数组的值也会跟着改变 原因在计算机的内存中，系统对变量的声明在栈中，而值是在堆中 画图理解 arr1 = arr4; arr2 = arr4; arr3 = arr4 的赋值只是将arr4的值的地址指向了arr1，arr2，arr3；内存中并没有为其创建内容空间，这样就导致直接或间接的修改变量的值，那么原始值都将被修改。]]></content>
      <tags>
        <tag>全局变量与形参的赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 中局部变量和形参同名冲突问题]]></title>
    <url>%2Fjavascript-%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%BD%A2%E5%8F%82%E5%90%8C%E5%90%8D%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[javascript 中局部变量和形参同名冲突问题新建一个数组 1234567var arr = [ &#123;name:'zhangsan',age:'18'&#125;, &#123;name:'lisi',age:'18'&#125;, &#123;name:'wangwu',age:'18'&#125;, &#123;name:'zhaoliu',age:'18'&#125;, &#123;name:'xiaoming',age:'18'&#125;] 局部变量和形参冲突的情况 12345678910function getList(i)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr[i].name == 'e')&#123; console.log('已遍历完整个数组') &#125; &#125; return arr[i]&#125;console.log(getList(1)) // undefined// 调用 getList(1)时，其结果并不是 &#123;tel:1234658,name:'b'&#125; , 而是 undefined 解决方法 将形参改变或者将循环体内变量改变一下 12345678910function getList(i) &#123; for(var j = 0; j &lt; arr.length; j++)&#123; if(arr[j].name == 'e')&#123; console.log('已遍历完整个数组') &#125; &#125; return arr[i]&#125;// console.log(getList(1)) // &#123; tel: 1234658, name: 'b' &#125;// 更改 循环体中 i 变量 为 j 结果就是想要的结果了]]></content>
      <tags>
        <tag>局部变量和形参同名冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将本地文件上传到github]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[将本地文件上传到github文件上传 桌面打开git命令面板 新建Git仓库 1git init 添加文件到git 12git add . // 或者下面一种git add README.md 添加此次更新内容描述 12 将本地仓库关联到github上 1git remote add origin git@github.com:ForeManWang/letao.git // 最后面的地址需要填写你自己github的项目地址 将代码上传到github 1git push -u origin master 常见错误执行代码git remote add origin git@github.com:ForeManWang/letao.git时出现错误：fatal: remote origin already exists 解决办法 执行命令 12git remote rm origingit remote add origin git@github.com:ForeManWang/letao.git 这样就解决了，后面再上传项目到github 12 ···]]></content>
      <tags>
        <tag>本地文件上传到github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之seo优化]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8Bseo%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HEXO SEO 优化最近用hexo搭建个人博客，但是去网上搜，搜什么都搜不到自己，这就很尴尬了，于是想到了seo优化，这里主要对google和baidu爬虫的优化 什么是 SEO SEO（Search Engine Optimization）:汉译为搜索引擎优化。是一种方式:利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是：为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力 =&gt;百度百科 建议: 最好一步一测，反正我遇到的坑无数个，由于之前没有一步一测，导致到后来错到哪都不知道，或者开启hexo debug服务命令，这样在本地站点根目会生成一个debug.log文件，就是你的错误日志，可以去查看，具体指令如下： 到站点目录下，开启git命令面板 1hexo s --debug 本地文章优化添加sitemap首先给你的文章生成sitemap文件 123npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎12 然后在站点配置文件_config.yml中添加以下代码(这里我在参考资料《HEXO SEO 高级优化》这篇博客中看到的配置，但是在我的配置里一应用就报错，所以我的没用到，我给注释起来了，具体配置和报错信息如下：) 1234567891011# 自动生成sitemap# sitemap:# path: sitemap.xml# baidusitemap:# path: baidusitemap.xml# 报错信息# =&gt; Error：FATAL duplicated mapping key at line 153, column 1:# ??path: baidusitemap.xml# ^# YAMLException: duplicated mapping key at line 153, column 1:# ??path: baidusitemap.xml 最后修改站点配置文件_config.yml 123456# URL 配置站点## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://qqqww.com # 这里应该更改为你自己的站点地址，我写的是我的root: /permalink: :title/ # 这里简化目录结构，后面也会讲到permalink_defaults: 每次hexo g后都会在/public目录下生成sitemap.xml和baidusitemap.xml，这就是你的站点地图，这里需要将站点地图提交到百度站长之家 添加 roborts.txt文件添加 roborts.txt文件到站点根目录source文件夹下 这里可以参照我的： 12345678910111213141516User-agent: *Allow: /Allow: /archives/Allow: /tags/Allow: /categories/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://qqqww.com/sitemap.xmlSitemap: http://qqqww.com/baidusitemap.xml 百度收录站点登录百度站长平台，在用户中心 =&gt; 站点管理添加你的站点网址 配置完站点属性后，进入最后一步：验证网站。有三种方式：文件验证、HTML标签验证、CNAME验证，文件验证和CNAME验证都比较简单，也有相对应的帮助文本，在此我选择的是HTML标签验证。 在主题的_config.yml文件中，设置：baidu_site_verification: true，如果没有该字段就手动添加。 在themes/next/layout/_partials/head.swig文件中添加下列代码 12345// 每个人的content值都不一致，请注意更换成你的content值&#123;% if theme.baidu_site_verification %&#125; &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;6K5YmdKWEx&quot; /&gt;&#123;% endif %&#125; 配置好后，重新发布站点，在百度站长页面完成验证。 百度链接提交 链接提交工具是网站主动向百度搜索推送数据的工具，本工具可缩短爬虫发现网站链接时间，网站时效性内容建议使用链接提交工具，实时向搜索推送数据。本工具可加快爬虫抓取速度，无法解决网站内容是否收录问题 主动推送 最为快速的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。 安装百度链接提交插件 1npm install hexo-baidu-url-submit --save 123456# 百度链接自动提交baidu_url_submit: count: 6 # 提交最新的链接数量 host: http://lianghuii.com # 在百度站长平台中注册的域名 token: # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 设置deploye 123456deploy: - type: git repo: github: git@github.com:MeanMouse/MeanMouse.github.io.git coding: git@git.coding.net:MeanMouse/blog.git - type: baidu_url_submitter 自动推送 是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。。 在主题配置文件将baidu_push设置为true 在路径themes\next\layout_scripts\下创建baidu_push.swig 文件，文件内容如下 12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) &#123; bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; &#125; else &#123; bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125; sitemap这里将之前生成的sitemap文件提交到百度站长 手动提交 如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度。 手动提交方式比较简单，按照官方提示就会使用 - -(这种方式确实好用，方便) 谷歌收录站点进行这个之前，首先友情提示下大佬们，最好开个vpn用，因为很多涉及谷歌服务，我这里用的是789vpn，网上有很多，可以去找，lantern也能用 打开 Google Search Console，添加博客地址。并进行相关验证,根据提示即可完成认证,认证成功如下： 认证方法其实这里方法和百度的类似，也有三种，我用的是直接下载文件，放到我的站点source目录下，然后我在git命令面板里输入以下指令（下面将这一套指令简称为更新并同步文件指令） 123hexo cleanhexo ghexo d 之后，我去google认证，发现并不能验证成功，后来去站点配置_config.yml下添加了一句代码，和百度的类似 1google-site-verification: true 这样就验证成功了，再去看看，验证成功吧的界面如下（这里用的是参考文档里验证成功的图片，其实都一样，下面发参考文档链接） 验证通过后点进入控制台测试robots.txt文件,没有错误和警告即可 提交 sitemap.xml 文件，点击右上角添加/测试站点地图输入 sitemap.xml 进行测试，测试无误后再提交文件 robots.txt验证和sitemap.xml验证通过，抓取网页，我这里给sitemap.xml和baidusitemap.xml都加进去了，虽然不知道是不是提交一个就可以了….. 输入框留空表示抓取首页，填入 about 表示抓取关于页面，抓取完成后,抓取因为验证原因,可能会有几种状态：完成、部分完成和已重定向等，直接提交就可以。 验证站点是否被收录 谷歌中输入：site:yousite，会有提示：(抓取需要时间。等几分钟) 以上就完成了百度和谷歌的搜索引擎抓取站点的功能 优化结构seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下： 123456# URL 配置站点## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://qqqww.comroot: /permalink: :title/permalink_defaults: 首页标题优化SEO最重要的是你的标题，一般搜索都是搜索你的标题。 更改index.swig文件(your-hexo-site\themes\next\layout); 将下面这段代码： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 这时候你的首页会更符合网站名称 - 网站描述这习惯。 进阶，做了seo优化，把关键词也显示在title标题里，可改成： 1&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125;&#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 注意：别堆砌关键字，整个标题一般不超过80个字符，可以通过chinaz的seo综合查询检查。 关键词与描述搜索引擎除了主要抓取标题外，页面的关键词和描述也会抓取。 在\scaffolds\post.md中添加如下代码，用于生成的文章中添加关键字和描述。 12keywords: description: 在\themes\next\layout_partials\head.swig有如下代码，用于生成文章的keywords。暂时还没找到生成description的位置。 1234567&#123;% if page.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; page.keywords &#125;&#125;&quot; /&gt;&#123;% elif page.tags and page.tags.length %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;&quot; /&gt;&#123;% elif theme.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; theme.keywords &#125;&#125;&quot; /&gt;&#123;% endif %&#125; 然后在\themes\next\layout_macro\post.swig中找到这个位置： 1&#123;% if post.description %&#125; 将以下代码去掉： 1234567&#123;% if post.description %&#125; &#123;&#123; post.description &#125;&#125; &lt;div class=&quot;post-more-link text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; 否则首页的文章摘要就会变成文章的description。 举个例子： 123456789101112---title: HEXO SEO优化方法总结copyright: truetop: 0date: 2018-07-19 21:17:42tags: SEOcategories: Debianpermalink:password:keywords: [HEXO,HEXO SEO优化]description: 总结一下使用Hexo搭建博客后，SEO优化方案的总结，后期会不定期更新。--- nofollow 标签给非友情链接的出站链接添加 “nofollow” 标签，nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 以hexo的NexT主题为例，需要修改两处 一：找到footer.swig，路径在your-hexo-site\themes\next\layout_partials，将下面代码 改成： 将下面代码： 1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; 改成： 1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt; 二：修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout_macro，将下面代码 1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 改成： 1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 将下面代码： 1&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt; 改成： 1&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt; 安装nofollow插件 减少出站链接能够有效防止权重分散，hexo有很方便的自动为出站链接添加nofollow的插件。 1npm install hexo-autonofollow --save 该插件会将博客中的出站链接自动加上nofollow属性，例外请在站点配置文件_config.xml中添加如下字段 1234nofollow: enable: true exclude: - https://qqqww.com // 友链地址 这样，例外的链接将不会被加上nofollow属性。 开启SEO优化选项hexo博客next提供了seo优化选项，在主题配置文件_config.yml中有个选项是seo，默认是false，改成true即开启了seo优化，会进行一些seo优化，如改变博文title等，然后相同文件下有个关键字选项keywords，填充上，写博文时最好每篇博文都加上keywords。 我用的是next的主题，把该主题的_config.yml的默认keyword改成你的网址关键词 12# Set default keywords (Use a comma to separate)keywords: &quot;wanggongtou&quot; 开启压缩文件因为hexo生成的文件是静态html，里面占用了大量的空白符。使用gulp进行压缩接口提高访问速度并且降低内存。 使用命令 1234npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --savenpm install gulp-concatnpm install gulp-imagemin 在hexo blog文件夹下创建gulpfile.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var gulp = require(&apos;gulp&apos;), uglify = require(&apos;gulp-uglify&apos;), cssmin = require(&apos;gulp-minify-css&apos;), imagemin = require(&apos;gulp-imagemin&apos;), htmlmin = require(&apos;gulp-htmlmin&apos;), htmlclean = require(&apos;gulp-htmlclean&apos;); concat = require(&apos;gulp-concat&apos;);//JS压缩gulp.task(&apos;uglify&apos;, function() &#123; return gulp.src([&apos;./public/js/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;])//只是排除min.js文件还是不严谨，一般不会有问题，根据自己博客的修改我的修改为return gulp.src([&apos;./public/**/*.js&apos;,&apos;!./public/zuoxi/**/*.js&apos;,,&apos;!./public/radio/**/*.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public/js&apos;));//对应修改为./public即可&#125;);//public-fancybox-js压缩gulp.task(&apos;fancybox:js&apos;, function() &#123; return gulp.src(&apos;./public/vendors/fancybox/source/jquery.fancybox.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public/vendors/fancybox/source/&apos;));&#125;);// 合并 JSgulp.task(&apos;jsall&apos;, function () &#123; return gulp.src(&apos;./public/**/*.js&apos;) // 压缩后重命名 .pipe(concat(&apos;app.js&apos;)) .pipe(gulp.dest(&apos;./public&apos;));&#125;);//public-fancybox-css压缩gulp.task(&apos;fancybox:css&apos;, function() &#123; return gulp.src(&apos;./public/vendors/fancybox/source/jquery.fancybox.css&apos;) .pipe(cssmin()) .pipe(gulp.dest(&apos;./public/vendors/fancybox/source/&apos;));&#125;);//CSS压缩gulp.task(&apos;cssmin&apos;, function() &#123; return gulp.src([&apos;./public/css/main.css&apos;,&apos;!./public/css/*min.css&apos;]) .pipe(cssmin()) .pipe(gulp.dest(&apos;./public/css/&apos;));&#125;);//图片压缩gulp.task(&apos;images&apos;, function() &#123; gulp.src(&apos;./public/uploads/*.*&apos;) .pipe(imagemin(&#123; progressive: false &#125;)) .pipe(gulp.dest(&apos;./public/uploads/&apos;));&#125;);// 压缩 public 目录 html文件 public/**/*.hmtl 表示public下所有文件夹中html，包括当前目录 gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;)) &#125;);gulp.task(&apos;build&apos;, [&apos;uglify&apos;, &apos;cssmin&apos;, &apos;fancybox:js&apos;, &apos;fancybox:css&apos;, &apos;jsall&apos;,&apos;images&apos;]);//, &apos;minify-html&apos; 在根目录下的package.json文件中生成写入scripts: 1&quot;scripts&quot;: &#123;&quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp build&quot;&#125; 这样每次输入npm run build就会自动清理上次生成的文件，然后生成新的文件，最后压缩文件。 站内优化这里就真正的涉及到SEO的相关知识了，对你的文章的结构，描述，关键词进行优化。 title优化搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。 1用法：&lt;title&gt;网站标题&lt;/title&gt; 注意点： 首页title写法：首页的title写法格式一般是“总标题-特别重要的关键词或者一句话含有特别重要关键词的描述”。注意这里的“-”是英文，要问我为什么呢?这个因为互联网不是我们国内开发的，汉语不是标准，计算机只对英语敏感性较高，而对汉语敏感性不太高。 栏目页title写法：栏目页title的写法有两种，关键词名称命名写法是“栏目名称-总名称”，非关键词命名写法是：“栏目名称 栏目关键词-总名称”。 分类列表页的title写法：用关键词为这个栏目起名，然后按照下列顺序填写便可了“分类列表页名称-栏目名称-总名称”。 注意事项： 每个标题应该是根据当前内容设置的独特不重复的。 字数限制。不能太长，要不然搜索引擎结果列表会显示不全。最好不超过 25 个中文字。最好是在 10~20 之间。 切勿堆砌关键词。这是很多人常犯的错误 关键词最好出现在最前面 标题有吸引力。毕竟有吸引力的标题才能让用户点击 连词符的使用。可以使用 |-&gt; 不要使用没有意义的句子 keywords优化主要作用是告诉搜索引擎，这个网站内容是什么。因为，好多站长在keywords堆砌关键词，所以好多搜索引擎不太重视keywords了。建议大家还是认真填写keywords，有的搜索引擎还是很重视的，由于现在词频和密度对于 SEO 影响不大，所以只要保持你的正文中出现 4~6 次关键词就可以了。千万不能堆砌关键词。 注意点： 首页keywords写法：首页keywords按照选定的栏目名称，在首页的keywords中加入总名称、栏目名称和一两个关键词。 栏目keywords写法：栏目的keywords其栏目下所有分类列表的名称列出，加上栏目关键字，写法是“栏目名称,栏目关键字,栏目分类列表名称” 分类列表页keywords写法：将你这个栏目中的主要关键字写入。 Description优化功能让搜索引擎是判断整个页面内容的，当中要写入的内容是你页面内容的简介。description一般不超过100个字符。对于个人站点而言，描述标签最好是一句通顺的句子，如果不能的话，则宁可不要。 注意点： 首页description写法：description的写法就是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍形式，不要只写关键词。 栏目description写法：将栏目的标题、关键字、分类列表名称，尽量的写入description中，仍是尽量写成介绍形式。 分类description写法：是将你这个栏目中的主要关键字写入。 H标签优化H 标签的重要性可能是仅次与页面标签。H1-&gt;H6 的重要性依次降低。 所以建议在页面的 H1 和 H2 标签中混入关键词 图片 ALT 文字优化插入图片的时候会提示输入文字，这个不能敷衍。图片 ALT 文字出现的关键词对页面相关性也有一定的影响。同样的，也不要在 ALT 上堆砌关键词。 内部链接及锚文字优化内部链接对于爬行和收录具有很重要的意义。内部链接对页面关键词相关性也有影响，最主要的就是在内部链接中使用锚文字。 锚文字是告诉搜索引擎被链接页面主题内容的最重要依据之一。我们有时候可能无法控制外部链接的锚文字，但是对于站内的内部链接锚文字我们可以控制。不过有几点需要注意： 适当出现匹配关键词的锚文字 锚文字不能集中导航或者页尾，要分散在正文中 本文参考文档以下三篇 HEXO SEO 高级优化 Hexo Seo优化让你的博客在google搜索排名第一 Hexo SEO设置]]></content>
      <tags>
        <tag>hexo seo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Git安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BGit%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[windows 环境下 Git 安装一、安装：官网下载对应 exe 文件直接安装 我电脑是win10 64位的，这里讲的是在windows下安装的Git 下载地址 下载之后，一直next就可以了 二、配置：配置环境变量 win + r 打开windows运行面板 输入 sysdm.cpl 打开系统属性面板 选择系统属性面板上的高级 选择环境变量 双击path,添加一条你安装git的路径即可，我这里是E:\Develop\Git\Git\cmd 三、检测是否安装成功 到任意位置下，鼠标右键出现Git Bash Here和Git GUI Here即视为成功 四、整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>Git安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装逼路上的小插曲一：博客上传图片无法显示]]></title>
    <url>%2F%E8%A3%85%E9%80%BC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%B0%8F%E6%8F%92%E6%9B%B2%E4%B8%80%EF%BC%9A%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[博客上传图片无法显示有些日子，不知不觉就过去了…… 有些坑，不知不觉就进了，我也很无奈啊 废话不说了，这里参照了————大佬的文档 简单总结下： 站点下配置文件_config.yml修改，找到post_asset_folder(如果没有，自己写一个)，默认值一般是false，修改为true。 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 1npm install https://github.com/CodeFalling/hexo-asset-image --save 安装后再站点根目录下执行命令hexo new &quot;我的测试博客&quot;，在hexo/source/_post文件夹下不仅会生成对应的.md文件，还有一个同名的文件夹，用于存放该文件相关的资源。 1npm new "我的测试博客" 这个时候在写.md文档的时候，只需要图片链接为我的测试博客/[图片名].png即可 这里是利用相对路径解决了这一问题，详细请参照大佬的博客 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>博客上传图片无法显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Github账号注册]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BGithub%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[GitHub账号注册点击进入Github官网 注册之后，登录，创建一个测试项目可以点击右上角红框位置 点击Create repository之后就可以创建一个测试项目了 新建一个分支 分支是用来同时处理存储库不同版本的方法；默认情况下你的存储库会有一个分支master作为主分支 。 输入分支名称，enter即可 在分支上可以进行修改和提交，具体还可以使用Git指令进行项目的下载，修改和上传，如果没有Git的，请参照我同一个系列的另一篇文章，点击hexo搭建个人博客之Git安装 Git的一些指令 本地任意位置打开Git面板 1234Git init // 初始化一个Git仓库，后面可以跟仓库名Git pull git@github.com:ForeManWang/test.git // 上传文件到项目地址，指令后面跟的是项目地址，具体查看方法，下面有Git clone git@github.com:ForeManWang/test.git // 下载文件到本地，指令后面跟的是项目地址，具体查看方法，下面有...... Github项目地址：见下图 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示 本文参考： （https://blog.csdn.net/lezaimemecha/article/details/84969353）]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Hexo安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[hexo搭建个人博客之Hexo安装什么是hexo一个快速高效的博客框架 安装hexo安装hexo之前，先确认自己必须已经安装了NodeJs和Git和已经拥有了GitHub账号，可以参照以下三篇文章 Git详细安装教程————点击此处 GitHub账号注册详细教程————点击此处 NodeJs详细安装过程和环境配置————点击此处 如果以上步骤已经全部完成，去任意一个位置，右键打开Git面板，输入以下指令 1npm install -g hexo-cli 等待一会，安装之后，继续输入指令 1hexo -v // 有版本号则成功 成功安装之后，就可以创建一个博客了，详细请见hexo搭建个人博客总流程 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>hexo安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之NodeJs安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BNodeJs%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[NodeJs 安装与环境配置安装这里只介绍windows环境下的NodeJs安装 这里是官网请点击 图片中左边稳定版，右边最新版 点击，下载，是一个msi文件，直接安装就可以，记住你的安装路径，后面做环境配置 安装之后就可以做配置了 配置不知道怎么做环境配置的点击这里查看,同样的道理 测试打开命令行面板，输入以下指令 1node -v npmnpm即包管理工具，一般安装完NodeJs之后，npm是附带安装上去的，所以，同样的执行命令行命令 1npm --version nvmnvm即版本管理工具，详细参考点击这里 整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>NodeJs安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客详细教程]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hexo个人博客一 Git 安装及GitHub账号注册Git详细安装教程————点击此处 GitHub账号注册详细教程————点击此处 二 NodeJS 安装NodeJs详细安装过程和环境配置————点击此处 三 Hexo 安装Hexo基本框架搭建过程————点击此处 四 基本主题next开启GitPages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 登录Github，右上角创建一个项目，也可以参照我的另外一个同系列的文章 hexo搭建个人博客之Github账号注册 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。 点击Create Repository之后，选择settings 进入如下： 找到GitHub Pages找到choose theme 之后进入主题仓库,任意选择一个主题，这里我选择的是这个 此时再去查看settings,会发现GitHub Pages变化如下 现在，我们就可以使用https://UserName.github.io，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)： 备注：由于我的有一个服务已经在开着了，电脑太卡了，这里借用参考文档的图片 创建一个本地博客站点打开windows命令面板，输入以下指令 1hexo init myBlog 测试本地博客12hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 此时打开浏览器，输入 http://localhost:4000/，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)： 同步GitHub，允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地站点的配置_config.yml文件，修改deploy下的配置如下： 1234deploy: type: git // 类型为 git repository: git@github.com:ForeManWang/ForeManWang.github.io.git // 这里写仓库地址 branch: master 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 下载主题-Next(官网)安装Git部署插件12345npm install hexo-deployer-git --save // 有版本号即成功// 部署指令hexo clean // 每次同步之前操作，清理缓存hexo g //将md文档生成博客hexo d //同步到github 下载Next,参考安装包，或直接克隆1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在 Hexo 中有2份主要的配置文件，其名称都是_config.yml。一份是站点配置文件，在站点根目录下另一份是主题配置文件，在主题目录下，比如我们这里用到的是next主题，则在myHexoBlog\themes\next下 打开themes/next/下的_config.yml,查找scheme，可以看到四种不同的风格。去掉#注释，即启用对应的scheme，博主采用Gemini主题，大家可以依次测试效果，选择自己喜欢的scheme。打开根目录下的_config.yml，查找theme字段，将字段改为theme: next(冒号:之后要有空格分隔，否则无效) 之后通过hexo g和hexo s，再在浏览器中访问localhost:4000即可本地预览主题效果。 主题基础配置设置过程中，可运行在本地查看，步骤跟之前一样(注意所有的：后面都要空一格!!!)。 设置菜单找到主题next的_config.yml查找menu`，去掉#注释即可显示对应的菜单项。 设置网站基本信息和语言找到站点的_config.yml，找到Site如下设置。 设置个人信息找到主题next的_config.yml，找到social如下设置。 设置头像进入themes/next/source/uploads下，找到avatar.png，放入一张同样大小的图片替换名字。之后找到主题next的_config.yml，找到avatar如下设置。 更多美化next主题参考请点击next美化主题1-4 hexo seo优化整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示 本文参考文档Hexo搭建个人博客（一）——框架搭建 Hexo搭建个人博客网站详细流程 Hexo博客搭建]]></content>
      <tags>
        <tag>hexo搭建个人博客</tag>
      </tags>
  </entry>
</search>
