<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[雅虎十四条性能优化原则]]></title>
    <url>%2F%E5%BC%80%E5%8F%91%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[雅虎十四条性能优化原则 首先我去看了《雅虎十四条性能优化原则》，当然是看大佬博客翻译过来的，纯英文的我看不懂 Web 应用性能优化黄金法则: 先优化前端程序 (front-end) 的性能,因为这是80% 或以上的最终用户响应时间的花费所在 减少HTTP请求 使用CDN 添加Expires头 压缩组件 将样式表放在头部 将脚本放在底部 避免CSS表达式 使用外部的js和css 减少DNS查找 精简js 避免重定向 删除重复脚本 配置ETag 使Ajax可缓存 原文中写的很详细，但是整个文章结构不是很明显，所以本文总结了下重点，并整理了一下结构，想看更加详细的请移步14条Yahoo（雅虎）十四条优化原则 减少HTTP请求 80%的最终用户响应时间花在前端程序上,而其大部分时间则花在各种页面元素, 如图像、 样式表、 脚本和 Flash 等的下载上 减少页面元素：简化页面设计 image：使用精灵图，配合 background-image 和 background-position实现部分图片 Combined files ：组合多个脚本文件到单一文件，同样的，样式也可以采用类似的方式处理 描述：40-60% 据的日常访问是首次访问,因此为首次访问者加快页面访问速度是用户体验的关键 CDN CDN(Content Delivery Network, 内容分发网络 ) 是地理上分布的web server的集合,用于更高效地发布内容。 通常基于网络远近来选择给具体用户服务的 web server 用户离 web server 的远近对响应时间也有很大影响。从用户角度看,把内容部署到多个地理位置分散的服务器上将有效提高页面装载速度 分布静态内容 使用如Akamai Technologies, Mirror Image Internet, 或 Limelight Networks 等 CDN 服务提供商的服务将是划算的 上面是原文中提供的CDN服务商，但我记得国内百度、阿里应该都有CDN服务，应该也是可用的，但由于使用CDN需要域名备案，我的域名暂未来得及备案，所以暂未测试 Expires Header 通过使用Expires header, 在客户端缓存更多的脚本文件、样式表、图像文件和 Flash Expires header常用于图像文件,但是它也应该用于脚本文件、样式表和 Flash 如果服务器是Apache 的话,您可以使用ExpiresDefault基于当期日期来设置过期日期,如: ExpiresDefault “access plus 10 years设置过期时间为从请求时间开始计算的10 年 注意：如果使用超长的过期时间,则当内容改变时,必须修改文件名称 压缩页面元素 通过压缩HTTP响应内容可减少页面响应时间 Accept-Encoding: gzip, deflate 如果 Web server 检查到 Accept-Encoding 头,它会使用客户端支持的方法来压 缩 HTTP 响应,会设置 Content-Encoding 头,如:Content-Encoding: gzip Gzip 是目前最流行及有效的压缩方法 如果是Apache,在 1.3 版本下需 使用 mod_gzip 模块,而在 2.x 版本下,则需使用mod_deflate Web server 根据文件类型来决定是否压缩: 一般HTML、脚本文件、样式表文件等进行压缩 图像文件和 PDF 文件一般不应该被压缩,因为它 们本来就是压缩格式保存的 把样式表放在头部 浏览器会阻塞显示直到样式表下载完毕,因此我们需要把样式表放在 HEAD部分 把样式表移到HEAD部分可以提高界面加载速度 把脚本文件放在底部 我们需尽量把它们放在页面的底部,这样一方面能顺序显示,另方面可达到最大的并行下载 脚本阻塞并行下载数量，HTTP/1.1 规范建议浏览器每个主机的并行下载数不超过2 个。 因此如果您把图像文件分布到多台机器的话,就可以达到超过2个的并行下载 但是当脚本文件下载时,浏览器不会启动其他的并行下载,甚至其他主机的下载也不启动 所以直接将脚本放在底部 避免 CSS 表达式 CSS 表达式是功能强大的(同时也是危险的)用于动态设置CSS属性的方式 直接以明确的数值来写，不写表达式 如果必须动态设置的话,可使用事件处理函数代替 把JavaScript和CSS放到外部文件中 在现实世界中,使用外部文件会加快页面显示速度,因为外部文件会被浏览器缓存 减少DNS查询次数 DNS用于映射主机名和IP地址,一般一次解析需要 20~120 毫秒 把内容分布到至少2 个,最多4个不同的主机名上 最小化JavaScript代码 最小化JavaScript代码指在JS代码中删除不必要的字符,从而降低下载时间 两个流行的工具是JSMin 和YUI Compressor 它通过删除注释和空格来减少源码大小,同时它还可以对代码进行混淆处理。 作为混淆的一部分,函数名和变量名被替换成短的字符串,这使得代码更紧凑,同时也更难读,使得难于被反向工程 Dojo Compressor (ShrinkSafe)是最常见的混淆工具 内嵌的脚本代码也应该被最小化 避免重定向 重定向功能是通过301和302这两个HTTP状态码完成的 在 Apache 下,可以通过Alias,mod_rewrite或 DirectorySlash 等方式来解决该问题 删除重复的脚本文件 在一个页面中包含重复的JS脚本文件会影响性能,即它会建立不必要的HTTP请求和额外的JS执行 一个避免重复的脚本文件的方式是使用模板系统来建立脚本管理模块。。 除了防止 重复的脚本文件外,该模块还可以实现依赖性检查和增加版本号到脚本文件名中,从而实现超长的过期时间 配置 ETags ETags 是用于确定浏览器缓存中元素是否与 Web server 中的元素相匹配的机制, 它是比 last-modified date 更灵活的元素验证机制 如果您未用到 ETags 系统提供的灵活的验证机制,最好删除 ETag。删除 ETag会减少 http response 及后续请求的 HTTP 头的大小 缓存 Ajax 性能优化法则同样适用于web 2.0 应用。提高Ajax的性能最重要的方式是使得其response 可缓存 总结说实话，以上的十四条，有些是我没看懂的，例如Expires Header和配置 ETags，先记录在这里，其实依照我对Web前端开发的理解，也总结出一些优化原则，也可能与上面的有些重复，但可能会更好理解一些 我的优化原则位置 css一般放在头部 脚本文件一般放在底部 页面分离 将js或者css或者json文件等分离到单独的页面 删除多余 删除多余脚本 删除多余函数，无用变量名等 压缩 最小化css、js文件等 图片处理 可以使用icon字体图标代替的图片尽量使用icon字体图标 尽量用css3代替， 比如说要实现修饰效果，如半透明、边框、圆角、阴影、渐变等 优化图片格式为常用格式 精灵图 用CSS或JavaScript实现预加载 在保证最不失真的情况下尽可能压缩图像文件的大小]]></content>
      <tags>
        <tag>雅虎十四条性能优化原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中sessionStorage 、localStorage 和 Cookie]]></title>
    <url>%2Fjavascript%E4%B8%ADsessionStorage-%E3%80%81localStorage-%E5%92%8C-cookie%2F</url>
    <content type="text"><![CDATA[javascript中sessionStorage 、localStorage 和 Cookie 参考文章：JS 详解 Cookie、 LocalStorage 与 SessionStorage 下面是个人总结内容： 相同点 用于浏览器端存储的缓存数据 不同点 特性 Cookie localStorage sessionStorage 数据的生命期 可设置的失效时间，到达时间自动过期 除非被清除，否则永久保存 仅用于当前会话，浏览器关闭，立即被清除 存放数据大小 4K左右 一般为5MB 一般为5MB 与服务器端通信 携带在HTTP头中，数据会发送到服务器端，可能造成宽带浪费 只在客户端，不参与和服务端的通信 只在客户端，不参与和服务端的通信 易用性 需程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 应用场景Cookie： 1. 最好精简，因为本身存放数据大小很小 2. 常用于判断用户登录，对于登录过的用户，浏览器会插入一个唯一的标识，当下次用户需要登录，只要读取到这个值，就能判断当前用户是否登录了 localStorage: 1. 购物车管理工作，一些产生的本地数据用以完成数据持久化 sessionStorage： 多页面表单，按步骤引导用户填写 安全性 Cookie、localStorage 和 sessionStorage三者，只要打开控制台，都能看到这三者存放的数据的，并且能够随意修改，所以会产生风险 而sessionStorage使用了session加密，这样用户看到的数据都是经过加密处理过的，会难以获取正确的标识 但是对于localStorage或者Cookie的数据，就可以被肆意妄为的修改或者伪造了 上面是我个人的一些理解，文章中还提到了XSS注入的风险，关于XSS注入为此我专门查了些文档，推荐一篇自我感觉写的相当详细的Web安全测试之XSS Web Storage AND Cookie 前者存储空间更大 前者存储内容不会发送到服务器，防止造成宽带浪费 接口丰富 独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，避免造成数据混乱 每个特定的域名下最多生成20个cookie sessionStorage用于本地存储一个会话存储，关闭会话，随之销毁 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的 Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地存储数据而生 一些基本操作 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 setItem存储value 用于存储对象格式的数据 12sessionStorage.setItem("key", "value"); localStorage.setItem("site", "qqqww"); getItem获取value 获取指定关键字段key本地存储的值 12var value = sessionStorage.getItem("key"); var site = localStorage.getItem("site"); removeItem删除key 删除指定关键字段key本地存储的值 12sessionStorage.removeItem("key"); localStorage.removeItem("site"); clear清除所有的key/value 清除所有本地的key/value 12sessionStorage.clear(); localStorage.clear(); 其他操作方法：点操作和[ ] web Storage不但可以用自身的setItem`,getItem`等方便存取，也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储 12345var storage = window.localStoragestorage.key1 = "hello"storage["key2"] = "world" console.log(storage.key1)console.log(storage["key2"]) 遍历 localStorage和sessionStorage的key和length属性实现遍历 sessionStorage和localStorage提供的key()和length可以方便的实现存储的数据遍历 123456var storage = window.localStorage;for(var i=0, len=storage.length; i&lt;len;i++)&#123; var key = storage.key(i); var value = storage.getItem(key); console.log(key + "=" + value); &#125;]]></content>
      <tags>
        <tag>sessionStorage 、localStorage 和 cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中跨域问题]]></title>
    <url>%2Fjavascript%E4%B8%AD%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[javascript中跨域问题 由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域 产生跨域的情况 网络协议不同，如http协议访问https协议 端口不同，如80端口访问8080端口 域名不同，如qqqww.com访问baidu.com 子域名不同，如abc.qqqww.com访问def.qqqww.com 域名和域名对应ip，如www.qqqww.com访问192.168.0.112 跨域请求资源的方法proxy代理定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。 实现方法：通过nginx代理 注意： 如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功 CORS定义和用法：CORS (Cross-Origin Resource Sharing) 是现代浏览器支持跨域资源请求的一种最常用的方式。 使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下： 123456res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html; charset=UTF-8&quot;, &quot;Access-Control-Allow-Origin&quot;:&apos;http://localhost&apos;, &apos;Access-Control-Allow-Methods&apos;: &apos;GET, POST, OPTIONS&apos;, &apos;Access-Control-Allow-Headers&apos;: &apos;X-Requested-With, Content-Type&apos;&#125;); jsonp定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下） 特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。 实例： 1234567891011&lt;script&gt; function testjsonp(data) &#123; console.log(data.name); // 获取返回的结果 &#125;&lt;/script&gt;&lt;script&gt; var _script = document.createElement(&apos;script&apos;); _script.type = &quot;text/javascript&quot;; _script.src = &quot;http://localhost:8888/jsonp?callback=testjsonp&quot;; document.head.appendChild(_script);&lt;/script&gt; 缺点： 1、这种方式无法发送post请求（这里） 2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的闭包]]></title>
    <url>%2Fjavascript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[javascript中的闭包 当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包 实例 根据作用域链的规则，底层作用域没有声明的变量，会向上一级查找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined，这里明显count 是函数内部的flag2 的那个count 1234567891011var count = 10 //全局作用域 标记为flag1function add () &#123; var count = 0 //函数全局作用域 标记为flag2 return function()&#123; count += 1 //函数的内部作用域 alert(count) &#125;&#125;var s = add()s() //输出1s() //输出2 ##变量的作用域 变量的作用域分类：全局变量和局部变量 特点： 函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量 函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量 使用闭包的注意点： 滥用闭包，会造成内存泄漏：由于标识为flag2的count被闭包所引用，所以在内存中不会被回收，造成内存泄漏 会改变父函数内部变量的值：所以，如果把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值]]></content>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中数组操作]]></title>
    <url>%2Fjavascript%E4%B8%AD%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[javascript中Array相关的属性和方法Array 对象属性constructor : 返回对创建此对象的数组函数的引用 1234var test=new Array()if (test.constructor==Array)&#123; document.write("This is an Array")&#125; length 设置或返回数组中元素的数目。 prototype 可以向构造函数的原型对象添加属性和方法 Array对象方法###concat() 连接两个或更多的数组，并返回结果 1234var arr = [1,2,3,4];var arr2 = [5,6,7,8];var arr3 = arr.concat(arr2);console.log(arr3); // 连接之后返回的数组为：[1, 2, 3, 4, 5, 6, 7, 8] join()把数组的所有元素放入一个字符串，元素通过指定的分隔符进行分隔 123var arr = ['xiao','lin','qiqi','mingtian'];var arr2 = arr.join(',');console.log(arr2); // 根据','隔开返回的字符串为："xiao,lin,qiqi,mingtian" pop() 删除并返回数组的最后一个元素 1234var arr = [2,3,4,5];var arr2 = arr.pop();console.log(arr2); // 删除的数组的最后一个元素为：5console.log(arr); // 删除元素之后的数组为：[2, 3, 4] ###shift() 删除并返回数组的第一个元素 1234var arr = [2,3,4,5];var arr2 = arr.shift();console.log(arr2); // 删除的数组的第一个元素为：2console.log(arr); // 删除元素之后的数组为：[3, 4，5] ###push() 向数组的末尾添加一个或更多元素，并返回新的长度 1234var arr = [2,3,4,5];var arr2 = arr.push(6);console.log(arr2); // 返回的数组长度：5 console.log(arr); // [2, 3, 4, 5, 6] unshift()向数组的开头添加一个或更多元素，并返回新的长度 1234var arr = ['xiao','ming','qiqi','aiming'];var arr1 = arr.unshift('lang');console.log(arr1); // 返回的数组的长度： 5console.log(arr); //向数组开头添加元素返回的结果：["lang", "xiao", "ming", "qiqi", "aiming"] reverse()颠倒数组中元素的顺序 123var arr = [2,3,4,5];arr.reverse();console.log(arr); // [5, 4, 3, 2] slice()从某个已有的数组返回选定的元素 1234var arr = [2,3,4,5];var arr2 = arr.slice(1,3);console.log(arr2); // 截取区间返回的数组为：[3, 4]console.log(arr); // [2, 3, 4, 5] sort()对数组的元素进行排序 1234567891011121314151617// 借助排序函数，实现数值由小到大排序function sortNumber(a,b)&#123; return a - b&#125;var arr = [23,30,42,5];var arr2 = arr.sort(sortNumber);console.log(arr2); // [5, 23, 30, 42]console.log(arr); // [5, 23, 30, 42]// 借助排序函数，实现数值由大到小排序function sortNumber(a,b)&#123; return b - a&#125;var arr = [23,30,42,5];var arr2 = arr.sort(sortNumber);console.log(arr2); // [42, 30, 23, 5]console.log(arr); // [42, 30, 23, 5] splice()删除元素，并向数组添加新元素。 123456789// 创建一个新数组，并向其添加一个元素var arr = [1,2,3,4];arr.splice(2,0,5);console.log(arr); // [1, 2, 5, 3, 4]// 删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素：var arr = [1,2,3,4];arr.splice(2,1,5);console.log(arr); // [1, 2, 5, 4] toSource()返回该对象的源代码 123456789101112// 浏览器支持// 只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。&lt;script type="text/javascript"&gt;function employee(name,job,born)&#123; this.name=name; this.job=job; this.born=born;&#125;var bill = new employee("Bill Gates","Engineer",1985);document.write(bill.toSource());&lt;/script&gt;// 输出：(&#123;name:"Bill Gates", job:"Engineer", born:1985&#125;) toString()把数组转换为字符串，并返回结果 123var arr = ['xiao','ming','qiqi','aiming'];arr.toString();console.log(arr); // ["xiao", "ming", "qiqi", "aiming"] ###toLocaleString() 把数组转换为本地数组，并返回结果 123var arr = ['xiao','ming','qiqi','aiming'];arr.toLocaleString();console.log(arr); // ["xiao", "ming", "qiqi", "aiming"] valueOf()返回数组对象的原始值 123var arr = ['xiao','ming','qiqi','aiming'];arr.valueOf('lang');console.log(arr); // ["xiao", "ming", "qiqi", "aiming"] Array部分方法实现数组元素去重方法一： 思路： 1. 定义一个 json 对象 2. 遍历数组，将 arr[i] 作为 json 的键 3. 若 不重复，则给对应 arr[i] 的键值为 1 作为后面判断的标识，并 push 到新数组 arr1 中，若重复，则删除 123456789var arr = [1, 2, 3, 2, 1, 5, 6, 3, 3, 2, 1, 7, 9, 8,6] var arr1 = [] var json = &#123;&#125; for (var i = 0; i &lt; arr.length; i++) &#123; if (!json[arr[i]]) &#123; json[arr[i]] = 1 arr1.push(arr[i]) &#125; &#125; 方法二： 思路： 定义一个新数组 arr1 如果这个新数组中没有这个元素，则 push 1234567var arr = [1, 2, 3, 2, 1, 5, 6, 3, 3, 2, 1, 7, 9, 8,6] var arr1 = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (arr1.indexOf(arr[i]) &lt; 0) &#123; arr1.push(arr[i]) &#125; &#125; 方法三：filter filter的接收回调，可以有多个参数回调可以接收三个参数，第一个是数组中的元素，第二个是位置，第三个是数组本身 利用filter过滤器，总是返回元素第一个位置 去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了 12345var arr = [1, 2, 3, 2, 1, 5, 6, 3, 3, 2, 1, 7, 9, 8,6] var arr1 = arr.filter(function(ele, index, self) &#123; return self.indexOf(ele) === index &#125;) console.log(arr1) 数组最值方法一：Math.max.apply And Math.min.apply 1234567方法一：Math.max.apply var iMax = 0 var iMin = 0 var arr = [1, 268, 5, 4, 9, 0, 68] iMax = Math.max.apply(null, arr) iMin = Math.min.apply(null, arr) console.log(iMax, iMin) 方法二：：Math.max.call And Math.min.call 123456var iMax = 0 var iMin = 0 var arr = [1, 268, 5, 4, 9, 0, 68] iMax = Math.max.call(null, 1, 268, 5, 4, 9, 0, 68) iMin = Math.min.call(null, 1, 268, 5, 4, 9, 0, 68) console.log(iMax, iMin) 方法三：循环比较 123456789101112var iMax = 0var iMin = 0var arr = [1, 268, 5, 4, 9, 0, 68]for (var i = 0; i &lt; arr.length; i++) &#123; if (iMax &lt; arr[i]) &#123; iMax = arr[i] &#125; if (iMin &gt; arr[i]) &#123; iMin = arr[i] &#125;&#125;console.log(iMax, iMin) 数组排序sort原理：在不带参数的情况下sort()方法默认会将数组元素当作string类型来升序排序,根据它们的unicode码从小到大依次排列，如果想按照自己的条件进行排序，需要传一个比较函数 1234567891011var arr = [1, 268, 5, 4, 9, 0, 68] // 从小到大 arr.sort(function (a, b) &#123; return a - b &#125;) console.log(arr) // 从大到小 arr.sort(function (a, b) &#123; return b - a &#125;) console.log(arr) 冒泡排序思路：每次比较相邻的两个数，如果后一个比前一个小，换位置。如果要实现由大到小排序，使用reverse()即可； 1234567891011121314var a = [1, 268, 5, 4, 9, 0, 68, 67, 69, 96, 14, 78, 100, 25, 42, 23, 32, 68, 89, 98, 1] var temp = 0 for (var i = 0; i &lt; a.length; i++) &#123; for (var j = 0; j &lt; a.length - i; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; temp = a[j] a[j] = a[j + 1] a[j + 1] = temp &#125; &#125; &#125; var b = a.reverse() console.log(a) 快速排序思路：采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边。 1234567891011121314151617181920var arr = [1, 268, 5, 4, 9, 0, 68, 67, 69, 96, 14, 78, 100, 25, 42, 23, 32, 68, 89, 98, 1]function quickSort(arr) &#123; if(arr.length == 0) &#123; return []; // 返回空数组 &#125; var arrL = [] var arrR = [] var index = Math.floor(arr.length / 2) var arrM = arr.splice(index, 1) // 返回被删除的数 for (var i = 0; i &lt; arr.length; i++) &#123; if (arrM &gt; arr[i]) &#123; arrL.push(arr[i]) &#125; else &#123; arrR.push(arr[i]) &#125; &#125; // console.log(arrL.concat(arrR)) return quickSort(arrL).concat(arrM, quickSort(arrR))&#125;console.log(quickSort(arr)) 数组翻转(非reverse)方法一： 删除数组最后一个元素并返回被删除的元素 12345678var arr = [1,2,3,4];var arr2 = [];while(arr.length) &#123; var num = arr.pop(); //删除数组最后一个元素并返回被删除的元素 arr2.push(num);&#125;console.log(arr2);// [4, 3, 2, 1] 方法二： 删除数组第一个元素并返回被删除的元素 1234567var arr = [1,2,3,4];var arr2 = [];while(arr.length)&#123; var num = arr.shift(); //删除数组第一个元素并返回被删除的元素 arr2.unshift(num);&#125;console.log(arr2);]]></content>
      <tags>
        <tag>Array相关的属性和方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中字符串操作]]></title>
    <url>%2Fjavascript%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[javascript中字符串操作 String : 1. javascript检测字符串 2. javascript去除字符串空格 3. URL中查询字符串中的参数 4. javascript字符串的常用函数 检测string类型方法一：typeof 123function isString (str) &#123; return typeof (str) === 'string' ? true : false&#125; 方法二：constructor 123function isString (str) &#123; return str.constructor === String ? true : false&#125; 去除字符串空格方法一：replace() 使用replace匹配正则，\s匹配任何空白字符,包括空格、制表符、换页符等等 12345var str = ' aaaa bcs dsda 'str = str.replace(/\s*/g, '') // 去除所有空格str = str.replace(/^\s|\s$/g, '') // 去除两头空格str = str.replace(/^\s/g, '') // 去除左空格str = str.replace(/\s$/g, '') // 去除右空格 方法二：trim() 局限：无法去除中间的空格 12var str = ' aaaa bcs dsda 'str = str.trim() // aaaa bcs dsda 获取URL中查询字符串参数split 测试地址为：http://www.runoob.com/jquery/misc-trim.html?channelid=12333&amp;name=xiaoming&amp;age=23 123456// window.location.href = "http://www.runoob.com/jquery/misc-trim.html?channelid=12333&amp;name=xiaoming&amp;age=23"var a = window.location.hrefvar b = a.split('?') // b[1] = "channelid=12333&amp;name=xiaoming&amp;age=23"var c = b[1].split('&amp;')for (var i = 0; i &lt; c.length; i++) &#123; console.log(c[i].split('=')) &#125;// 此时可遍历出 ? 后面参数的每一项 其他常用字符串函数 concat() – 将两个或多个字符的文本组合起来，返回一个新的字符串。 indexOf() – 返回字符串中一个子串第一处出现的索引。如果没有匹配项，返回 -1 。 charAt() – 返回指定位置的字符。 lastIndexOf() – 返回字符串中一个子串最后一处出现的索引，如果没有匹配项，返回 -1 。 match() – 检查一个字符串是否匹配一个正则表达式。 substr() 函数 – 返回从string的startPos位置，长度为length的字符串 substring() – 返回字符串的一个子串。传入参数是起始位置和结束位置。 slice() – 提取字符串的一部分，并返回一个新字符串。 replace() – 用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 search() – 执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。 split() – 通过将字符串划分成子串，将一个字符串做成一个字符串数组。 length – 返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。 toLowerCase() – 将整个字符串转成小写字母。 toUpperCase() – 将整个字符串转成大写字母。 看下面控制台输出结果：]]></content>
      <tags>
        <tag>javascript字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中typeof与instanceof的区别]]></title>
    <url>%2Fjavascript%E4%B8%ADtypeof%E4%B8%8Einstanceof%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[#typeof VS instanceof 相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的 区别：前者判断数据类型较多，后者判断一个变量是否属于某个对象实例 typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。 细节： (1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。 (2)、typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。 (3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。 Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。 实例演示： 123var a = new Array(); alert(a instanceof Array); // truealert(a instanceof Object) // true 如上，会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为 Array 是 object 的子类。 123function test()&#123;&#125;;var a = new test();alert(a instanceof test) // true]]></content>
      <tags>
        <tag>typeof VS instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中call与apply的区别]]></title>
    <url>%2Fjavascript%E4%B8%ADcall%E4%B8%8Eapply%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[javascript中call与apply的区别JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为： 12345/*apply()方法*/function.apply(thisObj[, argArray])/*call()方法*/function.call(thisObj[, arg1[, arg2[, [,...argN]]]]); ##它们各自的定义 apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。 call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。 ##它们的共同之处： 都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。 它们的不同之处apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。 call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。 ##示例 （1）基本用法 12345678910111213function add(a,b)&#123; return a+b; &#125;function sub(a,b)&#123; return a-b; &#125;var a1 = add.apply(sub,[4,2]); //sub调用add的方法var a2 = sub.apply(add,[4,2]);alert(a1); //6 alert(a2); //2/*call的用法*/var a1 = add.call(sub,4,2); （2）实现继承 12345678910111213141516function Animal(name)&#123; this.name = name; this.showName = function()&#123; alert(this.name); &#125; &#125;function Cat(name)&#123; Animal.apply(this,[name]); &#125;var cat = new Cat("咕咕");cat.showName();/*call的用法*/Animal.call(this,name); （3）多重继承 12345678910111213141516171819202122function Class10()&#123; this.showSub = function(a,b)&#123; alert(a - b); &#125; &#125;function Class11()&#123; this.showAdd = function(a,b)&#123; alert(a + b); &#125; &#125;function Class12()&#123; Class10.apply(this); Class11.apply(this); // Class10.call(this); //Class11.call(this); &#125;var c2 = new Class12();c2.showSub(3,1); //2c2.showAdd(3,1); //4 apply的一些其他巧妙用法（1）Math.max 可以实现得到数组中最大的一项： 因为Math.max不支持Math.max([param1,param2])也就是数组，但是它支持Math.max(param1,param2...)，所以可以根据apply的特点来解决 var max=Math.max.apply(null,array)，这样就轻易的可以得到一个数组中的最大项（apply会将一个数组转换为一个参数接一个参 数的方式传递给方法） 这块在调用的时候第一个参数给了null，这是因为没有对象去调用这个方法，我只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个null过去。 用这种方法也可以实现得到数组中的最小项：Math.min.apply(null,array) （2）Array.prototype.push可以实现两个数组的合并 同样push方法没有提供push一个数组，但是它提供了push(param1,param2...paramN)，同样也可以用apply来转换一下这个数组，即： 123var arr1=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);var arr2=new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;);Array.prototype.push.apply(arr1,arr2); //得到合并后数组的长度，因为push就是返回一个数组的长度 也可以这样理解，arr1调用了push方法，参数是通过apply将数组转换为参数列表的集合 通常在什么情况下，可以使用apply类似Math.max等之类的特殊用法： 一般在目标函数只需要n个参数列表，而不接收一个数组的形式，可以通过apply的方式巧妙地解决这个问题 其实看上面两张图打印的结果不难发现，我们的apply和call的第一个参数位置就是调用者，假如arr1在第一个参数位置，就是arr1调用了xxxx,那么相当于arr1此时拥有了xxx的方法，我们举个例子，例如Array.prototype.push.apply(arr1,arr2)就是arr1调用了Array.prototype.push方法]]></content>
      <tags>
        <tag>call与apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript对象冒充实现继承]]></title>
    <url>%2Fjavascript%E5%AF%B9%E8%B1%A1%E5%86%92%E5%85%85%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[javascript中的继承面向对象的基本特征有：封闭、继承、多态 在JavaScript中实现继承的方法： 原型链（prototype chaining） call()、apply() 混合方式(prototype和call()/apply()结合) 对象冒充 ##javascript对象冒充实现继承 本质上就是改变this指向 对象冒充原理: 构造函数使用this关键字给所有属性和方法赋值.因为构造函数只是一个函数,所以可使ClassA的构造方法称为ClassB的方法,然后调用它. ClassB就会收到ClassA的构造方法中定义的属性和方法. 例子: 1234567891011121314151617181920function ClassA(name)&#123; this.name=name; this.getName=function()&#123; return this.name; &#125;&#125;function ClassB(name,password)&#123; this.ClassA=ClassA; this.ClassA(name); delete this.ClassA; this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125;var b =new ClassB('wwww','1123');document.write(b.getName()); 经过调试,我们可以看到: 变量b中已经包含了ClassA中定义的方法. 代码理解: 在ClassB中,this.ClassA(name)等价于以下代码: 1234this.name=name; this.getName=function()&#123; return this.name; &#125; 所以将ClassA函数中的代码复制过来,即:ClassB中的代码如下: 123456789101112131415function ClassB(name,password)&#123; this.ClassA=ClassA; this.name=name; this.getName=function()&#123; return this.name; &#125; delete this.ClassA; this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125; 然后通过delete this.ClassA之后,ClassB中的实际代码如下: 1234567891011function ClassB(name,password)&#123; this.name=name; this.getName=function()&#123; return this.name; &#125; this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125; 从而实现了对象冒充. 注意: 对象冒充可以支持多重继承,也就是说一个类可以继承多个类.例子如下: 123456789function ClassC()&#123; this.ClassX=ClassX; this.ClassX(); delete this.ClassX; this.ClassY=ClassY; this.ClassY(); delete this.ClassY;&#125; 这样就ClassC就实现了继承自ClassX,ClassY.但此处存在一个弊端: 若ClassX和ClassY中存在两个同名的变量或方法,则ClassY会覆盖ClassX中的变量或方法. 此外: 我们还可以通过call()和apply()方法实现对象冒充. call方法 它的第一个参数用做this的对象,其他参数都直接传递给函数自身.我们来看下面这个小例子: 1234567891011function ShowColor(param1,param2)&#123; this.getColor=function()&#123; document.write(this.color+"&lt;br/&gt;Two Params : "+param1+" ; "+param2); &#125;&#125;var obj = new Object;obj.color='Red';ShowColor.call(obj,"pm1",'pm2');obj.getColor(); 运行此段代码后,我们发现页面上显示为: 解释: ShowColor方法是在对象外定义的,调用call时,它将第一个参数,也就是将ClassA的this指向了obj,将后面的参数”pm1”传递给了param1,’pm2’传递给了param2. 123var obj = new Object;obj.color='Red';ShowColor.call(obj,"pm1",'pm2'); 也就实现了以下效果: 我们将上面代码中的obj.color=’Red’给注释起来,再运行代码,结果如下: 原因是obj并没有color属性,而obj.getColor()方法中需要this.color,即obj.color,所以会出现undefined的结果. 我们再来看如何利用call来实现对象冒充,继续以刚才的ClassA,ClassB为例: 1234567891011121314151617181920function ClassA(name)&#123; this.name=name; this.getName=function()&#123; return this.name; &#125; &#125;function ClassB(name,password)&#123; //this.ClassA=ClassA; //this.ClassA(name); //delete this.ClassA; ClassA.call(this,name); this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125;var b = new ClassB('www','111');b.getPassword(); 调试效果: 解释: 此处的ClassA.call(this,name); 即将ClassA的this指向了ClassB的this.从而实现了对象冒充. apply方法 apply方法有两个参数,用作this的对象和要传传递给函数的参数的数组. 例子: 1234567891011function ShowColor(param1,param2)&#123; this.getColor=function()&#123; document.write(this.color+"&lt;br/&gt;Two Params : "+param1+" ; "+param2); &#125;&#125;var obj = new Object;obj.color='Red';ShowColor.apply(obj,new Array("pm1",'pm2'));obj.getColor(); 此方法可以被用于对象冒充: 123456789101112131415161718192021function ClassA(name)&#123; this.name=name; this.getName=function()&#123; return this.name; &#125; &#125;function ClassB(name,password)&#123; //this.ClassA=ClassA; //this.ClassA(name); //delete this.ClassA; ClassA.apply(this,new Array(name)); this.password=password; this.getPassword=function()&#123; return this.password; &#125;&#125;var b = new ClassB('www','111');b.getPassword(); 调试效果: 原型继承 Javascript对象的创建和继承使用了一套特别的模式,称作原型式继承. 原理是:对象的构造函数可以从其他对象中继承方法,它创建出一个原型对象后,所有其他的新对象都可以基于这个原型对象来构建. 原型本身并不会从其他原型或者构造函数中继承属性,而属性都是从实际对象那里继承过来的. 例1: 1234567891011121314151617function Person(name)&#123; this.name=name;&#125;Person.prototype.GetName=function()&#123; return this.name;&#125;function User(name,password)&#123; this.name = name; this.password = password;&#125;User.prototype = new Person();User.prototype.GetPassword=function()&#123; return this.password;&#125; 解释: User.prototype = new Person();这句话如何理解呢?User是对User对象构造函数的引用,new Person()使用person构造函数创建了一个Person对象,然后把Person对象的原型置为这个操作的结果.也就是说,当每次new User()时,得到的新User对象都会带有Person对象的所有方法]]></content>
      <tags>
        <tag>冒充对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript垃圾回收机制与内存管理]]></title>
    <url>%2Fjavascript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[垃圾回收机制与内存管理 Js具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。 什么是垃圾回收机制 垃圾回收机制（GC:Garbage Collection）： JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码在执行环境过程中使用的内存。垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性的执行这一操作。 垃圾回收机制的作用内存释放： 将某个不再被使用的变量所占用的内存释放掉，是为了不让内存总是被消耗而被没有释放，导致整个系统无法支持更为庞大的运算 垃圾回收机制不是总是那么高效，其不是总在运行，因此有时需要我们人为的释放被占用的内存，从而使程序能够支持更为庞大的运算，能够接受更为巨量的数据运算。 垃圾回收机制的原理垃圾收集机制的原理： 找出那些不再继续使用的变量，然后释放其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行 实例123456789101112131415function fn1 () &#123; var obj = &#123; name: 'zhangsan', age: 10 &#125;&#125;function fn2 () &#123; var obj = &#123; name: 'lisi', age: 11 &#125; return obj&#125;var a = fn1() var b = fn2() fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放 ##垃圾回收机制的标记策略 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略：标记清除、引用计数。 ###标记清除 1. 当变量进入环境时，将其标记为“进入环境”，当变量离开环境时，将其标记为“离开环境”（常用） 2. 某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量 3. 到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同 ###引用计数 跟踪记录每个值被引用的次数 当声明一个变量a并将一个引用类型的值赋给该变量时，这个值引用次数就是1 如果同一个引用类型的值又被赋给另一个变量b，则该值的引用次数加1，相反，如果包含这个值引用的变量a又取得了另一个值（也就是前面的引用被覆盖，不再引用前面那个值），则这个值的引用次数减1。 当这个值的引用次数变成0时，则说明没有办法再访问这个值，因而就可以将其占用的内存空间回收回来 少见，几乎不用，除了早版IE的元素JS，因为会出现循环引用的问题 1`var` `a = obj1;``var` `b = boj1;``//这是obj1的引用次数应该为2``var` `a = obj2;``//这是obj1的引用次数为1，obj2的引用次数也为1` 垃圾回收机制与内存管理 垃圾回收器是周期运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。触发方式的改善很重要 堆和栈 堆和栈空间分配区别： 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈 堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表 堆和栈空间存放数据类型的区别： 栈：基本类型是：Undefined/Null/Boolean/Number/String，基本类型的值存在内存中，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副 堆：引用类型：object，Array，function等，引用类型的值是对象类型，保存在堆内存中 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象 js操作对象就是在操作对象的引用，而不是在操作实际的对象 堆和栈缓存方式区别： 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放 堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些 堆和栈数据结构区别： 堆（数据结构）：堆可以被看成是一棵树，如：堆排序 栈（数据结构）：一种先进后出的数据结构 管理内存 虽然说使用具备垃圾回收机制的语言写程序，开发人员一般不必操心内存管理的问题。但是JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同的，其中最主要的问题之一，就是出于对安全方面考虑，防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃，所以分配给Web浏览器的内存数量通常比分配给桌面应用的程序少 内存泄漏 虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏 那么什么情况会引起内存泄漏呢？ 意外的全局变量引起的内存泄漏 123function fn () &#123; fn1 = 'xxxxxx';//fn 成为一个全局变量，不会被回收&#125; 原因：全局变量不会被回收 解决：使用严格模式(因为严格模式定义的变量都有其单独的作用域) 闭包引起的内存泄漏 123456var fn = (function()&#123; var fn1 = 'xxxxxx'; // 被闭包所引用，不会被回收 return function()&#123; console.log(fn1); &#125;&#125;)() 原因：闭包可以维持函数内部局部变量，使其得不到释放 解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对DOM的引用 DOM清空或删除时，事件未清除导致的内存泄漏 案例一： 12&lt;div id="container"&gt; &lt;/div&gt; 123$('#container').bind('click', function()&#123; console.log('click');&#125;).remove(); 案例二： 123&lt;div id="myDiv"&gt; &lt;input type="button" value="Click me" id="myBtn"&gt;&lt;/div&gt; 1234var btn = document.getElementById("myBtn");btn.onclick = function()&#123; document.getElementById("myDiv").innerHTML = "Processing...";&#125; 原因：虽然DOM被清空或者删除了，但是对象中还存在对DOM的引用 解决一：zepto 和 原生 js 下，#container dom 元素，还在内存里 jquery 的 empty 和 remove 会帮助开发者避免这个问题 123$('#container').bind('click', function()&#123; console.log('click');&#125;).off('click').remove(); 解决二：手动删除 12345var btn = document.getElementById("myBtn");btn.onclick = function()&#123; btn.onclick = null; document.getElementById("myDiv").innerHTML = "Processing...";&#125; 子元素存在引用引起的内存泄漏 原因：上图 黄色是指直接被 js变量所引用，在内存里 红色是指间接被 js变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的 子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除 解决：手动删除 被遗忘的定时器或者回调引起的内存泄漏 原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom 解决：手动删除定时器 总结 占用最少的内存可以让页面获得更好的性能，而优化内存占用最佳方式，就是执行中的代码只保留必要的数据（占用必要的内存）。 一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动解除引用。 解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾回收器下次运行时将其回收 12345678function getPerson (name) &#123; var privatePerson = new Object() privatePerson.name = name return privatePerson&#125;var globalPerson = getPerson('zhangsan')// 此时调用了函数getPerson，使得返回的对象privatePerson会被全局变量globalPerson所指向，所以该块内存并不会被释放，可以手动`globalPerson = null`来释放内存]]></content>
      <tags>
        <tag>垃圾回收机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github上contributions统计错误]]></title>
    <url>%2Fgithub%E4%B8%8Acontributions%E7%BB%9F%E8%AE%A1%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[为什么你的github上contributions那么少或者不更新前段时间还没注意，今天去看了下我的contributions，结果令我惊讶，统计的只有20个，然后我去查了什么会产生contributions,结果更匪夷所思，上面明确室友写到自己的仓库自己的commit是会产生contributions的，这么一想，我仅仅commit了也至少几百次吧，怎么就只有20呢？下面是研究和解决问题过程~~ 详情见官网https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/，如果对官网纯英文理解不深，请看我本篇人类的语言 基本概念想必能搜到这文章的老铁们，大概是对github已经有一定的了解了，那么什么是contributions呢？ 下面来自官网的官方说法： Your GitHub profile shows off your pinned repositories as well as a graph of your repository contributions over the past year. 人类的语言： 就是在github库（repository）中所做的贡献统计，那么怎么才能有贡献呢？ 什么操作会统计在contributionsIssues 和 pull requests 需要满足： 1. 一年之内 2. 独立的仓库，不能是`fork`来的 commits 需要满足： 一年之内 commits使用的email地址是与你的Github账号相关联的 独立仓库，不是fork来的 这些commits是在 默认分支（通常是master） 在gh-pages分支(包含 Project Pages sites 的仓库) Contributions未被Github计入的几个常见原因 进行Commits的用户没有被关联到你的Github帐号中，可能是github邮箱设置错误，或者commit用的邮箱和github主邮箱不一致 不是在这个版本库的默认分支进行的Commit 仓库是Fork仓库，不是独立仓库 排查这里以邮箱错误为例，因为我的也是这个原因，直接把处理过程写上了 查询commit的邮箱 将你的没有统计commits到contributions中的仓库版本历史记录都克隆到本地，并cd到本地仓库根目录下，git log查询历史记录邮箱 123git clone --bare "这里写你的仓库地址"cd 克隆到本地的文件夹的名字（一般是xxx.git）git log // 查询以前commit的时候用的邮箱 去github个人资料中看自己的主邮箱 登录，右上角头像点击有个菜单，菜单里有个settings点击，左边找到Emails,看下图中英文 Primary email address formanW@aliyun.com will be used for account-related notifications and for web-based GitHub operations (e.g. edits and merges). 翻译成汉语： 主电子邮件地址 formanW@aliyun.com将用于与帐户相关的通知和基于网络的GitHub操作(例如编辑和合并)。 比对下你commit的邮箱和主电子邮箱是否一样，不一样的话，就是这原因无疑了 解决方案 在你刚才克隆下来的仓库中新建一个文件script.sh，将如下代码粘贴进去 12345678910111213141516#!/bin/shgit filter-branch --env-filter 'OLD_EMAIL="旧的Email地址"CORRECT_NAME="正确的用户名"CORRECT_EMAIL="正确的邮件地址"if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]then export GIT_COMMITTER_NAME="$CORRECT_NAME" export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"fiif [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]then export GIT_AUTHOR_NAME="$CORRECT_NAME" export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"fi' --tag-name-filter cat -- --branches --tags 直接在本地仓库中，双击这个script.sh脚本运行，会弹出来一个控制面板，上面就是更新的历史记录 完成2步骤之后，在本地仓库根目录中运行以下命令上传正确的历史记录到giehub 1git push --force --tags origin 'refs/heads/*' 删掉刚才克隆的下来的本地仓库 至此，去你的github contributions看看，统计的数量就正常了 正确设置github邮箱和用户名12git config --global user.email "你的邮件地址"git config --global user.name "你的Github用户名" 设置之后，就可以开心的进行以后的github提交了，妈妈再也不担心github没贡献了]]></content>
      <tags>
        <tag>contributions统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次hexo生成静态文件报错]]></title>
    <url>%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1hexo%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[hexo常见错误hexo d 生成HTML文件报错###错误代码： FATAL Something&#39;s wrong. Maybe you can find the solution here: http://hexo.io/do cs/troubleshooting.html Template render error: (unknown path) [Line 1, Column 12] unexpected token: }} 问题原因：看到其中有一句Template render error，模板渲染错误 看到渲染错误，我的md文档中不就有渲染的语法嘛，}}双大括号就是做渲染的语法，可能有冲突吧，有文章说有代码块包含就可以，那么我试试 12// 有包含&#123;&#123;&#125;&#125; 果然，hexo g试验了一下，果然是没有报错的，而我没有使用代码块包含双大括号的时候，就会报上面的错误代码 解决办法： 双大括号我把我那篇包含渲染语法的文档，双大括号都改成了汉字，有些必须的用代码块包含了起来，这样果然就醒了 总结： 1. hexo渲染html静态文件的时候是个渲染过程，会和渲染语法冲突，避免一下 2. `}}` 被代码块包含起来是不会有错的，但没包含的会报错]]></content>
      <tags>
        <tag>hexo生成html报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序学习笔记]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[微信小程序 微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 关于此学习的测试项目都暂时保存在https://github.com/ForeManWang/wxapp-study微信小程序账号与工具在线文档：https://mp.weixin.qq.com/debug/wxadoc/dev/ 小程序开发者账号注册微信公众平台：https://mp.weixin.qq.com/ 小程序开发者账号注册：https://mp.weixin.qq.com/wxopen/waregister?action=step1 微信开发者工具微信开发者工具：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html 小程序在线Demo 微信小程序文件结构主体文件结构主体部分由三个文件组成，必须放在项目的根目录，如下： 文件 必填 作用 app.js 是 小程序逻辑 app.json 是 配置文件——小程序公共设置，主要界面外观设置 app.wxss 否 小程序公共样式表 页面文件结构 通过开发者工具快速创建了一个 QuickStart 项目。可以留意到这个项目里边生成了不同类型的文件: .json 后缀的 JSON 配置文件 .wxml 后缀的 WXML(Wei Xin Markup Language) 模板文件 .wxss 后缀的 WXSS(Wei Xin Style Sheets) 样式文件 .js 后缀的 JS 脚本逻辑文件 接下来我们分别看看这4种文件的作用。 页面由四个文件组成，分别是： 文件类型 必填 作用 js 是 页面逻辑 ( 微信小程序没有window和document对象 ) wxml 是 页面结构 ( XML语法，不是HTML语法 ) wxss 否 页面样式表 ( 拓展了rpx尺寸单位，微信专属响应式像素 ) json 否 页面配置 ( 不能写注释，否则编译报错 ) 微信小程序全局配置app.json 配置项列表 app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。可以看到生成的app.json配置内容如下： 123456789&#123; "pages": ["pages/index/index", "pages/logs/logs"], "window": &#123; "backgroundTextStyle": "light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle": "black" &#125;&#125; app.json配置各项的含义 属性 类型 必填 描述 最低版本 pages String Array 是 描述当前小程序所有页面路径，通常文件名和页面各文件名都相同 window Object 否 定义小程序所有页面的顶部背景颜色，文字颜色定义等。 tabBar Object 否 底部 tab 栏的表现 networkTimeout Object 否 网络超时时间 debug Boolean 否 是否开启 debug 模式，默认关闭 functionalPages Boolean 否 是否启用插件功能页，默认关闭 2.1.0 subpackages Object Array 否 分包结构配置 1.7.3 workers String 否 Worker 代码放置的目录 1.9.90 requiredBackgroundModes String Array 否 需要在后台使用的能力，如「音乐播放」 plugins Object 否 使用到的插件 1.9.6 preloadRule Object 否 分包预下载规则 2.3.0 resizable Boolean 否 iPad 小程序是否支持屏幕旋转，默认关闭 2.3.0 navigateToMiniProgramAppIdList String Array 否 需要跳转的小程序列表，详见 wx.navigateToMiniProgram 2.4.0 usingComponents Object 否 全局自定义组件配置 开发者工具 1.02.1810190 permission Object 否 小程序接口权限相关设置 微信客户端 7.0.0 pages 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径+文件名 信息。文件名不需要写文件后缀，框架会自动去寻找对于位置的 .json, .js, .wxml, .wxss 四个文件进行处理。 例如app.json中,此时数组中第一项为默认首页，即index是首页 123&#123; "pages": ["pages/index/index", "pages/logs/logs"]&#125; window 用于设置小程序的状态栏、导航条、标题、窗口背景色。 注意：页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键。 属性 类型 默认值 描述 最低版本 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle String white 导航栏标题颜色，仅支持 black / white navigationBarTitleText String 导航栏标题文字内容 navigationStyle String default 导航栏样式，仅支持以下值： default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮。参见注2。 微信客户端 6.6.0 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light backgroundColorTop String #ffffff 顶部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16 backgroundColorBottom String #ffffff 底部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16 enablePullDownRefresh Boolean false 是否开启当前页面的下拉刷新。 详见 Page.onPullDownRefresh onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 Page.onReachBottom pageOrientation String portrait 屏幕旋转设置，仅支持 auto / portrait 详见 响应显示区域变化 微信客户端 6.7.3 注1：HexColor（十六进制颜色值），如”#ff00ff” 注2：关于navigationStyle 客户端 7.0.0 以下版本，navigationStyle 只在 app.json 中生效。 客户端 6.7.2 版本开始，navigationStyle: custom 对 组件无效 开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用）可方便切到旧视觉 如 app.json ： 123456789&#123; "window": &#123; "navigationBarBackgroundColor": "#ffffff", "navigationBarTextStyle": "black", "navigationBarTitleText": "微信接口功能演示", "backgroundColor": "#eeeeee", "backgroundTextStyle": "light" &#125;&#125; 微信接口功能演示 tabBar 如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 属性 类型 必填 默认值 描述 最低版本 color HexColor 是 tab 上的文字默认颜色，仅支持十六进制颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色，仅支持十六进制颜色 backgroundColor HexColor 是 tab 的背景色，仅支持十六进制颜色 borderStyle String 否 black tabbar上边框的颜色， 仅支持 black / white list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom tabBar的位置，仅支持 bottom / top custom Boolean 否 false 自定义 tabBar，见详情 2.5.0 tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 属性说明： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 示例： 1234567891011121314151617181920212223242526272829303132&#123; "pages":[ "pages/index/index", "pages/logs/logs" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle":"black", &#125;, "debug": true, "tabBar": &#123; "color": "#444", "backgroundColor": "#e0e0e0", "SelectedColor": "#219be3", "boderStyle": "black", "position": "bottom", "list": [ &#123; "text": "Home", "PagePath": "pages/index/index", "iconPath": "icons/grid-01.png" &#125;, &#123; "text": "logs", "PagePath": "pages/logs/logs", "iconPath": "icons/grid-02.png" &#125; ] &#125;&#125; 图示： networkTimeout 各类网络请求的超时时间，单位均为毫秒。 属性 类型 必填 默认值 说明 request Number 否 60000 wx.request 的超时时间，单位：毫秒。 connectSocket Number 否 60000 wx.connectSocket 的超时时间，单位：毫秒。 uploadFile Number 否 60000 wx.uploadFile 的超时时间，单位：毫秒。 downloadFile Number 否 60000 wx.downloadFile 的超时时间，单位：毫秒。 debug 可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发等。可以帮助开发者快速定位一些常见的问题。 functionalPages 基础库 2.1.0 开始支持，低版本需做兼容处理。 启用插件功能页时，插件所有者小程序需要设置其 functionalPages 为 true。 subpackages 微信客户端 6.6.0 ，基础库 1.7.3 及以上版本支持。 启用分包加载时，声明项目分包结构。 写成 subPackages 也支持。 workers 基础库 1.9.90 开始支持，低版本需做兼容处理。 使用 Worker 处理多线程任务时，设置 Worker 代码放置的目录。 requiredBackgroundModes 微信客户端 6.7.2 及以上版本支持。 申明需要后台运行的能力，类型为数组。目前支持以下项目： audio: 后台音乐播放 如： 1234&#123; &quot;pages&quot;: [&quot;pages/index/index&quot;], &quot;requiredBackgroundModes&quot;: [&quot;audio&quot;]&#125; 注：在此处申明了后台运行的接口，开发版和体验版上可以直接生效，正式版还需通过审核。 plugins 基础库 1.9.6 开始支持，低版本需做兼容处理。 声明小程序需要使用的插件。 preloadRule 基础库 2.3.0 开始支持，低版本需做兼容处理。 声明分包预下载的规则。 resizable 基础库 2.3.0 开始支持，低版本需做兼容处理。 在 iPad 上运行的小程序可以设置支持屏幕旋转。 navigateToMiniProgramAppIdList 基础库 2.4.0 开始支持，低版本需做兼容处理。 当小程序需要使用 wx.navigateToMiniProgram 接口跳转到其他小程序时，需要先在配置文件中声明需要跳转的小程序 appId 列表，最多允许填写 10 个。 usingComponents 开发者工具 1.02.1810190 及以上版本支持。 在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。 permission 微信客户端 7.0.0 及以上版本支持 小程序接口权限相关设置。字段类型为 Object，结构为： 属性 类型 必填 默认值 描述 scope.userLocation PermissionObject 否 位置相关权限声明 PermissionObject 结构 属性 类型 必填 默认值 说明 desc string 是 小程序获取权限时展示的接口用途说明。最长30个字符 如： 12345678&#123; &quot;pages&quot;: [&quot;pages/index/index&quot;], &quot;permission&quot;: &#123; &quot;scope.userLocation&quot;: &#123; &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot; &#125; &#125;&#125; 微信小程序页面配置 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 配置示例1234567&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;&#125; 页面配置项列表 属性 类型 默认值 描述 最低版本 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle String white 导航栏标题颜色，仅支持 black / white navigationBarTitleText String 导航栏标题文字内容 navigationStyle String default 导航栏样式，仅支持以下值： default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮 微信客户端 7.0.0 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light enablePullDownRefresh Boolean false 是否全局开启下拉刷新。 详见 Page.onPullDownRefresh onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 Page.onReachBottom disableScroll Boolean false 设置为 true 则页面整体不能上下滚动。 只在页面配置中有效，无法在 app.json中设置 disableSwipeBack Boolean false 禁止页面右滑手势返回 微信客户端 7.0.0 页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个属性。 逻辑层App Service 小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。 逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。 逻辑层的JavaScript 小程序不是运行在Web的浏览器中，所以没有BOM和DOM对象，就意味着没有document和window 在小程序中有一些额外的全局成员 App 方法，用于定义应用实例对象 Page 方法，用于定义页面对象 getApp方法，用于获取全局应用程序实例对象 getCurrentPages方法，用于获取当前页面的调用栈， 说明：历史栈指的是当前调用的页面和历史页面的栈，尝试打印console.log(getCurrentPage())打印出来是一个数组，意味着返回值是一个数组，然后this指向当前的页面，是当前页面的调用栈 wx对象：丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力 每个页面有独立的作用域，并提供模块化能力。 小程序的JS是支持CommonJS规范的，也就是说可以通过require载入模块，通过module.exports导出模块，但不支持exports.xxx 视图层View 框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。 将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。 WXML(WeiXin Markup language) 用于描述页面的结构。 WXS(WeiXin Script) 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 WXSS(WeiXin Style Sheet) 用于描述页面的样式。 组件(Component)是视图的基本组成单元。 WXML WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。 数据绑定将数据动态渲染到页面中 简单数据绑定 数据在哪？ data：页面的初始数据，给页面供数据的，就是界面和逻辑之间的桥梁 示例 123456789Page(&#123; ... data: &#123; ... message: "hello wxxcx", ... &#125; ...&#125;) 绑定到哪？ 通过双大括号的形式，绑定数据到想要输出的位置 &lt;text&gt;&lt;/text&gt; 简单数据绑定 绑定给页面中的text文本节点 绑定给class，为元素添加样式或者拼接样式 以字面量的形式或者简单的逻辑运算符（简单的运算或者三元表达式等）直接输出 双大括号的语法 innerHTML上 元素的属性上 不能用在标签名和属性名上 注意：若判断布尔类型时，要将true或者false包裹在双大括号内进行解析，防止被JS误解为字符串 列表渲染将数组中的数据在页面中循环渲染 去index.js文件的data中定义一个数组，数组中的每一个成员都是一个对象 在index.wxml中利用wx:for=&quot;&quot;遍历输出，注意这里的wx:for中间不能有空格 12345person: [ &#123; name: 'zhangsan', age: 18, adult: true &#125;, &#123; name: 'wangwu', age: 20, adult: true &#125;, &#123; name: 'zhaoliu', age: 16, adult: false &#125; ] 1234&lt;view wx:for="&#123;&#123; person &#125;&#125;"&gt; &lt;checkbox checked='&#123;&#123; item.adult &#125;&#125;'&gt;&lt;/checkbox&gt; &lt;text&gt;&#123;&#123; item.name &#125;&#125;&lt;/text&gt;&lt;/view&gt; 如果全局属性中有一个item关键词，解决方法可以直接在循环的属性后面加上wx:for-item=&quot;项目名称缩写&quot;，那么下面遍历的时候也需要用你起的别名进行遍历，看下面示例 1234&lt;view wx:for="&#123;&#123; person &#125;&#125;" wx:for-item="wx"&gt; &lt;checkbox checked='&#123;&#123; wx.adult &#125;&#125;'&gt;&lt;/checkbox&gt; &lt;text&gt;&#123;&#123; wx.name &#125;&#125;&lt;/text&gt;&lt;/view&gt; 用 拿序号，但若关键字冲突，可以通过wx:for-index=&quot;i&quot;去拿，那么下面拿序号的时候，就要用拿 12345&lt;view wx:for="&#123;&#123; person &#125;&#125;" wx:for-item="wx" wx:for-index="i"&gt; &lt;text&gt;&#123;&#123; i &#125;&#125;&lt;/text&gt; &lt;checkbox checked='&#123;&#123; wx.adult &#125;&#125;'&gt;&lt;/checkbox&gt; &lt;text&gt;&#123;&#123; wx.name &#125;&#125;&lt;/text&gt;&lt;/view&gt; 另外wx:for的值在下面是可以点出来legth值的，我在代码中试了试 123456&lt;view wx:for="&#123;&#123; person &#125;&#125;" wx:for-item="wx" wx:for-index="i"&gt; &lt;text&gt;&#123;&#123; i &#125;&#125;&lt;/text&gt; &lt;checkbox checked='&#123;&#123; wx.adult &#125;&#125;'&gt;&lt;/checkbox&gt; &lt;text&gt;&#123;&#123; wx.name &#125;&#125;&lt;/text&gt; &lt;text&gt;&#123;&#123; person.length &#125;&#125;&lt;/text&gt;&lt;/view&gt; wx:for 也可以嵌套，下边是一个九九乘法表 ，我们将这个乘法口诀代码粘贴到自己的测试项目中看一下 12345&lt;view wx:for="&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;" wx:for-item="i"&gt; &lt;view wx:for="&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;" wx:for-item="j"&gt; &lt;view wx:if="&#123;&#123;i &lt;= j&#125;&#125;"&gt;&#123;&#123;i&#125;&#125; * &#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 渲染一个包含多节点的结构块: 可以将 wx:for 用在&lt;block/&gt;标签上 1234&lt;block wx:for="&#123;&#123;[1, 2, 3]&#125;&#125;"&gt; &lt;view&gt;&#123;&#123;index&#125;&#125;:&lt;/view&gt; &lt;view&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;&lt;/block&gt; 使用 wx:key 来指定列表中项目的唯一的标识符 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如&lt;input&gt;中的输入内容，&lt;switch&gt;的选中状态） wx:key 的值以两种形式提供 作用：当数据发生改变时，快速定位更新的值，防止顺序错乱 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字 ，如当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率 如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 示例： 123456789101112131415161718192021222324252627282930313233343536373839Page(&#123; data: &#123; objectArray: [ &#123;id: 5, unique: 'unique_5'&#125;, &#123;id: 4, unique: 'unique_4'&#125;, &#123;id: 3, unique: 'unique_3'&#125;, &#123;id: 2, unique: 'unique_2'&#125;, &#123;id: 1, unique: 'unique_1'&#125;, &#123;id: 0, unique: 'unique_0'&#125;, ], numberArray: [1, 2, 3, 4] &#125;, switch(e) &#123; const length = this.data.objectArray.length for (let i = 0; i &lt; length; ++i) &#123; const x = Math.floor(Math.random() * length) const y = Math.floor(Math.random() * length) const temp = this.data.objectArray[x] this.data.objectArray[x] = this.data.objectArray[y] this.data.objectArray[y] = temp &#125; this.setData(&#123; objectArray: this.data.objectArray &#125;) &#125;, addToFront(e) &#123; const length = this.data.objectArray.length this.data.objectArray = [&#123;id: length, unique: 'unique_' + length&#125;].concat(this.data.objectArray) this.setData(&#123; objectArray: this.data.objectArray &#125;) &#125;, addNumberToFront(e) &#123; this.data.numberArray = [this.data.numberArray.length + 1].concat(this.data.numberArray) this.setData(&#123; numberArray: this.data.numberArray &#125;) &#125;&#125;) 12345678910&lt;switch wx:for="&#123;&#123;objectArray&#125;&#125;" wx:key="unique" style="display: block;"&gt; &#123;&#123;item.id&#125;&#125;&lt;/switch&gt;&lt;button bindtap="switch"&gt;Switch&lt;/button&gt;&lt;button bindtap="addToFront"&gt;Add to the front&lt;/button&gt;&lt;switch wx:for="&#123;&#123;numberArray&#125;&#125;" wx:key="*this" style="display: block;"&gt; &#123;&#123;item&#125;&#125;&lt;/switch&gt;&lt;button bindtap="addNumberToFront"&gt;Add to the front&lt;/button&gt; 注意：当wx:for=&quot;string&quot;的时候，会把字符串解析为数组，例如下面两个等价的代码 123&lt;view wx:for="hello"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;// 等同于&lt;view wx:for="&#123;&#123; ['h', 'e', 'l', 'l', 'o'] &#125;&#125;"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; ​ 4. 注意：花括号和引号之间如果有空格，将最终被解析成为字符串 123&lt;view wx:for="&#123;&#123;[1,2,3]&#125;&#125; "&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;// 等同于&lt;view wx:for="&#123;&#123;[1,2,3] + ' '&#125;&#125;"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; 条件渲染 当判断是否需要去渲染一个代码块的时候，就需要用到wx:if , 当需要判断是否添加一个代码块的时候，要用到wx:elif或者wx:else 示例：用在wx:for章节的代码，跟着后面添加了几句判断 123&lt;view wx:if="&#123;&#123; person.length &gt; 5 &#125;&#125;"&gt;2&lt;/view&gt;&lt;view wx:elif="&#123;&#123; person.length &lt; 5 &#125;&#125;"&gt;3&lt;/view&gt;&lt;view wx:else&gt;1&lt;/view&gt; 如果要一次性判断多个组件标签，可以使用一个 &lt;block/&gt; 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。 1234&lt;block wx:if="&#123;&#123;true&#125;&#125;"&gt; &lt;view&gt;view1&lt;/view&gt; &lt;view&gt;view2&lt;/view&gt;&lt;/block 注意： &lt;block/&gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 wx:ifVShidden 因为 wx:if 之中的模板也可能包含数据绑定，所以当 wx:if 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。 同时 wx:if 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。 相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。 一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。 模板 WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。 定义模板 使用 name 属性，作为模板的名字。然后在&lt;template/&gt;内定义代码片段，如： 1234567891011&lt;!-- index: int msg: string time: string--&gt;&lt;template name="msgItem"&gt; &lt;view&gt; &lt;text&gt;&#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125;&lt;/text&gt; &lt;text&gt;Time: &#123;&#123;time&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt; 使用模板 使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入，如： 1&lt;template is="msgItem" data="&#123;&#123;...item&#125;&#125;" /&gt; 123456789Page(&#123; data: &#123; item: &#123; index: 0, msg: 'this is a template', time: '2016-09-15' &#125; &#125;&#125;) is 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板： 12345678910&lt;template name="odd"&gt; &lt;view&gt;odd&lt;/view&gt;&lt;/template&gt;&lt;template name="even"&gt; &lt;view&gt;even&lt;/view&gt;&lt;/template&gt;&lt;block wx:for="&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;"&gt; &lt;template is="&#123;&#123;item % 2 == 0 ? 'even' : 'odd'&#125;&#125;" /&gt;&lt;/block&gt; 模板的作用域 模板拥有自己的作用域，只能使用 data 传入的数据以及模板定义文件中定义的 &lt;wxs /&gt; 模块 事件 事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。 事件对象可以携带额外信息，如 id, dataset, touches 事件的使用方式 在组件中绑定事件处理函数 123&lt;view class="container"&gt; &lt;button bindtap='buttonTap'&gt;点击我哦&lt;/button&gt;&lt;/view&gt; 1234567Page(&#123; ... buttonTap() &#123; console.log('123') &#125;, ...&#125;) 给buttonTap函数传参，但是微信开发中绑定事件函数的时候，明确的规定不能直接在后面加括号传参的，不然会报错，这时候和H5开发的时候一样，需要给元素添加自定义属性data-xxx，在逻辑层通过dataset拿到数据 1&lt;button bindtap='buttonTap' data-hello='事件传参'&gt;点击我哦&lt;/button&gt; 12345678Page(&#123; ... buttonTap(e) &#123; console.log(e) console.log(e.target) &#125;, ...&#125;) 可以看到e对象里面有很多属性和方法方便以后使用 看到e.target对象是这样的 事件分类 事件分为冒泡事件和非冒泡事件： 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。 WXML的冒泡事件列表： 类型 触发条件 最低版本 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 1.5.0 longtap 手指触摸后，超过350ms再离开（推荐使用longpress事件代替） transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发 animationstart 会在一个 WXSS animation 动画开始时触发 animationiteration 会在一个 WXSS animation 一次迭代结束时触发 animationend 会在一个 WXSS animation 动画完成时触发 touchforcechange 在支持 3D Touch 的 iPhone 设备，重按时会触发 1.9.90 注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如的submit事件，的input事件，的scroll事件，(详见各个组件) 事件绑定和冒泡 事件绑定的写法同组件的属性，以 key、value 的形式 : key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtouchstart。自基础库版本 1.5.0 起，在非原生组件中，bind和catch后可以紧跟一个冒号，其含义不变，如bind:tap、catch:touchstart value 是一个字符串，需要在对应的 Page 中定义同名的函数，不然当触发事件的时候会报错 1234567&lt;view id="outer" style='width: 200px; height: 200px; background-color:red' bindtap="handleTap1"&gt; 我是他爷爷 &lt;view id="middle" style='width: 100px; height: 100px; background-color:yellow' bindtap="handleTap2"&gt; 我是他爸爸 &lt;view id="inner" style='width: 50px; height: 50px; background-color:blue' bindtap="handleTap3"&gt;我是他儿子&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213Page(&#123; ... handleTap1() &#123; console.log('我是他爷爷') &#125;, handleTap2() &#123; console.log('我是他爸爸') &#125;, handleTap3() &#123; console.log('我是他儿子') &#125;, ...&#125;) 实际上熟悉JS事件冒泡的对于这个都不难理解，就是子元素的事件会向上冒泡给相同事件的父元素 阻止事件冒泡cstch + xxx阻止冒泡 将上面的案例中的其中一个父元素绑定一下阻止冒泡的事件，观察下 1234567&lt;view id="outer" style='width: 200px; height: 200px; background-color:red' bindtap="handleTap1"&gt; 我是他爷爷 &lt;view id="middle" style='width: 100px; height: 100px; background-color:yellow' catchtap="handleTap2"&gt; 我是他爸爸 &lt;view id="inner" style='width: 50px; height: 50px; background-color:blue' bindtap="handleTap3"&gt;我是他儿子&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 这样的话，事件冒泡到我是他爸爸这个盒子之后就不会再冒泡了 事件捕获 自基础库版本 1.5.0 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段。 在下面的代码中，点击 inner view 会先后调用handleTap2、handleTap4、handleTap3、handleTap1 1234&lt;view id="outer" style='width: 200px; height: 200px; background-color:red' bind:tap="handleTap1" capture-bind:tap="handleTap2"&gt; 我是他爸爸 &lt;view id="middle" style='width: 100px; height: 100px; background-color:yellow' bind:tap="handleTap3" capture-bind:tap="handleTap4"&gt; 我是我自己&lt;/view&gt; &lt;/view&gt; 12345678910111213141516Page(&#123; ... handleTap1() &#123; console.log('我是handleTap1') &#125;, handleTap2() &#123; console.log('我是handleTap2') &#125;, handleTap3() &#123; console.log('我是handleTap3') &#125;, handleTap4() &#123; console.log('我是handleTap4') &#125;, ...&#125;) 如果将上面代码中的第一个capture-bind改为capture-catch，将只触发handleTap2 事件对象 如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象 BaseEvent 基础事件对象属性列表： 属性 类型 说明 type String 事件类型 timeStamp Integer 事件生成时的时间戳 target Object 触发事件的组件的一些属性值集合 currentTarget Object 当前组件的一些属性值集合 CustomEvent 自定义事件对象属性列表（继承 BaseEvent）： 属性 类型 说明 detail Object 额外的信息 TouchEvent 触摸事件对象属性列表（继承 BaseEvent）： 属性 类型 说明 touches Array 触摸事件，当前停留在屏幕中的触摸点信息的数组 changedTouches Array 触摸事件，当前变化的触摸点信息的数组 特殊事件： 中的触摸事件不可冒泡，所以没有 currentTarget。 type 代表事件的类型 timeStamp 页面打开到触发事件所经过的毫秒数 target 触发事件的源组件 属性 类型 说明 id String 事件源组件的id tagName String 当前组件的类型 dataset Object 事件源组件上由data-开头的自定义属性组成的集合 currentTarget 事件绑定的当前组件 属性 类型 说明 id String 当前组件的id tagName String 当前组件的类型 dataset Object 当前组件上由data-开头的自定义属性组成的集合 说明： target 和 currentTarget 可以参考前面的例子 dataset 这个在前面传参中也有提到过 在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.currentTarget.dataset 中会将连字符转成驼峰elementType 示例： 123&lt;view data-alpha-beta=&quot;1&quot; data-alphaBeta=&quot;2&quot; bindtap=&quot;bindViewTap&quot;&gt; DataSet Test&lt;/view&gt; 123456Page(&#123; bindViewTap(event) &#123; event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法 event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写 &#125;&#125;) touches touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点 Touch 对象 属性 类型 说明 identifier Number 触摸点的标识符 pageX, pageY Number 距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴 clientX, clientY Number 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴 CanvasTouch 对象 属性 类型 说明 特殊说明 identifier Number 触摸点的标识符 x, y Number 距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为X轴，纵向为Y轴 changedTouches changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel） detail 自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义 点击事件的detail 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离 引用 WXML 提供两种文件引用方式import和include import import可以在该文件中使用目标文件定义的template，如： 在 item.wxml 中定义了一个叫item的template： 1234&lt;!-- item.wxml --&gt;&lt;template name=&quot;item&quot;&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt; 在 index.wxml 中引用了 item.wxml，就可以使用item模板： 12&lt;import src=&quot;item.wxml&quot; /&gt;&lt;template is=&quot;item&quot; data=&quot;&#123;&#123;text: &apos;forbar&apos;&#125;&#125;&quot; /&gt; import 的作用域 import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template 如：C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template。 1234&lt;!-- A.wxml --&gt;&lt;template name=&quot;A&quot;&gt; &lt;text&gt;A template&lt;/text&gt;&lt;/template&gt; 12345&lt;!-- B.wxml --&gt;&lt;import src=&quot;a.wxml&quot; /&gt;&lt;template name=&quot;B&quot;&gt; &lt;text&gt;B template&lt;/text&gt;&lt;/template&gt; 12345&lt;!-- C.wxml --&gt;&lt;import src=&quot;b.wxml&quot; /&gt;&lt;template is=&quot;A&quot; /&gt;&lt;!-- Error! Can not use tempalte when not import A. --&gt;&lt;template is=&quot;B&quot; /&gt; include include 可以将目标文件除了 &lt;template/&gt; &lt;wxs/&gt; 外的整个代码引入，相当于是拷贝到 include 位置，如： 12345678&lt;!-- index.wxml --&gt;&lt;include src=&quot;header.wxml&quot; /&gt;&lt;view&gt;body&lt;/view&gt;&lt;include src=&quot;footer.wxml&quot; /&gt;&lt;!-- header.wxml --&gt;&lt;view&gt;header&lt;/view&gt;&lt;!-- footer.wxml --&gt;&lt;view&gt;footer&lt;/view&gt; 单向数据流由于微信小程序框架中没有像Angular中的ngMoudel或者Vue中的v-model的双向数据绑定，所以默认微信小程序中的数据流只有单向数据流 123456789101112Page(&#123; ... inputHandle(e) &#123; // console.log(e.detail.value) // console.log(this.data.message) // this.data.message = e.detail.value this.setData(&#123; message: e.detail.value &#125;) &#125;, ...&#125;) 12&lt;input value='&#123;&#123; message &#125;&#125;' bindinput='inputHandle'&gt;&lt;/input&gt;&lt;text&gt;&#123;&#123; message &#125;&#125;&lt;/text&gt; 发现只有内存中的数据改变了，页面却不能跟随变化 双向数据绑定利用setData()这个内部方法进行双向数据绑定 123456789Page(&#123; ... inputHandle(e) &#123; // console.log(e.detail.value) // console.log(this.data.message) this.data.message = e.detail.value &#125;, ...&#125;) 这样实现内存和页面中数据同步更新 WXSS 样式WXSS(WeiXin Style Sheets)是一套样式语言。 与 CSS 相比，WXSS 扩展以下2个特性： 尺寸单位 rpx ( responsive pixel 响应式像素) ，750rpx充满屏幕 样式导入 @import “样式表路径”; 微信小程序组件(标签)组件文档：https://developers.weixin.qq.com/miniprogram/dev/component/ 常用布局标签12345&lt;view&gt;&lt;/view&gt; 视图容器，相当于 &lt;div&gt;&lt;/div&gt;&lt;text&gt;&lt;/text&gt; 相当于 &lt;span&gt;&lt;/span&gt; &lt;image&gt;&lt;/image&gt; 相当于 &lt;img /&gt;&lt;navigator&gt;&lt;/navigator&gt; 相当于 &lt;a&gt;&lt;/a&gt;&lt;block&gt;&lt;/block&gt; 区块标签，不会渲染到页面 注意：image组件默认宽度300px、高度225px，很多时候我们都不需要这个默认宽高，记得手动设置宽高 flex布局参考文档https://qqqww.com/Flex%E5%B8%83%E5%B1%80/ 页面间跳转（navigator）新建页面小技巧当我们新建页面的时候，自己去新建一个页面，每个页面还要新建好几个文件，很麻烦，这里其实不需要直接新建，在配置app.json的时候，微信开发者工具会自动帮我们创建好，看下图，我左侧是没有demo4这个页面的，但是右边配置中写上了&quot;pages/demo4/deom4&quot;，那么ctrl+s保存之后，可以看到，左边的页面以及需求的文件都被自动创建出来了 如何做页面跳转语法： 在当前页面设置跳转 1&lt;navigator url="想去到达页面的相对路径"&gt;&lt;/navigator&gt; 配置json，不然页面跳转无法显示 123&#123; "usingComponents": &#123;&#125;&#125; 页面间传值以往通过?或者请求体进行传值 在小程序中，页面间的传值，也可以利用?传参，在需要使用的传过来的数的时候，在该页面的js文件的onLoad生命周期的时候通过options去接受参数 123// demo1.wxml&lt;navigator url="../demo2/demo2?name=小明&amp;age=18"&gt;小明&lt;/navigator&gt;&lt;navigator url="../demo2/demo2?name=小红"&gt;小红&lt;/navigator&gt; 1234567891011121314151617181920// pages/demo2/demo2.jsPage(&#123; data:&#123;&#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 console.log(options) &#125;, onReady:function()&#123; // 页面渲染完成 &#125;, onShow:function()&#123; // 页面显示 &#125;, onHide:function()&#123; // 页面隐藏 &#125;, onUnload:function()&#123; // 页面关闭 &#125;&#125;) 页面导航模式通过redirect进行重定向，类型时布尔类型 12// demo1.wxml&lt;navigator url="../demo2/demo2" redirect&gt;跳转过去（不回来了）&lt;/navigator&gt; 导航元素点击高亮利用hover-class控制点击时添加自定义的高亮的类 123// demo1.wxml&lt;navigator hover-class="my-hover"&gt;点我点我&lt;/navigator&gt;&lt;navigator hover-class="none"&gt;点我点我&lt;/navigator&gt; 1234// demo1.wxss.my-hover &#123; color: red;&#125; cursor pointer 的方式是一个小技巧，可以让任何元素点击时高亮 12// demo1.wxml&lt;image class="hover-demo" src="../../images/poster.jpg"&gt;&lt;/image&gt; 1234// demo1.wxss.hover-demo &#123; cursor: pointer;&#125; 页面导航API可以利用wx.navigateTo进行跳转，并可以在url中添加链接，?后面接收参数 12// demo1.wxml&lt;button type="primary" bindtap="tapHandle"&gt;跳转过去&lt;/button&gt; 123456789101112131415// demo1.jsPage(&#123; tapHandle: function () &#123; // 当我们点击按钮 系统会自动执行这里的代码 // console.log(1111) wx.navigateTo(&#123; url: '../demo2/demo2?id=123' &#125;) // 相当于加上redirect的 navigator // wx.redirectTo(&#123; // url: '../demo2/demo2' // &#125;) &#125;&#125;) 基础内容 组件名 说明 icon 图标 text 文字，可以嵌套，支持换行 rich-text 富文本 progress 进度条 icon 属性名 类型 默认值 说明 type String icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear size Number / String 23px icon的大小，单位px（2.4.0起支持rpx） color Color icon的颜色，同css的color aria-label String 无障碍访问，（属性）元素的额外描述 2.5.0 属性type 用于定义图标类型，只能是规定范围的类型，除了这些内置图标，其他的图标必须通过图片的方式使用 1&lt;icon type="success"&gt;&lt;/icon&gt; 属性size size用于指定图标大小，默认是 23px 1&lt;icon type="success" size="60"&gt;&lt;/icon&gt; 属性color color用于指定图标颜色，取值和css取值一样 1&lt;icon type="success" size="60" color="red"&gt;&lt;/icon&gt; rich-text tip: nodes 不推荐使用 String 类型，性能会有所下降。 tip: rich-text 组件内屏蔽所有节点的事件。 tip: attrs 属性不支持 id ，支持 class 。 tip: name 属性大小写不敏感。 tip: 如果使用了不受信任的HTML节点，该节点及其所有子节点将会被移除。 tip: img 标签仅支持网络图片。 tip: 如果在自定义组件中使用 rich-text 组件，那么仅自定义组件的 wxss 样式对 rich-text 中的 class 生效。 123456789101112131415&lt;view class="page-body"&gt; &lt;view class="page-section"&gt; &lt;view class="page-section-title"&gt;传入html字符串&lt;/view&gt; &lt;view class="rich-text-wrp"&gt; &lt;rich-text nodes="&#123;&#123;html&#125;&#125;" bindtap="tap"&gt;&lt;/rich-text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="page-section"&gt; &lt;view class="page-section-title"&gt;传入节点列表&lt;/view&gt; &lt;view class="rich-text-wrp"&gt; &lt;rich-text nodes="&#123;&#123;nodes&#125;&#125;" bindtap="tap"&gt;&lt;/rich-text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526rich-text &#123; width: 700rpx; padding: 25rpx 0;&#125;.rich-text-wrp &#123; padding: 0 25rpx; background-color: #fff;&#125;.page-section&#123; width: 100%; margin-bottom: 60rpx;&#125;.page-section:last-child&#123; margin-bottom: 0;&#125;.page-section-title&#123; font-size: 28rpx; color: #999999; margin-bottom: 10rpx; padding-left: 30rpx; padding-right: 30rpx;&#125; 12345678910111213141516171819Page(&#123; data: &#123; html: '&lt;div class="div_class" style="line-height: 60px; color: red;"&gt;Hello&amp;nbsp;World!&lt;/div&gt;', nodes: [&#123; name: 'div', attrs: &#123; class: 'div_class', style: 'line-height: 60px; color: red;' &#125;, children: [&#123; type: 'text', text: 'Hello&amp;nbsp;World!' &#125;] &#125;] &#125;, tap() &#123; console.log('tap') &#125;&#125;) progress 这个直接写代码到页面上是不会出现进度条的，原因在于其父元素的设置了flex且align-item:center导致没有宽度，需要自己加宽度才能显示，看下图，修改了控制台内其父元素的样式之后就可以了 加上active属性，有一个从左到右的进度条动画 其他属性 属性名 类型 默认值 说明 最低版本 percent Float 无 百分比0~100 show-info Boolean false 在进度条右侧显示百分比 border-radius Number / String 0 圆角大小，单位px（2.4.0起支持rpx） 2.3.1 font-size Number / String 16 右侧百分比字体大小，单位px（2.4.0起支持rpx） 2.3.1 stroke-width Number / String 6 进度条线的宽度，单位px（2.4.0起支持rpx） color Color #09BB07 进度条颜色 （请使用 activeColor） activeColor Color 已选择的进度条的颜色 backgroundColor Color 未选择的进度条的颜色 active Boolean false 进度条从左往右的动画 active-mode String backwards backwards: 动画从头播；forwards：动画从上次结束点接着播 1.7.0 bindactiveend EventHandle 动画完成事件 2.4.1 aria-label String 无障碍访问，（属性）元素的额外描述 2.5.0 常用表单标签1234&lt;button&gt;&lt;/button&gt;&lt;input type="text" /&gt; &lt;checkbox /&gt;&lt;radio/&gt; buttonbutton参考文档 type有效值123&lt;button type='warn'&gt;这是一个红色按钮&lt;/button&gt;&lt;button type='primary'&gt;这是一个绿色按钮&lt;/button&gt;&lt;button type='default'&gt;这是一个白色按钮&lt;/button&gt; size有效值123&lt;button type='warn' size='default'&gt;这是一个红色按钮&lt;/button&gt;&lt;button type='primary' size='mini'&gt;这是一个小尺寸绿色按钮&lt;/button&gt;&lt;button type='default'&gt;这是一个白色按钮&lt;/button&gt; form-type 有效值 值 说明 submit 提交表单 reset 重置表单 hover-class当按钮按下去，将hover-class指向想要展示出来的类 1&lt;button hover-class='btn-active'&gt;hover-class&lt;/button&gt; 123.btn-active &#123; background: red;&#125; 演示图片： checkbox多选框 checkbox-group多项选择器，内部由多个checkbox组成。 属性名 类型 默认值 说明 bindchange EventHandle &lt;checkbox-group&gt;中选中项发生改变时触发 change 事件，detail = {value:[选中的checkbox的value的数组]} checkbox多选项目。 属性名 类型 默认值 说明 最低版本 value String 标识，选中时触发的 change 事件，并携带 的 value disabled Boolean false 是否禁用 checked Boolean false 当前是否选中，可用来设置默认选中 color Color checkbox的颜色，同css的color aria-label String 无障碍访问，（属性）元素的额外描述 2.5.0 演示图片： form类似于HTML的form，将一些需要在表单中呈现的元素框起来 区别： 这里的form事件绑定方式是通过：bindsubmit提交，和bindreset重置 注意： 表单，将组件内的用户输入的&lt;switch&gt;、&lt;input&gt;、&lt;checkbox&gt;、&lt;slider&gt;、&lt;radio&gt;、&lt;picker&gt;提交。 当点击&lt;form&gt;表单中 form-type 为 submit 的&lt;button&gt;组件时，会将表单组件中的 value 值进行提交，需要在表单组件中加上 name 来作为 key。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;form bindsubmit="formSubmit" bindreset="formReset"&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;switch&lt;/view&gt; &lt;switch name="switch" /&gt; &lt;/view&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;slider&lt;/view&gt; &lt;slider name="slider" show-value&gt;&lt;/slider&gt; &lt;/view&gt; &lt;view class="section"&gt; &lt;view class="section__title"&gt;input&lt;/view&gt; &lt;input name="input" placeholder="please input here" /&gt; &lt;/view&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;radio&lt;/view&gt; &lt;radio-group name="radio-group"&gt; &lt;label&gt; &lt;radio value="radio1" /&gt; radio1 &lt;/label&gt; &lt;label&gt; &lt;radio value="radio2" /&gt; radio2 &lt;/label&gt; &lt;/radio-group&gt; &lt;/view&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;checkbox&lt;/view&gt; &lt;checkbox-group name="checkbox"&gt; &lt;label&gt; &lt;checkbox value="checkbox1" /&gt; checkbox1 &lt;/label&gt; &lt;label&gt; &lt;checkbox value="checkbox2" /&gt; checkbox2 &lt;/label&gt; &lt;/checkbox-group&gt; &lt;/view&gt; &lt;view class="btn-area"&gt; &lt;button form-type="submit"&gt;Submit&lt;/button&gt; &lt;button form-type="reset"&gt;Reset&lt;/button&gt; &lt;/view&gt;&lt;/form&gt; 12345678Page(&#123; formSubmit(e) &#123; console.log('form发生了submit事件，携带数据为：', e.detail.value) &#125;, formReset() &#123; console.log('form发生了reset事件') &#125;&#125;) inputinput在线文档 和原生基本类似，体验 1&lt;input class='input1' placeholder='请输入...' placeholder-class='input-placeholder'&gt;&lt;/input&gt; 1234567.input1 &#123; border: 1px solid #c0c0c0;&#125;.input-placeholder &#123; color: red;&#125; label基本和HTML差不多 用来改进表单组件的可用性，使用for属性找到对应的id，或者将控件放在该标签下，当点击时，就会触发对应的控件。 for优先级高于内部控件，内部有多个控件的时候默认触发第一个控件。 目前可以绑定的控件有：[button checkbox radio switch 属性名 类型 说明 for String 绑定控件的 id picker支持滚动的选择器，类似下图这样 目前picker支持五类选择器，普通选择器，多列选择器，时间选择器（一天内的时间），日期选择器（年月日），省市选择器 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;view class="section"&gt; &lt;view class="section__title"&gt;普通选择器&lt;/view&gt; &lt;picker bindchange="bindPickerChange" value="&#123;&#123;index&#125;&#125;" range="&#123;&#123;array&#125;&#125;"&gt; &lt;view class="picker"&gt; 当前选择：&#123;&#123;array[index]&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;多列选择器&lt;/view&gt; &lt;picker mode="multiSelector" bindchange="bindMultiPickerChange" bindcolumnchange="bindMultiPickerColumnChange" value="&#123;&#123;multiIndex&#125;&#125;" range="&#123;&#123;multiArray&#125;&#125;"&gt; &lt;view class="picker"&gt; 当前选择：&#123;&#123;multiArray[0][multiIndex[0]]&#125;&#125;，&#123;&#123;multiArray[1][multiIndex[1]]&#125;&#125;，&#123;&#123;multiArray[2][multiIndex[2]]&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;时间选择器&lt;/view&gt; &lt;picker mode="time" value="&#123;&#123;time&#125;&#125;" start="09:01" end="21:01" bindchange="bindTimeChange"&gt; &lt;view class="picker"&gt; 当前选择: &#123;&#123;time&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;日期选择器&lt;/view&gt; &lt;picker mode="date" value="&#123;&#123;date&#125;&#125;" start="2015-09-01" end="2017-09-01" bindchange="bindDateChange"&gt; &lt;view class="picker"&gt; 当前选择: &#123;&#123;date&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;省市区选择器&lt;/view&gt; &lt;picker mode="region" bindchange="bindRegionChange" value="&#123;&#123;region&#125;&#125;" custom-item="&#123;&#123;customItem&#125;&#125;"&gt; &lt;view class="picker"&gt; 当前选择：&#123;&#123;region[0]&#125;&#125;，&#123;&#123;region[1]&#125;&#125;，&#123;&#123;region[2]&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt; 123456// 这里注意需要现在`lib`文件夹中放入`weui.wxss`的依赖文件@import "../lib/weui.wxss";.picker&#123; padding: 13px; background-color: #FFFFFF;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165Page(&#123; data: &#123; array: ['美国', '中国', '巴西', '日本'], objectArray: [ &#123; id: 0, name: '美国' &#125;, &#123; id: 1, name: '中国' &#125;, &#123; id: 2, name: '巴西' &#125;, &#123; id: 3, name: '日本' &#125; ], index: 0, multiArray: [['无脊柱动物', '脊柱动物'], ['扁性动物', '线形动物', '环节动物', '软体动物', '节肢动物'], ['猪肉绦虫', '吸血虫']], objectMultiArray: [ [ &#123; id: 0, name: '无脊柱动物' &#125;, &#123; id: 1, name: '脊柱动物' &#125; ], [ &#123; id: 0, name: '扁性动物' &#125;, &#123; id: 1, name: '线形动物' &#125;, &#123; id: 2, name: '环节动物' &#125;, &#123; id: 3, name: '软体动物' &#125;, &#123; id: 3, name: '节肢动物' &#125; ], [ &#123; id: 0, name: '猪肉绦虫' &#125;, &#123; id: 1, name: '吸血虫' &#125; ] ], multiIndex: [0, 0, 0], date: '2016-09-01', time: '12:01', region: ['广东省', '广州市', '海珠区'], customItem: '全部' &#125;, bindPickerChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; index: e.detail.value &#125;) &#125;, bindMultiPickerChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; multiIndex: e.detail.value &#125;) &#125;, bindMultiPickerColumnChange: function (e) &#123; console.log('修改的列为', e.detail.column, '，值为', e.detail.value); var data = &#123; multiArray: this.data.multiArray, multiIndex: this.data.multiIndex &#125;; data.multiIndex[e.detail.column] = e.detail.value; switch (e.detail.column) &#123; case 0: switch (data.multiIndex[0]) &#123; case 0: data.multiArray[1] = ['扁性动物', '线形动物', '环节动物', '软体动物', '节肢动物']; data.multiArray[2] = ['猪肉绦虫', '吸血虫']; break; case 1: data.multiArray[1] = ['鱼', '两栖动物', '爬行动物']; data.multiArray[2] = ['鲫鱼', '带鱼']; break; &#125; data.multiIndex[1] = 0; data.multiIndex[2] = 0; break; case 1: switch (data.multiIndex[0]) &#123; case 0: switch (data.multiIndex[1]) &#123; case 0: data.multiArray[2] = ['猪肉绦虫', '吸血虫']; break; case 1: data.multiArray[2] = ['蛔虫']; break; case 2: data.multiArray[2] = ['蚂蚁', '蚂蟥']; break; case 3: data.multiArray[2] = ['河蚌', '蜗牛', '蛞蝓']; break; case 4: data.multiArray[2] = ['昆虫', '甲壳动物', '蛛形动物', '多足动物']; break; &#125; break; case 1: switch (data.multiIndex[1]) &#123; case 0: data.multiArray[2] = ['鲫鱼', '带鱼']; break; case 1: data.multiArray[2] = ['青蛙', '娃娃鱼']; break; case 2: data.multiArray[2] = ['蜥蜴', '龟', '壁虎']; break; &#125; break; &#125; data.multiIndex[2] = 0; console.log(data.multiIndex); break; &#125; this.setData(data); &#125;, bindDateChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; date: e.detail.value &#125;) &#125;, bindTimeChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; time: e.detail.value &#125;) &#125;, bindRegionChange: function (e) &#123; console.log('picker发送选择改变，携带值为', e.detail.value) this.setData(&#123; region: e.detail.value &#125;) &#125;&#125;) 演示图片： picker-view和picker类似 radio单项选择器，用法同html slider滑动选择器 switch开关选择器 textarea多行输入框，和html一样 操作组件通过方法调用来呈现组件（交互操作组件必须通过调用API的方式来调用） 12345678910111213141516171819Page(&#123; data: &#123; &#125;, btnTodo() &#123; // 当点击按钮触发 // console.log('111') wx.showActionSheet(&#123; // 显示出来的项目列表 itemList: ['a', 'b', 'c'], // 成功回调 success: function (res) &#123; if(!res.cancel) &#123; console.log(res.tapIndex) &#125; &#125; &#125;) &#125;&#125;) 1&lt;button type='primary' bindtap='btnTodo'&gt;你要点击我哦&lt;/button&gt; 另外模态框和上面用法一致…. 轮播图组件12345678&lt;swiper indicator-dots="是否显示面板指示点" autoplay="是否自动切换" interval="自动切换时间间隔" duration="滑动动画时长"&gt; &lt;swiper-item&gt; &lt;image src="图片路径1" width="375" height="150"/&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="图片路径2" width="375" height="150"/&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; 探索：实现无缝轮播怎么办？ 总结 组件的基本用法： 组件的语法问题 组件得使用是类似于HTML的方式，但是又有不同，组件使用的是严格的XML标准（例如结束标签问题要注意） 组件的分类 功能型组件（progress、checkbox、radio等具有具体功能的） 布局类型组件，用来完成页面结构 API类型组件，例如wx.showModal，通过调用API来使用 微信小程序页面函数生命周期函数1234567891011121314151617181920Page(&#123; /** 页面的初始数据 */ data: &#123; &#125;, /** 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, /** 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;&#125;) 页面相关事件处理函数123456789/** 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125; WXS 脚本WXS（WeiXin Script）是小程序的一套脚本语言，功能类似&lt;script&gt;标签，用于在视图层定义函数(比较少用)。 12345678910&lt;!--wxml--&gt;&lt;wxs module="foo"&gt;var sum = function(a,b)&#123; return a+b;&#125;;// 这里可以导出一个对象，这个对象可以直接在界面上使用 module.exports.sum = sum;&lt;/wxs&gt;&lt;view&gt; &#123;&#123;foo.sum&#125;&#125; &lt;/view&gt;]]></content>
      <tags>
        <tag>微信小程序学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局的语法和案例]]></title>
    <url>%2Fflex%E5%B8%83%E5%B1%80%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Flex 布局本文参考阮一峰老师的《Flex布局：语法篇》，在实践过程中，添加了一些案例，方便理解 详细参考Flex 布局教程：语法篇 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 1234&gt; .box&#123;&gt; display: flex;&gt; &#125;&gt; 行内元素也可以使用 Flex 布局。 1234&gt; .box&#123;&gt; display: inline-flex;&gt; &#125;&gt; Webkit 内核的浏览器，必须加上-webkit前缀。 12345&gt; .box&#123;&gt; display: -webkit-flex; /* Safari */&gt; display: flex;&gt; &#125;&gt; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 案例当一个布局需要自适应或者，一边固定宽度，其他自适应的情况下，使用flex布局 当想要使用flex布局的时候，找到其父元素，给父元素的类添加display:flex即可，在固定宽度的位置固定宽度，其他需要自适应的兄弟元素，分配flex，意思就是父盒子总宽度 - 固定宽度为剩余总宽度，把剩余需要自适应的兄弟元素按照需要的比例去分配剩余总宽度，案例代码如下： 案例一： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Flex布局1&lt;/title&gt; &lt;style type="text/css"&gt; /* 使用 flex 流程 1.设计 DOM 结构 2.将父盒子设置为伸缩盒子 display: flex; 3.固定一边宽度，另一边设置flex: 1;就实现了 */ html, body &#123; height: 100%; &#125; .root &#123; /*padding-left: 100px;*/ display: flex; border: 2px solid #c0c0c0; height: 100%; &#125; .sidebar &#123; width: 100px; background-color: yellow; &#125; .content &#123; /*width: 100%;*/ flex: 1; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="root"&gt; &lt;div class="sidebar"&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 案例二： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Flex2&lt;/title&gt; &lt;style type="text/css"&gt; .container &#123; display: flex; width: 400px; height: 300px; &#125; .item &#123; flex: 1; /*每一项占一份*/ &#125; .item:nth-child(even) &#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 案例三：音乐播放器主界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// index.wxml&lt;view class="root"&gt; &lt;!-- 标签栏的页签 固定高度 --&gt; &lt;view class="tabs"&gt; &lt;view class="item active"&gt; &lt;text&gt;个性推荐&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;text&gt;歌单&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;text&gt;主播电台&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;text&gt;排行榜&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 内容区域 自适应高度 --&gt; &lt;scroll-view class="content" scroll-y&gt; &lt;swiper class="slide" autoplay indicator-dots&gt; &lt;swiper-item&gt; &lt;image src="../../images/slide.png"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../images/slide.png"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../images/slide.png"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;view class="portals"&gt; &lt;view class="item"&gt; &lt;image src="../../images/04.png"&gt;&lt;/image&gt; &lt;text&gt;私人FM&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/05.png"&gt;&lt;/image&gt; &lt;text&gt;每日歌曲推荐&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/06.png"&gt;&lt;/image&gt; &lt;text&gt;云音乐新歌榜&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="list"&gt; &lt;view class="title"&gt; &lt;text&gt;推荐歌单&lt;/text&gt; &lt;/view&gt; &lt;view class="inner"&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;!-- 播放控制条条 固定高度 --&gt; &lt;view class="player"&gt; &lt;view class="poster"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="info"&gt; &lt;text class="title"&gt;一生中最爱&lt;/text&gt; &lt;text class="artist"&gt;谭咏麟&lt;/text&gt; &lt;/view&gt; &lt;view class="controls"&gt; &lt;image src="../../images/01.png"&gt;&lt;/image&gt; &lt;image src="../../images/02.png"&gt;&lt;/image&gt; &lt;image src="../../images/03.png"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// index.wxsspage &#123; height: 100%;&#125;.root &#123; display: flex; flex-direction: column; height: 100%; background-color: #f0f0f0;&#125;.tabs &#123; display: flex; background-color: pink;&#125;.tabs .item &#123; flex: 1; text-align: center; font-size: 12px; background-color: #222; color: #ccc; padding: 8px 0;&#125;.tabs .item.active &#123; color: #fff; border-bottom: 2px solid #e9232c;&#125;.content &#123; flex: 1; background-color: #111214; color: #ccc; overflow: hidden;&#125;.slide image &#123; width: 100%; height: 130px;&#125;.portals &#123; display: flex; margin-bottom: 15px;&#125;.portals .item &#123; flex: 1;&#125;.portals .item image &#123; width: 60px; height: 60px; display: block; margin: 10px auto;&#125;.portals .item text &#123; display: block; font-size: 12px; text-align: center;&#125;.list .title &#123; margin: 5px 10px; font-size: 14px;&#125;.list .inner &#123; display: flex; flex-wrap: wrap;&#125;.list .inner .item &#123; width: 33.33333333%;&#125;.list .inner .item image &#123; display: block; width: 120px; height: 120px; margin: 0 auto;&#125;.list .inner .item text &#123; font-size: 14px;&#125;.player &#123; display: flex; height: 50px; background-color: #17181A;&#125;.poster image &#123; width: 40px; height: 40px; margin: 5px;&#125;.info &#123; flex: 1; color: #888; font-size: 14px; margin: 5px;&#125;.info .title&#123; display: block; font-size: 16px; color: #ccc;&#125;.controls image &#123; width: 40px; height: 40px; margin: 5px 2px;&#125; 123456// index.json&#123; "navigationBarTitleText": "Music Player", "navigationBarBackgroundColor": "#333", "navigationBarTextStyle": "white"&#125; 三、各种属性 flex-direction调整主轴方向（默认为水平方向） justify-content调整主轴对齐 align-items调整侧轴对齐（子元素可以使用align-self覆盖） flex-wrap控制是否换行 align-content堆栈（由flex-wrap产生的独立行）对齐 flex-flow是flex-direction + flex-wrap的简写形式 flex是子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配 order控制子项目的排列顺序，正序方式排序，从小到大]]></content>
      <tags>
        <tag>flex布局语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2FFlex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Flex 布局本文参考阮一峰老师的《Flex布局：语法篇》，在实践过程中，添加了一些案例，方便理解 详细参考Flex 布局教程：语法篇 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 1234&gt; .box&#123;&gt; display: flex;&gt; &#125;&gt; 行内元素也可以使用 Flex 布局。 1234&gt; .box&#123;&gt; display: inline-flex;&gt; &#125;&gt; Webkit 内核的浏览器，必须加上-webkit前缀。 12345&gt; .box&#123;&gt; display: -webkit-flex; /* Safari */&gt; display: flex;&gt; &#125;&gt; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 案例当一个布局需要自适应或者，一边固定宽度，其他自适应的情况下，使用flex布局 当想要使用flex布局的时候，找到其父元素，给父元素的类添加display:flex即可，在固定宽度的位置固定宽度，其他需要自适应的兄弟元素，分配flex，意思就是父盒子总宽度 - 固定宽度为剩余总宽度，把剩余需要自适应的兄弟元素按照需要的比例去分配剩余总宽度，案例代码如下： 案例一： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Flex布局1&lt;/title&gt; &lt;style type="text/css"&gt; /* 使用 flex 流程 1.设计 DOM 结构 2.将父盒子设置为伸缩盒子 display: flex; 3.固定一边宽度，另一边设置flex: 1;就实现了 */ html, body &#123; height: 100%; &#125; .root &#123; /*padding-left: 100px;*/ display: flex; border: 2px solid #c0c0c0; height: 100%; &#125; .sidebar &#123; width: 100px; background-color: yellow; &#125; .content &#123; /*width: 100%;*/ flex: 1; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="root"&gt; &lt;div class="sidebar"&gt; &lt;/div&gt; &lt;div class="content"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 案例二： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Flex2&lt;/title&gt; &lt;style type="text/css"&gt; .container &#123; display: flex; width: 400px; height: 300px; &#125; .item &#123; flex: 1; /*每一项占一份*/ &#125; .item:nth-child(even) &#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 案例三：音乐播放器主界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// index.wxml&lt;view class="root"&gt; &lt;!-- 标签栏的页签 固定高度 --&gt; &lt;view class="tabs"&gt; &lt;view class="item active"&gt; &lt;text&gt;个性推荐&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;text&gt;歌单&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;text&gt;主播电台&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;text&gt;排行榜&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 内容区域 自适应高度 --&gt; &lt;scroll-view class="content" scroll-y&gt; &lt;swiper class="slide" autoplay indicator-dots&gt; &lt;swiper-item&gt; &lt;image src="../../images/slide.png"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../images/slide.png"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../images/slide.png"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;view class="portals"&gt; &lt;view class="item"&gt; &lt;image src="../../images/04.png"&gt;&lt;/image&gt; &lt;text&gt;私人FM&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/05.png"&gt;&lt;/image&gt; &lt;text&gt;每日歌曲推荐&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/06.png"&gt;&lt;/image&gt; &lt;text&gt;云音乐新歌榜&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="list"&gt; &lt;view class="title"&gt; &lt;text&gt;推荐歌单&lt;/text&gt; &lt;/view&gt; &lt;view class="inner"&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;view class="item"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;text&gt;一生中最爱的是谁谁？&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;!-- 播放控制条条 固定高度 --&gt; &lt;view class="player"&gt; &lt;view class="poster"&gt; &lt;image src="../../images/poster.jpg"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="info"&gt; &lt;text class="title"&gt;一生中最爱&lt;/text&gt; &lt;text class="artist"&gt;谭咏麟&lt;/text&gt; &lt;/view&gt; &lt;view class="controls"&gt; &lt;image src="../../images/01.png"&gt;&lt;/image&gt; &lt;image src="../../images/02.png"&gt;&lt;/image&gt; &lt;image src="../../images/03.png"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// index.wxsspage &#123; height: 100%;&#125;.root &#123; display: flex; flex-direction: column; height: 100%; background-color: #f0f0f0;&#125;.tabs &#123; display: flex; background-color: pink;&#125;.tabs .item &#123; flex: 1; text-align: center; font-size: 12px; background-color: #222; color: #ccc; padding: 8px 0;&#125;.tabs .item.active &#123; color: #fff; border-bottom: 2px solid #e9232c;&#125;.content &#123; flex: 1; background-color: #111214; color: #ccc; overflow: hidden;&#125;.slide image &#123; width: 100%; height: 130px;&#125;.portals &#123; display: flex; margin-bottom: 15px;&#125;.portals .item &#123; flex: 1;&#125;.portals .item image &#123; width: 60px; height: 60px; display: block; margin: 10px auto;&#125;.portals .item text &#123; display: block; font-size: 12px; text-align: center;&#125;.list .title &#123; margin: 5px 10px; font-size: 14px;&#125;.list .inner &#123; display: flex; flex-wrap: wrap;&#125;.list .inner .item &#123; width: 33.33333333%;&#125;.list .inner .item image &#123; display: block; width: 120px; height: 120px; margin: 0 auto;&#125;.list .inner .item text &#123; font-size: 14px;&#125;.player &#123; display: flex; height: 50px; background-color: #17181A;&#125;.poster image &#123; width: 40px; height: 40px; margin: 5px;&#125;.info &#123; flex: 1; color: #888; font-size: 14px; margin: 5px;&#125;.info .title&#123; display: block; font-size: 16px; color: #ccc;&#125;.controls image &#123; width: 40px; height: 40px; margin: 5px 2px;&#125; 123456// index.json&#123; "navigationBarTitleText": "Music Player", "navigationBarBackgroundColor": "#333", "navigationBarTextStyle": "white"&#125; 三、各种属性 flex-direction调整主轴方向（默认为水平方向） justify-content调整主轴对齐 align-items调整侧轴对齐（子元素可以使用align-self覆盖） flex-wrap控制是否换行 align-content堆栈（由flex-wrap产生的独立行）对齐 flex-flow是flex-direction + flex-wrap的简写形式 flex是子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配 order控制子项目的排列顺序，正序方式排序，从小到大]]></content>
      <tags>
        <tag>flex布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git克隆失败和解决办法]]></title>
    <url>%2Fgit%E5%85%8B%E9%9A%86%E5%A4%B1%E8%B4%A5%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git clone 失败，解决办法：–depth 1去github上面去clone一个项目，发现总是失败，网速太差？ 上网查了下原因，给我的git clone 项目地址后面加上--depth 1就好了 原因git clone 是克隆所有历史版本 而 –depth 1 是克隆最近一次的commit， 1 代表克隆深度]]></content>
      <tags>
        <tag>git克隆失败</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative豆瓣电影项目文档]]></title>
    <url>%2FReactNative%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[ReactNative豆瓣电影项目技能：react，react-native，android环境 项目目的：只做项目环境搭建和小部分功能以练习react-native基本功能和android上app的打包构建 项目地址：ReactNative豆瓣电影 ReactNative项目环境搭建参考我这个文档ReactNative项目环境搭建 首页在进行这一步之前，先确认项目环境搭建并打包下载到手机上没有任何问题之后，进行之后的代码编写和调试 如何更改首页知识点：View组件和Text组件 编写一个自己的首页：根目录下创建MyHomePage.js作为自己的首页 注意：在 RN 中只能使用 .js 不能使用 .jsx 123456789101112131415161718192021222324/** * 自己的首页 */// 导入 reactimport React, &#123; Component &#125; from 'react'// 按需导入组件， View 组件就好比网页中的 div 元素import &#123; View, Text &#125; from 'react-native'export default class MyHomePage extends Component &#123; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; // 1. 在 RN 中不能使用在网页中的所有标签 // 2. 如果想要实现布局，RN 提供了一个叫做 View 的组件，来实现布局， 想要使用，要先导入 return ( &lt;View&gt; &#123; /*3. 在 RN 中，所有的文本，必须使用 RN 提供的 Text 组件进行包裹，依然是按需导入*/ &#125; &lt;Text&gt;123456&lt;/Text&gt; &lt;/View&gt;) &#125;&#125; 在index.js中导入自己的组件 12345// 导入自己的组件页面import MyHomePage from './MyHomePage.js'// 当使用 AppRegistry 注册项目的时候，方法中的第一个参数不要改// 第二个参数表示要把哪个页面注册为首页AppRegistry.registerComponent(appName, () =&gt; MyHomePage); 组件的学习ReactNative组件 正式开始豆瓣电影项目练习了上面一些组件和属性之后，着手去做一个豆瓣电影的小项目 Tabbar基本结构使用组件react-native-tab-navigator react-native-tab-navigator使用方法：老套路，对照官方文档，装包=&gt;导入=&gt;使用 这里的装包，不推荐使用npm，首先下载慢，其次如果是npm5.X在装新包的时候会把一些老包删除，可能会出现猝不及防的惊喜~~~~ 我这里使用的是facebook开发的yarn装包 1yarn add react-native-tab-navigator // 默认是 --save 12// 导入 Tabbvar 相关组件import TabNavigator from 'react-native-tab-navigator' 1234567891011121314151617181920212223242526export default class MyHomePage extends Component &#123; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; // 1. 在 RN 中不能使用在网页中的所有标签 // 2. 如果想要实现布局，RN 提供了一个叫做 View 的组件，来实现布局， 想要使用，要先导入 return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TabNavigator&gt; &lt;TabNavigator.Item title="Home"&gt; // 放入组件 &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item title="Me"&gt; // 放入组件 &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt; &lt;/View&gt;); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1 &#125;&#125;); 这里的放入组件的位置是自己创建的组件，其他后面的自己创建的组件引入方式也是一样套路创建自己的组件=&gt;引入=&gt;使用 创建自己的新组件，components/tabars/Home.js和components/tabars/Me.js 两个组件都简单写下基本代码 12345678910import React, &#123; Component &#125; from 'react'import &#123; View, Text &#125; from 'react-native'export default class Search extends Component &#123; render() &#123; return &lt;View&gt; &lt;Text&gt;这是 Home 组件&lt;/Text&gt; &lt;/View&gt; &#125;&#125; 引入 12import Home from './components/tabbars/Home.js'import Me from './components/tabbars/Me.js' 使用 12345678910&lt;View style=&#123;styles.container&#125;&gt; &lt;TabNavigator&gt; &lt;TabNavigator.Item title="Home"&gt; &lt;Home&gt;&lt;/Home&gt; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item title="Me"&gt; &lt;Me&gt;&lt;/Me&gt; &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt;&lt;/View&gt;); 组件高亮和切换拿home组件举例子，官方文档上这两句加上就行了 12selected=&#123;this.state.selectedTab === 'home'&#125;onPress=&#123;() =&gt; this.setState(&#123; selectedTab: 'home' &#125;)&#125;&gt; Tab栏的四个组件都按照这样写完，就可以实现正常切换了 组件的图标用react-native-vector-icons的组件，安装=&gt;配置=&gt;导入=&gt;使用 安装1yarn add react-native-vector-icons 配置 在官方文档找到对应的手机平台配置，我这里应为开发的是Android，所以配置的是Android的 编辑 android/app/build.gradle( NOT android/build.gradle ) ,去这个文件中添加下面两行代码 12345project.ext.vectoricons = [ iconFontNames: [ 'MaterialIcons.ttf', 'EvilIcons.ttf', 'FontAwesome.ttf' ] // Name of the font files you want to copy]apply from: "../../node_modules/react-native-vector-icons/fonts.gradle" fonts文件找到自己的字体文件C:\Users\wanggongtou\Desktop\douban\node_modules\react-native-vector-icons\Fonts下面的所有文件全部复制放到android/app/src/main/assets/fonts，下面没有assets/fonts就手动创建一个，再复制进来 将下面两行代码放到android/settings.gradle下合适的位置，并把前面的+去掉 12+ include ':react-native-vector-icons'+ project(':react-native-vector-icons').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-vector-icons/android') 编辑 android/app/build.gradle ，找到dependencies的大括号内部加上compile project(&#39;:react-native-vector-icons&#39;) 1234dependencies &#123; ... compile project(':react-native-vector-icons')&#125; 编辑android\app\src\main\java\com\douban\MainApplication.java在package com.douban; 这句代码下面添加import com.oblador.vectoricons.VectorIconsPackage;这句代码，在同一个文件中，找到protected List&lt;ReactPackage&gt; getPackages()在其内部，加上, new VectorIconsPackage() 12345678910package com.douban;import com.oblador.vectoricons.VectorIconsPackage;@Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage() , new VectorIconsPackage() ); &#125; 注意：只要修改了Android里面的配置文件，要重新打包构建 重新打包构建1react-native run-android 这里可能会遇到两点问题： 问题一：提示没有licenses协议 解决方案：去配置Android的环境目录下，找到 Android SDK Manager 安装 Android SDK Build-tools 23.0.1 并接受其 license; 注意：这里的 Android SDK Build-tools 23.0.1 版本号需要和自己的构建工具版本号相对应 问题二：打包构建之后，发现手机上的app打开没有页面了 解决方案：关闭APP进程，重新打开一下就有了 导入1import Icon from 'react-native-vector-icons/FontAwesome' 使用可以去FontAwesome官网列表中查找对应组件需要的图标，Icon name=图标的名字就可以了 123456789&lt;TabNavigator&gt; &lt;TabNavigator.Item ... renderIcon=&#123;() =&gt; &lt;Icon name="home" size=&#123;25&#125; color="gray" /&gt;&#125; // 未选中状态下，展示的图标 renderSelectedIcon=&#123;() =&gt; &lt;Icon name="home" size=&#123;25&#125; color="#0079FF" /&gt;&#125; // 选中状态下展示的图标 ... &lt;Home&gt;&lt;/Home&gt; &lt;/TabNavigator.Item&gt;&lt;/TabNavigator&gt; 主页主页轮播图静态页面找组件react-native-swiper去官网看， 安装、导入、使用 1yarn add react-native-swiper 因为轮播图在主页，所以在主页的组件中进行导入 12// 导入轮播图组件import Swiper from 'react-native-swiper' 把对应的结构和样式全部都拷贝过来 123456789101112131415161718192021222324252627282930313233343536373839404142434445export default class Search extends Component &#123; render() &#123; return ( &lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125;&gt; &lt;View style=&#123;styles.slide1&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Hello Swiper&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide2&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Beautiful&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide3&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;And simple&lt;/Text&gt; &lt;/View&gt; &lt;/Swiper&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; wrapper: &#123; &#125;, slide1: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#9DD6EB', &#125;, slide2: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#97CAE5', &#125;, slide3: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#92BBD9', &#125;, text: &#123; color: '#fff', fontSize: 30, fontWeight: 'bold', &#125;&#125;) 这里轮播图就出来了，再设置自动轮播和轮播图高度，由于这里的轮播图默认充满全屏，所以可以给轮播图最外层套一个View，给它一个高度 123&lt;View style=&#123;&#123; height: 220 &#125;&#125;&gt; // 放轮播图代码&lt;/View&gt; 给Swiper盒子加上属性，自动轮播 123&lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125; autoplay=&#123;true&#125; loop=&#123;true&#125;&gt; ...&lt;/Swiper&gt; 渲染数据12345678910111213141516171819202122232425262728293031323334export default class Home extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; banner: [] // 轮播图数组 &#125; &#125; componentWillMount() &#123; fetch('http://www.liulongbin.top:3005/api/getlunbo') .then(res =&gt; res.json()) .then(data =&gt; &#123; // console.warn(JSON.stringify(data, null, ' ')) this.setState(&#123; banner: data.message &#125;) &#125;) &#125; render() &#123; return ( &lt;View style=&#123;&#123; height: 220 &#125;&#125;&gt; &lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125; autoplay=&#123;true&#125; loop=&#123;true&#125;&gt; &#123;this.state.banner.map((item, i) =&gt; &#123; return &lt;View key=&#123;i&#125;&gt; &lt;Image source=&#123;&#123;uri: item.img&#125;&#125; style=&#123;&#123;width: '100%', height: '100%'&#125;&#125;&gt;&lt;/Image&gt; &lt;/View&gt; &#125;)&#125; &lt;/Swiper&gt; &lt;/View&gt; ); &#125;&#125; 主页六宫格导入所需要的组件 1import &#123; AppRegistry, StyleSheet, View, Text, Image, TouchableHighlight &#125; from 'react-native' 12345678910// 六宫格区域&#123;/* 在 RN 中，默认，就已经为 所有的 View 启用了弹性和模型，同时，默认的主轴是 纵向的 */&#125; &lt;View style=&#123;&#123; flexDirection: 'row', flexWrap: 'wrap' &#125;&#125;&gt; &lt;View style=&#123;styles.box&#125;&gt; &lt;Image source=&#123;require('../../images/menu1.png')&#125; style=&#123;&#123; width: 60, height: 60 &#125;&#125;&gt;&lt;/Image&gt; &lt;Text&gt;新闻资讯&lt;/Text&gt; &lt;/View&gt; // ...这里根据需求可以增加主页的宫格数目，我这里是六个，上面代码复制六份就可以 &lt;/View&gt; 1234567var styles = StyleSheet.create(&#123; box: &#123; width: '33.33%', alignItems: 'center', marginTop: 15 &#125;&#125;) 热映电影Main.js 配置路由在项目根目录新建一个Main.js作为项目根组件，修改一下index.js中指向App.js的代码 12import Main from './Main.js'AppRegistry.registerComponent(appName, () =&gt; Main); 去编辑Main.js的代码 1234// Main 项目的根组件// 导入组件import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, ActivityIndicator &#125; from 'react-native' 安装一个配置路由规则的插件react-native-router-flux 1yarn add react-native-router-flux 在Main.js中导入 1import &#123; Router, Stack, Scene &#125; from 'react-native-router-flux' Router: 就相当于 HashRouterStack: 这是一个分组的容器，他不表示具体的路由，专门用来给路由分组的Scene：就表示一个具体的路由规则，好比 昨天学到的 Route 新建两个组件components/movie/MovieList.js和components/movie/MovieDetail.js作为电影列表组件和电影描述组件 而且由于更换了项目的根组件，所以需要在Main.js中导入App.js 1234// 导入组件import App from './App.js'import MovieList from './components/movie/MovieList.js'import MovieDetail from './components/movie/MovieDetail.js' 继续修改代码将App.js作为首页展示，在render渲染的时候，可以配置首页，并且一并配置其他页面路由 1234567891011121314render() &#123; return &lt;Router sceneStyle=&#123;&#123; backgroundColor: 'white' &#125;&#125;&gt; &lt;Stack key="root"&gt; &#123;/* 配置路由规则 */&#125; &#123;/* 注意，所有的路由规则，都应该写到这个位置 */&#125; &#123;/* 第一个 Scene 就是默认要展示的首页 */&#125; &#123;/* key 属性，表示路由的规则名称，将来可以使用这个 key ，进行编程式导航，每一个路由规则，都应该提供一个 唯一的key， key不能重复 */&#125; &lt;Scene key="app" component=&#123;App&#125; title="" hideNavBar=&#123;true&#125; /&gt; &#123;/* 电影列表的路由规则 */&#125; &lt;Scene key="movielist" component=&#123;MovieList&#125; title="热映电影列表" /&gt; &lt;Scene key="moviedetail" component=&#123;MovieDetail&#125; title="电影详情" /&gt; &lt;/Stack&gt; &lt;/Router&gt;&#125; 这个时候，依然是不能点击跳转的，是因为没有给Home.js内部的热映电影组件绑定点击事件，所以去帮顶下 用TouchableHighlight包裹Home.js中的热映电影的代码片段 1234567891011// 在使用前应该现在最前面导入该组件import &#123; AppRegistry, StyleSheet, View, Text, Image, TouchableHighlight &#125; from 'react-native' // 包裹 &lt;TouchableHighlight onPress=&#123;this.goMovieList&#125; underlayColor="white" style=&#123;styles.box&#125;&gt; &#123;/* 在 TouchableHighlight 内部，只能放置唯一的一个元素 */&#125; &lt;View&gt; &lt;Image source=&#123;require('../../images/menu5.png')&#125; style=&#123;&#123; width: 60, height: 60 &#125;&#125;&gt;&lt;/Image&gt; &lt;Text&gt;热映电影&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt;// goMovieList 方法在下面定义 导入Actions组件，实现编程式导航 123// 导入 Actions 组件，实现编程式导航// Actions 表示要进行 JS 操作了import &#123; Actions &#125; from 'react-native-router-flux' 写一个跳转方法,并去TouchableHighlight中绑定这个方法 123456render() &#123; ... goMovieList = () =&gt; &#123; Actions.movielist() &#125;&#125; 1&lt;TouchableHighlight onPress=&#123;this.goMovieList&#125; underlayColor="white" style=&#123;styles.box&#125;&gt; 这样就实现了基本的路由跳转 豆瓣热映电影列表基本页面123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, StyleSheet, ... &#125; from 'react-native'const styles = StyleSheet.create(&#123; ...&#125;)// 导入路由的组件import &#123; Actions &#125; from 'react-native-router-flux'export default class MovieList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; ... &#125; &#125; componentWillMount() &#123; ... &#125; render() &#123; return ... &#125; ...&#125; 豆瓣接口这里先说一下豆瓣接口，根据接口可以进行数据的获取 访问https://api.douban.com/v2/movie/in_theaters?start=0&amp;count=12可以看到豆瓣的电影数据，链接中的?后面的参数start表示开始页码，count表示每页显示的记录条数，可以根据需求修改，可以拷贝假数据用于测试，可以调用接口，用于测试方法成功之后进行动态数据的渲染 fetch获取电影列表数据 根据页码获取电影列表数据 渲染电影列表的方法测试 每项数据需要同步this.state中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default class MovieList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; movies: [], // 电影列表 nowPage: 1, // 当前的页码 totalPage: 0, // 总页数 pageSize: 15, // 每页显示的记录条数 isloading: true // 是否正在加载数据 &#125; &#125; componentWillMount() &#123; this.getMoviesByPage() &#125; render() &#123; return &lt;View&gt; &#123;this.renderList()&#125; &lt;/View&gt; &#125; // 根据页码获取电影列表 getMoviesByPage = () =&gt; &#123; const start = (this.state.nowPage - 1) * this.state.pageSize const url = `https://api.douban.com/v2/movie/in_theaters?start=$&#123;start&#125;&amp;count=$&#123;this.state.pageSize&#125;` /* fetch(url) .then(res =&gt; res.json()) .then(data =&gt; &#123; this.setState(&#123; isloading: false, movies: this.state.movies.concat(data.subjects), totalPage: Math.ceil(data.total / this.state.pageSize) &#125;) &#125;) */ /* 此代码用了拷贝的假数据用于测试 */ setTimeout(() =&gt; &#123; this.setState(&#123; isloading: false, movies: require('./test_list.json').subjects, totalPage: 1 &#125;) &#125;, 1000) &#125; // 渲染电影列表的方法,此处用于测试，若能获取电影条数则方法可以继续往下写 renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;View&gt; &lt;Text&gt;&#123;this.state.moives.length&#125;&lt;/Text&gt; &lt;/View&gt; &#125; ...&#125; 渲染电影列表数据12345678910111213141516171819202122232425// 渲染电影列表的方法 renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;FlatList data=&#123;this.state.movies&#125; keyExtractor=&#123;(item, i) =&gt; i&#125; // 解决 key 问题 renderItem=&#123;(&#123; item &#125;) =&gt; this.renderItem(item)&#125; // 调用方法，去渲染每一项 /&gt; &#125; // 渲染每项电影 renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight&gt; &lt;View&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#125; 美化布局相当于加一些样式，不然太丑了 123456789101112131415161718192021222324252627282930313233// 渲染电影列表的方法renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;FlatList data=&#123;this.state.movies&#125; keyExtractor=&#123;(item, i) =&gt; i&#125; // 解决 key 问题 renderItem=&#123;(&#123; item &#125;) =&gt; this.renderItem(item)&#125; // 调用方法，去渲染每一项 ItemSeparatorComponent=&#123;this.renderSeparator&#125; //渲染分割线的属性方法 onEndReachedThreshold=&#123;0.5&#125; // 距离底部还有多远的时候，触发加载更多的事件 onEndReached=&#123;this.loadNextPage&#125; // 当距离不足 0.5 的时候，触发这个方法，加载下一页数据 /&gt;&#125;// 渲染每项电影renderItem = (item) =&gt; &#123; return &lt;View style=&#123;&#123; flexDirection: 'row', padding: 10 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View style=&#123;&#123; justifyContent: 'space-around' &#125;&#125;&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt;&#125;// 渲染分割线renderSeparator = () =&gt; &#123; return &lt;View style=&#123;&#123; borderTopColor: '#ccc', borderTopWidth: 1, marginLeft: 10, marginRight: 10 &#125;&#125;&gt;&lt;/View&gt;&#125; 下拉加载更多利用官方文档的属性onEndReachedThreshold和onEndReached来控制 onEndReachedThreshold：距离底部还有多远的时候，触发加载更多的事件 onEndReached:当距离不足 0.5 的时候，触发这个方法，加载下一页数据 123456789101112131415161718192021222324252627282930313233343536373839404142// 渲染电影列表的方法 renderList = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;FlatList data=&#123;this.state.movies&#125; keyExtractor=&#123;(item, i) =&gt; i&#125; // 解决 key 问题 renderItem=&#123;(&#123; item &#125;) =&gt; this.renderItem(item)&#125; // 调用方法，去渲染每一项 ItemSeparatorComponent=&#123;this.renderSeparator&#125; //渲染分割线的属性方法 onEndReachedThreshold=&#123;0.5&#125; // 距离底部还有多远的时候，触发加载更多的事件 onEndReached=&#123;this.loadNextPage&#125; // 当距离不足 0.5 的时候，触发这个方法，加载下一页数据 /&gt; &#125; // 渲染每项电影 renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight underlayColor="#fff" onPress=&#123;() =&gt; &#123; Actions.moviedetail(&#123; id: item.id &#125;) &#125;&#125;&gt; &lt;View style=&#123;&#123; flexDirection: 'row', padding: 10 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View style=&#123;&#123; justifyContent: 'space-around' &#125;&#125;&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#125; // 加载下一页 loadNextPage = () =&gt; &#123; // 如果下一页的页码值，大于总页数了，直接return if ((this.state.nowPage + 1) &gt; this.state.totalPage) &#123; return &#125; this.setState(&#123; nowPage: this.state.nowPage + 1 &#125;, function () &#123; this.getMoviesByPage() &#125;) &#125; 提升体验写着写着，遇到了个问题，这时不时的访问不到服务，但是这好像和代码关系不大，因为我重连几次就可以了，我觉得和网速关系很大，我这网速太渣 所以我就加了几句提示错误的代码 123456789101112131415161718getMoviesByPage = () =&gt; &#123; const start = (this.state.nowPage - 1) * this.state.pageSize const url = `https://api.douban.com/v2/movie/in_theaters?start=$&#123;start&#125;&amp;count=$&#123;this.state.pageSize&#125;` fetch(url) .then(res =&gt; &#123; if (res.ok) &#123; return res.json() &#125; else &#123; console.error('服务器忙，请稍后重试' + res.status) &#125; &#125;) .then(data =&gt; &#123; ... &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) &#125; 豆瓣热映电影详情基本页面12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, ActivityIndicator, ScrollView &#125; from 'react-native'export default class MovieDetail extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; movieInfo: &#123;&#125;, // 电影信息 isloading: true &#125; &#125; componentWillMount() &#123; ... &#125; render() &#123; return &lt;View&gt; ... &lt;/View&gt; &#125; ...&#125; 同样的需要去Main.js配置路由规则，和配置MovieList组件的路由规则一个套路，这里由于我之前配置过了，不再配置 给MovieDetil在MovieList中的代码片段（就是渲染的每一部电影的代码片段）加上链接跳转，这里依然是要依靠TouchableHighlight组件 首先引入 1import &#123; View, Image, Text, ActivityIndicator, FlatList, StyleSheet, TouchableHighlight &#125; from 'react-native' 在获取每项电影的时候，代码片段用TouchableHighlight包裹起来 12345678910111213renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight underlayColor="#fff"&gt; &lt;View style=&#123;&#123; flexDirection: 'row', padding: 10 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: item.images.small &#125;&#125; style=&#123;&#123; width: 100, height: 140, marginRight: 10 &#125;&#125;&gt;&lt;/Image&gt; &lt;View style=&#123;&#123; justifyContent: 'space-around' &#125;&#125;&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影名称：&lt;/Text&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;电影类型：&lt;/Text&gt;&#123;item.genres.join('，')&#125;&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;制作年份：&lt;/Text&gt;&#123;item.year&#125;年&lt;/Text&gt; &lt;Text&gt;&lt;Text style=&#123;styles.movieTitle&#125;&gt;豆瓣评分：&lt;/Text&gt;&#123;item.rating.average&#125;分&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#125; 绑定点击事件，并导入Actions，实现编程式导航 12// 导入路由的组件import &#123; Actions &#125; from 'react-native-router-flux' 123456// 渲染每项电影renderItem = (item) =&gt; &#123; return &lt;TouchableHighlight underlayColor="#fff" onPress=&#123;() =&gt; &#123; Actions.moviedetail(&#123; id: item.id &#125;) &#125;&#125;&gt; ... &lt;/TouchableHighlight&gt;&#125; 数据渲染在生命周期是componentWillMount()的时候从接口获取数据，再到this.state同步数据，然后去render()填充数据，这里为render()定义了一个方法，直接this.renderInfo()调用就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from 'react'import &#123; View, Image, Text, ActivityIndicator, ScrollView &#125; from 'react-native'export default class MovieDetail extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; movieInfo: &#123;&#125;, // 电影信息 isloading: true &#125; &#125; componentWillMount() &#123; fetch('https://api.douban.com/v2/movie/subject/' + this.props.id) .then(res =&gt; res.json()) .then(data =&gt; &#123; this.setState(&#123; movieInfo: data, isloading: false &#125;) &#125;) &#125; render() &#123; return &lt;View&gt; &#123;this.renderInfo()&#125; &lt;/View&gt; &#125; renderInfo = () =&gt; &#123; if (this.state.isloading) &#123; return &lt;ActivityIndicator size="large"&gt;&lt;/ActivityIndicator&gt; &#125; return &lt;ScrollView&gt; &lt;View style=&#123;&#123; padding: 4 &#125;&#125;&gt; &lt;Text style=&#123;&#123; fontSize: 25, textAlign: 'center', marginTop: 20, marginBottom: 20 &#125;&#125;&gt;&#123;this.state.movieInfo.title&#125;&lt;/Text&gt; &lt;View style=&#123;&#123; alignItems: 'center' &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: this.state.movieInfo.images.large &#125;&#125; style=&#123;&#123; width: 200, height: 280 &#125;&#125;&gt;&lt;/Image&gt; &lt;/View&gt; &lt;Text style=&#123;&#123; lineHeight: 30, marginTop: 20 &#125;&#125;&gt;&#123;this.state.movieInfo.summary&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/ScrollView&gt; &#125;&#125; 提示：各种接口数据最好借助Postman工具，先看一下接口数据里哪些属性要用，不然挺乱的，不过不借助Psotman工具的话也可以去该接口连接把json数据拷贝下来到编辑器中，自己整理下格式 小功能体验：拍照功能为Me.js添加一个拍照功能 调用插件react-native-image-picker该插件可以调用摄像头 安装包 1yarn add react-native-image-picker 导入包 123import &#123; View, Button, Image &#125; from 'react-native'// 导入拍照的包import ImagePicker from 'react-native-image-picker' 创建拍照时的配置对象 1234567891011121314var photoOptions = &#123; //底部弹出框选项 title: '请选择', cancelButtonTitle: '取消', takePhotoButtonTitle: '拍照', chooseFromLibraryButtonTitle: '选择相册', quality: 0.75, // 照片的质量 allowsEditing: true, // 允许被编辑 noData: false, // 拍照时候不附带日期 storageOptions: &#123; // 存储选项 skipBackup: true, // 在IOS平台中，会自动把 照片同步到 云端的存储，如果此项为 true，表示跳过 备份，不会把照片上传到 云端 path: 'images' &#125;&#125; 创建保存数据的容器 123456constructor(props) &#123; super(props); this.state = &#123; imgURL: 'https://qqqww.com/uploads/avatar.png' // 将来，拍摄的照片路径，会存到这里 &#125; &#125; 渲染 123456render() &#123; return &lt;View style=&#123;&#123; alignItems: 'center', paddingTop: 70 &#125;&#125;&gt; &lt;Image source=&#123;&#123; uri: this.state.imgURL &#125;&#125; style=&#123;&#123; width: 200, height: 200, borderRadius: 100 &#125;&#125;&gt;&lt;/Image&gt; &lt;Button title="拍照" onPress=&#123;this.cameraAction&#125;&gt;&lt;/Button&gt; &lt;/View&gt; &#125; 定义一个拍照方法，在渲染的时候调用 12345678910111213cameraAction = () =&gt; &#123; ImagePicker.showImagePicker(photoOptions, (response) =&gt; &#123; console.log('response' + response); if (response.didCancel) &#123; // 点击了取消按钮，此时，用户没有拍照 return &#125; // 用户已经拍摄了一张照片了 this.setState(&#123; imgURL: response.uri &#125;); &#125;) &#125; 到这一步，在React-Native项目中的拍照功能就完成了，并且手机测试成功 发布安卓项目说明：这只是用于测试react-native的一部分功能的小demo，并不能用于实际作用 先保证配置了一个正确的RN环境 在 cmd 命令行中，运行这一句话keytool -genkey -v -keystore my-release-key2.keystore -alias my-key-alias2 -keyalg RSA -keysize 2048 -validity 10000生成签名 my-release-key.keystore 表示你一会儿要生成的那个 签名文件的 名称【很重要，包找个小本本记下来】 -alias 后面的东西，也很重要，需要找个小本本记下来，这个名称可以根据自己的需求改动my-key-alias 当运行找个命令的时候，需要输入一系列的参数，找个口令的密码，【一定要找个小本本记下来】 当生成了签名之后，这个签名，默认保存到了自己的用户目录下C:\Users\liulongbin\my-release-key2.keystore 将你的签名证书copy到 android/app目录下。 编辑 android -&gt; gradle.properties文件，在最后，添加如下代码： 1234MYAPP_RELEASE_STORE_FILE=your keystore filenameMYAPP_RELEASE_KEY_ALIAS=your keystore aliasMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** 编辑 android/app/build.gradle文件添加如下代码： 1234567891011121314151617181920...android &#123; ... defaultConfig &#123; ... &#125; + signingConfigs &#123; + release &#123; + storeFile file(MYAPP_RELEASE_STORE_FILE) + storePassword MYAPP_RELEASE_STORE_PASSWORD + keyAlias MYAPP_RELEASE_KEY_ALIAS + keyPassword MYAPP_RELEASE_KEY_PASSWORD + &#125; +&#125; buildTypes &#123; release &#123; ... + signingConfig signingConfigs.release &#125; &#125;&#125;... 进入项目根目录下的android文件夹，在当前目录打开终端，然后输入./gradlew assembleRelease开始发布APK的Release版； 第七步出了点小问题，报错信息是Execution failed for task ‘:app:validateSigningRelease’.后来看看原来是我的第五步里的MYAPP_RELEASE_KEY_ALIAS=your keystore alias这一块的签名写错了，忘了加后缀名，改了之后，又给了我一个响应超时的惊喜，不过我就重新运行了第二次就打包构建成功了 当发行完毕后，进入自己项目的android\app\build\outputs\apk目录中，找到app-release.apk，这就是我们发布完毕之后的完整安装包；安装到自己和朋友的手机上，测试成功，就可以上传到各大应用商店供用户使用啦。 注意：请记得妥善地保管好你的密钥库文件，不要上传到版本库或者其它的地方。 参考文章： ReactNative之Android打包APK方法（趟坑过程） React Native发布APP之签名打包APK]]></content>
      <tags>
        <tag>ReactNative豆瓣电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative组件]]></title>
    <url>%2FReactNative%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[#ReactNative组件 该文档要配合项目文档地址ReactNative豆瓣电影看会更好 这里只写我在进行ReactNative豆瓣电影项目的时候去ReactNative官网研究过的组件 Platform: 用来提供平台检测功能的 StyleSheet: 样式相关的组件，专门用来创建样式的 Text: 文本节点，所有文本必须放到这个里面 View: 用来布局的，相当于 div TextInput: 文本框组件 Image: 图片组件 Button: 按钮组件 ActivityIndicator: 加载中的 loading 效果小圆圈 ScrollView: 滚动组件（默认，如果一个RN的页面非常长，超出了屏幕高度，这时候，不会像网页中那样自动提 供滚动条，如果需要让页面实现滚动的话，需要使用 ScrollView 把页面包裹起来） 基本都是导入组件，然后在首页中用render()渲染就可以了，真是超级无敌爆炸爽 1234// 导入 React 基础包，这个包，作用是创建 组件import React, &#123; Component &#125; from 'react'// 从 react-native 中导入系统开发需要的包import &#123;Platform, StyleSheet, Text, View ...&#125; from 'react-native' ##Platform 用来提供平台检测功能 123456const instructions = Platform.select(&#123; ios: 'Press Cmd+R to reload,\n' + 'Cmd+D or shake for dev menu', android: 'Double tap R on your keyboard to reload,\n' + 'Shake or press menu button for dev menu',&#125;); ##StyleSheet 使用 StyleSheet.create 创建样式表对象，可以为 create 传递一个配置对象，这个对象就是要创建的样式 123456789101112131415161718const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', // 一些文本类型的样式值，需要引号包裹起来 alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, welcome: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;, instructions: &#123; textAlign: 'center', color: '#333333', marginBottom: 5, &#125;,&#125;); 载入样式(和对象的操作一样，例如style.welcome) 12345678910export default class App extends Component&lt;Props&gt; &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt;Welcome to React Native!&lt;/Text&gt; ... &lt;/View&gt; ); &#125;&#125; ##Text 文本节点，所有文本必须放到这个里面，在项目文档地址上面首页中有讲到 ##View 用来布局的，相当于页面元素div，在项目文档地址上面首页中有讲到 ##TextInput 文本框组件 这里刚开始输入框会特别窄，所以需要修改样式 在styles对象中添加一个一个键值对inputStyle: { width: &#39;100%&#39; } TextInput有很多属性选项，这里使用的几个练手,具体参考ReactNative官方文档 ###allowFontScaling 控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。 类型 必填 bool No ###autoCapitalize 控制TextInput是否要自动将特定字符切换为大写，This property is not supported by some keyboard types such as name-phone-pad. characters: 所有的字符。 words: 每个单词的第一个字符。 sentences: 每句话的第一个字符（默认）。 none: 不切换。 类型 必填 enum(‘none’, ‘sentences’, ‘words’, ‘characters’) No ###autoFocus 如果为true，在componentDidMount后会获得焦点。默认值为false。 类型 必填 bool No ###defaultValue 提供一个文本框中的初始值。当用户开始输入的时候，值就可以改变。在一些简单的使用情形下，如果你不想用监听消息然后更新value属性的方法来保持属性和状态同步的时候，就可以用defaultValue来代替。 类型 必填 string No ###keyboardType 决定弹出的何种软键盘的，譬如numeric（纯数字键盘）。 这些值在所有平台都可用： default number-pad decimal-pad numeric email-address phone-pad 下面的值仅iOS可用： ascii-capable numbers-and-punctuation url name-phone-pad twitter web-search 下面的值仅Android可用： visible-password 类型 必填 enum(‘default’, ‘email-address’, ‘numeric’, ‘phone-pad’, ‘ascii-capable’, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’, ‘visible-password’) No ###maxLength 限制文本框中最多的字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。 类型 必填 number No ###multiline 如果为true，文本框中可以输入多行文字。默认值为false。注意安卓上如果设置multiline = {true}，文本默认会垂直居中，可设置textAlignVertical: &#39;top&#39;样式来使其居顶显示。 类型 必填 bool No ###onChange 当文本框内容变化时调用此回调函数。回调参数为{ nativeEvent: { eventCount, target, text} }。 类型 必填 function No ###onChangeText 当文本框内容变化时调用此回调函数。改变后的文字内容会作为参数传递。 类型 必填 function No ###placeholder 如果没有任何文字输入，会显示此字符串。 类型 必填 string No ###placeholderTextColor 占位字符串显示的文字颜色。 类型 必填 color No ###secureTextEntry 如果为true，文本框会遮住之前输入的文字，这样类似密码之类的敏感文字可以更加安全。默认值为false。multiline={true}时不可用。 类型 必填 bool No ##Image 图片组件 Image的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 ###style 这里可以自定义样式，或者使用枚举 类型 必填 style 否 ###source 图片源数据（远程 URL 地址或本地数据）。 目前原生支持的图片格式有png、jpg、jpeg、bmp、gif、webp (仅 Android)、psd (仅 iOS)。 类型 必填 ImageSourcePropType 否 ##Button 按钮组件 Button的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 ###onPress 用户点击此按钮时所调用的处理函数, 必须的 类型 必填 function 是 ###title 按钮内显示的文本，必须的 类型 必填 string 是 ###accessibilityLabel 用于给残障人士显示的文本（比如读屏应用可能会读取这一内容） 类型 必填 string 否 ###color 文本的颜色(iOS)，或是按钮的背景色(Android) 类型 必填 color 否 ###disabled 设置为 true 时此按钮将不可点击。 类型 必填 bool 否 ###testID 用来在端到端测试中定位此视图。 类型 必填 string 否 ##ActivityIndicator 加载中的 loading 效果小圆圈 ActivityIndicator的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 ###animating 是否要显示指示器动画，默认为 true 表示显示，false 则隐藏。 类型 必填 bool 否 ###color 滚轮的前景颜色（默认为灰色）。 类型 必填 color 否 ###size 指示器的大小，默认为’small’。目前只能在 Android 上设定具体的数值。 类型 必填 enum(‘small’, ‘large’), number 否 ##ScrollView 滚动组件（默认，如果一个RN的页面非常长，超出了屏幕高度，这时候，不会像网页中那样自动提 供滚动条，如果需要让页面实现滚动的话，需要使用 ScrollView 把页面包裹起来） ScrollView的属性选项，这里使用的几个练手,具体参考ReactNative官方文档 ###horizontal 当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。 类型 必填 bool 否 滚轮的前景颜色（默认为灰色）]]></content>
      <tags>
        <tag>ReactNative组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative项目环境搭建]]></title>
    <url>%2FReactNative%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[ReactNative项目环境搭建项目地址：ReactNative豆瓣电影 看到github中ReactNative豆瓣电影的项目, 打算做一个基本功能的练练手，然后就项目基本配置中就遇到了不少坑，这里总结一下流程和遇到的一些坑，万一再遇到了，还能再来看解决方案 说明：ReactNative的项目建议由React开发经验的看会事半功效 ReactNative项目环境的搭建需要： android编译环境 手机设备能够正常连接电脑并通过adb devices指令测试连接正确 成功打包并安装到手机 基本开发环境首先，我是按照React Native中文网的方法，一步一步安装的，但并不成功，（错误信息大概描述的是android develepment or device安卓或者手机设备的问题，后面还有个fail connection连接失败）, 所以配合下面的android环境搭建和手机设备正确连接之后才成功，但是这些步骤在后续的环境搭建过程中肯定是有用到的 这里简述一下步骤： Chocolatey安装 Chocolatey是一个 Windows 上的包管理器，类似于 linux 上的yum和 apt-get。 你可以在其官方网站上查看具体的使用说明。一般的命令行安装步骤应该是下面这样： 1@powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 一般来说，使用 Chocolatey 来安装软件的时候，需要以管理员的身份来运行命令提示符窗口。译注：chocolatey 的网站可能在国内访问困难，导致上述安装命令无法正常完成。请使用稳定的翻墙工具。 如果你实在装不上这个工具，也不要紧。下面所需的 python2 和 nodejs 你可以分别单独去对应的官方网站下载安装即可。 Python 2安装 打开命令提示符窗口，使用 Chocolatey 来安装 Python 2. 1choco install python2 Node安装 打开命令提示符窗口，使用 Chocolatey 来安装 NodeJS。注意，目前已知 Node 7.1 版本在 windows 上无法正常工作，请避开这个版本！ 1choco install nodejs.install 安装完 node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！ 其实到这里我才知道为什么要安装另外一个包管理工具Chocolatey，原以为我安装过NodeJS的就不需要重新安装了（我以前使用cnpm安装的），但这个官方文档明显提到不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！所以我这里老老实实的又用choco指令安装了一遍Node 安装完 node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！ 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global Yarn、React Native 的命令行工具（react-native-cli） Yarn是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 1npm install -g yarn react-native-cli 安装完 yarn 后同理也要设置镜像源： 12yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 这里是官方提示的一个错误：但我的安装过程中没有遇到，先放到这 如果你遇到EACCES: permission denied权限错误，可以尝试运行下面的命令（限 linux 系统）： sudo npm install -g yarn react-native-cli. android环境搭建(Android Studio)1、这里是我是直接去官网下载的最新版Android Studio 下载下来就是这么个玩意： 2、一看到exe文件，直接安装嘛，这里建议不要随意安装到其他目录（因为第一次我就安装到了我自定义的我的个人dev目录中，就后面各种错误，后来卸载，重新开始），按照他默认的走，还有之后需要下载的插件选项，尽量他默认打钩的，不要去掉，然后再加上我建议的就行了 3、记住以上的钩都要选上，初步安装过程结束后，选择Custom选项 4、选择如下图的组件安装，都选上 5、这里遇到了这样一堆错误 1Preparing &quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot;.Downloading https://dl.google.com/android/repository/platform-tools_r28.0.0-windows.zip&quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot; ready.Installing Android SDK Platform-Tools in D:\Android\sdk\platform-tools&quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot; complete.&quot;Install Android SDK Platform-Tools (revision: 28.0.0)&quot; finished.Preparing &quot;Install Android Support Repository (revision: 47.0.0)&quot;.Downloading https://dl.google.com/android/repository/android_m2repository_r47.zipjava.io.IOException: Cannot download &apos;https://dl.google.com/android/repository/android_m2repository_r47.zip&apos;: SSL peer shut down incorrectly, response: 200 OKWarning: An error occurred while preparing SDK package Android Support Repository: Cannot download &apos;https://dl.google.com/android/repository/android_m2repository_r47.zip&apos;: SSL peer shut down incorrectly, response: 200 OK.&quot;Install Android Support Repository (revision: 47.0.0)&quot; failed.Preparing &quot;Install Android SDK Tools (revision: 26.1.1)&quot;.Downloading https://dl.google.com/android/repository/sdk-tools-windows-4333796.zipjava.io.IOException: Cannot download &apos;https://dl.google.com/android/repository/sdk-tools-windows-4333796.zip&apos;: Read timed out, response: 200 OKWarning: An error occurred while preparing SDK package Android SDK Tools: Cannot download &apos;https://dl.google.com/android/repository/sdk-tools-windows-4333796.zip&apos;: Read timed out, response: 200 OK.&quot;Install Android SDK Tools (revision: 26.1.1)&quot; failed.Preparing &quot;Install SDK Patch Applier v4 (revision: 1)&quot;.Downloading https://dl.google.com/android/repository/3534162-studio.sdk-patcher.zip.bakjava.io.IOException: Cannot download 没复制全，就大概讲的是插件安装失败，主要错误原因就是外国网站被墙或者网速实在太渣,为什么这样讲呢？因为我去网上查，都说是被墙，但我很确认我已经翻墙了啊，而且后面安装插件的过程中，一直重试，发现有些能成功，有些不能成功（这里要多看日志），所以我断定是网络过慢原因了，多重试，而且一定要开vpn 6、安装过程中，有一个选择主题的环节，一个白色的，一个黑色的，随便选一个，主题嘛，看着顺眼就行 下面就可以一直默认安装到最后有一个让你运行Android Studio ，然后直接运行，会到Android Studio的欢迎界面 ，它的有下角有个Configure, Configure下面有个SDK Manager,点击进去 7、在SDK Platforms窗口中，选择Show Package Details，然后在Android 6.0 (Marshmallow)中勾选Google APIs、Android SDK Platform 23、Intel x86 Atom System Image、Intel x86 Atom_64 System Image以及Google APIs Intel x86 Atom_64 System Image。这里遇到和6同样的问题，先看下面的第8步再apply 8、在SDK Tools窗口中，选择Show Package Details，然后在Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1（必须是这个版本）。然后还要勾选最底部的Android Support Repository.这里也遇到和6同样的问题 解决办法：两个 办法一：开VPN，我这里用的蓝灯 办法二：可以直接迅雷加速下载包到本地，然后一个一个放入该放的文件夹中，这里可以参考文档手动安装配置Android Studio，在本文后面我会把这里所需要的插件一整套，全部整理上传到我的百度云，这样从我的百度云下载应该就好多了，然后再参考前面的手动安装配置Android Studio文档手动配置也可以的 下面会有android环境依赖包、基本依赖包、vpn软件一整套的百度云链接 到这一步，Android Studio环境基本就配置好了 手机驱动安装###手机驱动查看和安装 这里要把手机连接到电脑上 前面android环境配置好之后，我又去测试了下，测试命令 1234// 初始化一个安卓仓库react-native init douban// 安装app到手机上react-native run-android 但是又发现报了一个错误设备不能连接或者是android环境问题 然后这里我去我的电脑=&gt;管理=&gt;设备管理器查看了下 我这里用驱动人生更新过了，所以红框中看起来一切正常，遇到设备问题一定要去电脑的驱动管理看看，看带!号的或者带?号的相关驱动去给更新下 到了这一步，然后我再来测试 手机设备的设置启用开发者模式这里拿我的小米手机举例 你的手机=&gt;设置=&gt;我的设备或者我的手机=&gt;全部参数=&gt;MIUI版本（其他手机找版本号就对了）=&gt;莲须点十几下基本上这时候就显示你已经处于开发者模式了 返回设置=&gt;更多设置=&gt;开发者选项=&gt;打开开发者选项和USB调试和USB安装和USB调试（安全设置） 由于到了这一步也翻了不少文档，我又多学了一条测试手机设备连接的指令 cmd命令行输入命令检测下 1adb devices 这是后命令行给到的结果就能显示成功连接了，下面再进行安卓环境初始化和打包安装到手机就可以成功了 1react-native init douban ####安装成功 这时候发现手机上多了一个叫douban的应用 回去node后台看看 这个窗口，就是React Native Packager 是帮我们实时编译项目源代码的，并把编译结果应用到手机上，可以让开发者随时查看最新的项目代码效果。 打开手机上刚安装的应用看看 就显示Welcome to React Native，这样就可以通过App.js入口文件进行开发和调试了 在手机上查看代码在Welcome to React Native界面常按左下角的菜单键，会弹出下图 android环境支持包百度云链接依赖包里有android环境依赖包、基本依赖包、vpn软件 链接：https://pan.baidu.com/s/1Oj2EUuuuNbKdQcoeUsc1AQ提取码：tbo6 参照文档搭建基本的开发环境 - 英文官网搭建基本的开发环境 - 中文]]></content>
      <tags>
        <tag>ReactNative豆瓣电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-虚拟DOM与Diff算法]]></title>
    <url>%2FReact-%E8%99%9A%E6%8B%9FDOM%2F</url>
    <content type="text"><![CDATA[虚拟DOM与Diff算法虚拟DOM(Virtual Document Object Model)的模拟DOM树操作需要用到DIff算法，推荐先看这句话下面的文章内容 DOM的本质 浏览器中的概念，用JS对象来表示 页面上的元素，并提供了操作 DOM 对象的API React中的虚拟DOM 框架中的概念，是程序员 用JS对象来模拟 页面上的 DOM 和 DOM嵌套 实现虚拟DOM的目的 为了实现页面中， DOM 元素的高效更新 DOM和虚拟DOM的区别 DOM：浏览器中，提供的概念；用JS对象，表示页面上的元素，并提供了操作元素的API 虚拟DOM：是框架中的概念；而是开发框架的程序员，手动用JS对象来模拟DOM元素和嵌套关系 本质： 用JS对象，来模拟DOM元素和嵌套关系 目的：就是为了实现页面元素的高效更新 如何实现页面元素的高效更新利用虚拟DOM可以实现页面元素的高效更新，那么如何实现页面元素的高效更新呢？ 假如我有一个需求：点击列头，实现表格数据顺序的排序 数据来源：表格中的数据从数据库查询而来 存储：这些查询到的数据以数组的形式，存放到了浏览器的内存中 渲染： 方案一：手动for循环整个数据，手动拼接字符串str += &#39;&lt;tr&gt;123&lt;tr&gt;&#39; 方案二：使用模板引擎，类似art-template，比手动更方便点，其内部本质也是拼接了字符串 思考：对于上述方案，思考其缺陷和解决方案 如果用户点击了时间,想要按照时间从大到小的排序，其流程应当是： 触发点击事件，在事件中，把内存中的对象数组，重新排序 当排序完成之后，页面时旧的，但是内存中的顺序是最新的 把最新的数据顺序渲染到页面上 上述方案只是实现了把数据渲染到页面中，但是并没有把性能做到最优，这里的第三步，完全可以按需渲染页面(只重新渲染排序中需要更新的数据所对应的页面元素)，以提高性能 DOM树实现按需渲染： 什么是DOM树： DOM结构，类似下图1中的结构 一个网页的呈现过程： 浏览器请求服务器获取HTML代码 浏览器在内存中，解析DOM结构, 并在浏览器中内存中渲染出一棵DOM树 浏览器把DOM树呈现到页面上 怎么按需更新：获取内存中新旧两棵DOM树，得到需要被按需更新得DOM树 如何获取到新旧两棵DOM树： 浏览器并没有直接提供获取DOM树的相关API，因此无法拿到内存中的DOM树 可以自己手动模拟新旧两棵DOM树 那么怎么去模拟DOM树呢 模拟一个DOM元素，假如网页上有一个div元素，怎么模拟呢？用js以字面量赋值的形式进行模拟，看下图模拟DOM元素 当旧的DOM发生改变，对比两棵DOM树的标签和值，如果都相等，则不变，如果标签相同，值不同，则修改，这样的新旧两棵树就是模拟DOM树 总结：什么是虚拟DOM 用JS对象的形式，来模拟页面上的DOM嵌套关系，即虚拟DOM是以JS对象的形式存在的 React中虚拟DOM对象的本质和目的： 本质：用JS对象来模拟DOM元素的嵌套关系 目的：实现页面元素的高效更新 Diff算法 tree diff上图中新旧两棵DOM树每一层对比的过程叫做tree diff，当整棵DOM树逐层对比完毕，则所有的按需更新的元素必然能够找到 component diff在进行tree diff的时候，每一层中组件级别的对比，叫做component diff 如果对比前后，组件类型相同，则暂时认为不需要更新组件 如果对比前后，组件类型不同，则需要暂时移除旧组件，创建新组件，追加到页面上 ###element diff 在进行组件对比的时候，如果两个组件类型相同，需要进行元素级别的对比，这叫做element diff]]></content>
      <tags>
        <tag>虚拟DOM与Diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-vuex]]></title>
    <url>%2Fvue-vuex%2F</url>
    <content type="text"><![CDATA[vuex描述本文档对于有一定vue项目环境搭建和配置的相关经验的人会更轻松的理解 什么是 vuex vuex 是 Vue 配套的公共管理数据工具，他可以把一些共享的数据，保存到 vuex 中，方便整个程序中的任何组件直接获取或者修改公共数据 为什么要用vuex下面原始的传值和vuex的区别与优缺点 兄弟组件之间传值定义中间实例vm进行传值，逻辑过于复杂 父子组件之间传值子向父传值，通过事件调用机制，父给子传值通过属性绑定，但如果嵌套过深的传值，难免会产生复杂的逻辑 引入vuexvuex相当于是项目共享数据仓库，全局共享数据存储区域，方便各个组件直接拿来使用，这样就少了很多复杂的逻辑 vuex安装和使用 安装 1npm i vuex -S 导入包到文件 1import Vuex from 'vuex' 注册 1Vue.use(Vuex) 实例化，得到一个数据仓储对象 123456789101112var store = new Vuex.store(&#123; state: &#123; // 可以把 state 对比 vue 组件中的 data ，专门用来存储数据 count: 0 &#125;, mutations: &#123; &#125;, getters: &#123; &#125;&#125;) 将 vuex 创建的实例对象挂载到 vm 实例上 12345const vm = new Vue(&#123; ... // store: store store&#125;) 在需要共享数据的组件中想要去访问 vuex 实例中的数据，需要通过this.$store.count来访问 例子####项目演示地址 git@github.com:ForeManWang/vuex-study.git 可以先去这里下载项目下来，跟着例子操作 创建基本项目结构和搭建vue环境和配置，不多赘述了 下载下来项目之后，在根目录自行安装所有依赖插件 1npm i state这里就是相当于第六步，去components/amount.vue 去访问 vuex 实例中的数据 这时候打开后台，打开页面刷新，发现就已经能够访问 vuex 中的数据了 moutations 操作数据加法需求 去components/counter.vue的methods中写了一个add方法 1&lt;input type="button" value="增加" @click="add"&gt; 1234567add() &#123; // 千万不要这么用，不符合 vuex 的设计理念 // 这种操作数据的方法相当于是自己的组件操作数据，假如数据紊乱，会不知道是谁操作的数据导致了数据紊乱，所以不利于后期维护 // 所以将需求告诉一个 &lt;库管员&gt; 让 &lt;库管员&gt; 去操作 // 这里就是要 vuex 仓库中的 mutations 提供的方法去操作对应的数据，这样假如维护中出现数据紊乱的情况，可以快速定位错误的原因，利于后期维护 this.$store.state.count++; &#125;, 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit(‘方法名’) 所以在components/counter.vue内部就这样调用 12345add() &#123; // 千万不要这么用，不符合 vuex 的设计理念 // this.$store.state.count++; this.$store.commit("increment");&#125;, 减法需求 去components/counter.vue的methods中写了一个remove方法 1&lt;input type="button" value="减少" @click="remove"&gt; 在main.js的moutations中定义 123subtract(state, obj) &#123; state.count -= (obj.c + obj.d)&#125; 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数； 去components/counter.vue中调用，需要传参 12 这样减法就实现了，实现一次性减obj.c + obj.d getters 包装数据 这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations main.js 12345getters: &#123; optCount: function (state) &#123; return '当前最新的count值是: ' + state.count &#125;&#125; counter.vue 123456computed:&#123; fullname: &#123; get()&#123;&#125;, set()&#123;&#125; &#125;&#125; 经过回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者；其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值 总结 state中的数据，不能直接修改，如果想要修改，必须通过mutations 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.*** 如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit(&#39;方法的名称&#39;， 唯一的一个参数) 如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用getters, 如果需要使用 getters ,则用this.$store.getters.***]]></content>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-读取文件方法封装]]></title>
    <url>%2Fnode-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[node读取文件方法封装&amp;Promise准备 一个空js文件和files文件里面放上三个文件，方便下面操作 载入核心模块 12const fs = require('fs')const path = require('path') 需求：封装一个方法，给你一个要读取文件的路径，你这个方法能帮我读取文件，并把内容返回给我 普通方式12345// 这是普通读取文件的方式 fs.readFile(path.join(__dirname, './files/1.txt'), 'utf-8', (err, dataStr) =&gt; &#123; if (err) throw err console.log(dataStr)&#125;) 但是这样达不到需求，所以就有了下面一种方式 简单封装一给一个路径参数fpath 12 由于读取文件是异步操作，不能直接在函数内部return,所以没有接收到返回值，在外部调用就是undefined 所以用callback接收一下 简单封装二封装一个给定文件路径，返回读取到的内容的读取文件的异步方法 12345678910function getFileByPath (fpath, callback) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) throw err // console.log(data) callback(data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), (data) =&gt; &#123; console.log(data) // 111&#125;) 这样基本就达到需求了，但是依然不能知道读取文件数据到底成功还是失败，没有明确的标识 简单封装三所以可以给 callback 规定两个参数，一个失败结果，一个成功结果 同时我们规定，如果成功后，返回结果应该位于 callback 结果的第二个位置，此时第一个结果由于没有出错，所以放一个 null ，如果失败了，则第一个结果放置 error 对象，第二个位置放置一个 undefined 123456789101112function getFileByPath (fpath, callback) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) throw err // console.log(data) callback(null, data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), (err, data) =&gt; &#123; // console.log(data) // 111 if (err) return console.log(err.message) console.log(data)&#125;) 这种情况下，不管成功还是失败，共用的是一个参数（不是很好理解），可以拆分为两个，成功一个回调，失败一个回调，这样更好理解 简单封装四1234567891011function getFileByPath (fpath, succCb, errCb) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) errCb(err) succCb(data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), function (data) &#123; console.log(data + '成功了')&#125;, function (err) &#123; console.log(err.message + '失败了')&#125;) 这样就基本封装完成，达到需求，并提示失败和成功，提升体验 Promise解决回调地狱假如我们使用上一种封装方法，去按顺序读取三个文件files/1.txt、files/2.txt、files/3.txt这样就需要嵌套 1234567891011getFileByPath(path.join(__dirname, './files/1.txt'), function (data) &#123; console.log(data) getFileByPath(path.join(__dirname, './files/2.txt'), function (data) &#123; console.log(data) getFileByPath(path.join(__dirname, './files/3.txt'), function (data) &#123; console.log(data) &#125;) &#125;)&#125;) 假如以上的嵌套有很多，还不止这样三个嵌套呢？就会成这样 这样就形成了回调地狱，由于函数查找变量的规则需要由内至外一层一层去查找，这样难免造成大量的资源浪费 引入Promise来解决回调地狱的问题 Promise介绍Promise是ES6中的一个对象，用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。 在浏览器控制台输入console.dir(Promise)可以看到 我们看图片中两个红框，第一个红框，Promise是一个构造函数 第二个红框是两个回调函数，reject()表示失败执行，resolve()表示成功后执行 点开prototype:Promise发现一个then方法和catch()方法，而then和catch方法和在Promise的原型对象中，所以可以用promise直接调用 Promise解决回调地狱这样就可以封装一个基于Promise读取文件的函数 12345678910const fs = require('fs')function getFileByPath(fpath) &#123; return new Promise (function (resolve, reject) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) return reject(err) resolve(data) &#125;) &#125;)&#125; 12345678910111213141516171819202122// 如果 ，前面的 Promise 执行失败，我们不想让后续的Promise 操作被终止，可以为 每个 promise 指定 失败的回调 getFileByPath('./files/11.txt') .then(function (data) &#123; console.log(data) // 读取文件2 return getFileByPath('./files/2.txt') &#125;, function (err) &#123; console.log('这是失败的结果：' + err.message) // return 一个 新的 Promise return getFileByPath('./files/2.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;).then(function (data) &#123; console.log(data) &#125;) 当 我们有这样的需求： 哪怕前面的 Promise 执行失败了，但是，不要影响后续 promise 的正常执行，此时，我们可以单独为 每个 promise，通过 .then 指定一下失败的回调； 有时候，我们有这样的需求，个上面的需求刚好相反：如果 后续的Promise 执行，依赖于 前面 Promise 执行的结果，如果前面的失败了，则后面的就没有继续执行下去的意义了，此时，我们想要实现，一旦有报错，则立即终止所有 Promise的执行。 1234567891011121314151617getFileByPath('./files/1.txt') .then(function (data) &#123; console.log(data) return getFileByPath('./files/22.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;) .catch(function (err) &#123; // catch 的作用： 如果前面有任何的 Promise 执行失败，则立即终止所有 promise 的执行，并 马上进入 catch 去处理 Promise中 抛出的异常； console.log('这是自己的处理方式：' + err.message) &#125;)]]></content>
      <tags>
        <tag>函数封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime添加自定义代码段]]></title>
    <url>%2Fsublime%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[sublime添加自定义代码段一：打来Sublime Text，在菜单栏找到“Tools（工具）”-&gt;”New Snippet（新代码段）” 二：Hello, ${1:this} is a ${2:snippet}.这块代码区域，可以直接删除，然后添加上你所需要的代码段进去，然后Ctrl + s保存，保存到默认文件夹，命名随意，假如你的命名是vuecode，那么你去书写你的代码时就需要通过vuecode来调用这个代码段 三：调用过程： Ctrl + Shift + P ======&gt; Snippet:vuecode =====&gt; enter 这时候代码段就自动添加到你需要的地方了]]></content>
      <tags>
        <tag>sublime添加自定义代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime安装插件&常用的sublime插件]]></title>
    <url>%2Fsublime%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[sublime安装插件&amp;常用的sublime插件其实sublime安装插件并不难，几步操作就好了，关键插件安装过程中总出现各种各样的错误，而且比较好的插件都有哪些呢？ 安装步骤 第一步：下载一个sublime，正版不正版，汉化不汉化的那就按照你个人要求制定就行，网上也有相应教程，我用的是官网的，然后加的汉化包 sublime官网 第二步：打开你的sublime , Ctrl + ` 切换到sublime控制台，控制台一共两块内容区域，第一块区域时监控代码运行进程的，不用管，当然出错也可以从这里查找，第二块区域根据你自己的是sublime2还是sublime3来选择代码复制粘贴进去并运行 sublime3 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) sublime2 1import urllib2,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 第三步：安装完成后，按 Ctrl+Shift+p (Windows)/ Command+Shift+p (Mac), 输入Install Packages，之后Sublime会自动下载插件列表，然后弹出一个小的下拉菜单让你填写想要下载的插件名称。 常见错误这里是我遇到过的一些问题：欢迎大佬们补充 直接无法安装插件网上看了一些文档，说是GWF被墙问题 错误提示如下： 解决办法： 1、开代理自己翻墙 2、直接下载插件，将下载的文件解压到Sublime Text3的Installed Packages目录下 解析错误还有个问题是包解析错误，需要自己去发现错误翻译下看看是不是这一类问题，我忘记错误代码了，这一类问题可能是网络原因，我换了个网，能用了 常用插件推荐下面推荐我安装的一些插件，主要参照了博客sublime常用插件 本文参考博客Package Control]]></content>
      <tags>
        <tag>sublime安装插件&amp;常用的sublime插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记一]]></title>
    <url>%2FES6%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ES6笔记一 ES6的笔记参考ECMAScript 6 入门 部署进度 这里使用阮一峰老师写的一个工具 ES-Checker用来检查各种运行环境对 ES6 的支持情况。访问ruanyf.github.io/es-checker，可以看到您的浏览器支持 ES6 的程度。运行下面的命令，可以查看你正在使用的 Node 环境对 ES6 的支持程度。 1234567$ npm install -g es-checker$ es-checker// 结果=========================================Passes 39 feature DetectionsYour runtime supports 92% of ECMAScript 6========================================= Babel转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 例子： 1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 Babel的配置文件.babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 1234567891011# 最新转码规则$ npm install --save-dev babel-preset-latest# react 转码规则$ npm install --save-dev babel-preset-react# 不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 然后，将这些规则加入.babelrc。 12345678&#123; &quot;presets&quot;: [ &quot;latest&quot;, &quot;react&quot;, &quot;stage-2&quot; ], &quot;plugins&quot;: []&#125; 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 本来这里想详细总结下各种转码，然后发现阮一峰老师写的是真的详细，请参见ECMAScript 6 入门]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基本属性配置]]></title>
    <url>%2Fwebpack%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack 基本属性配置1234567891011121314151617181920212223242526272829303132333435363738394041const path = require('path')module.exports = &#123; entry: &#123; // main是默认入口，也可以是多入口 main: './src/main.js' &#125;, // 出口 output: &#123; filename: './build.js', // 指定js路径 path: path.join(__dirname, '..', '', 'dist') // 最好是绝对路径 // 代表上一级的dist &#125;, module: &#123; // 一样的功能rules: webpack2.xx新加的 loaders: [ // require('./a.css||./a.js') &#123; test: /\.css$/, loader: 'style-loader!css=loader', //多个loader用!分割 //顺序是反过来的 2!1 多个loader &#125;, &#123; test: /\.(jpg|svg)$/, loaderL 'url-loader?limit=4096&amp;name=[name].[ext]', // limit=4096&amp;name=[name].[ext]' 多个参数之间用&amp;符号分割 //[name].[ext]内置提供的 options: &#123; limit: 4096, name: '[name].[ext]' &#125; &#125; ] &#125;, plugins: [ // 插件的执行顺序是依次执行的，和loader是反过来的 new htmlWebpackPlugin(&#123; template: './src/index.html', &#125;) // 将src下的template属性描述的文件根据当前配置的output.path，将文件移动到该目录。 // 在插件的执行过程中，它本身可以去拿当前所设置的webpack选项，便于对webpack选项的复用， ]&#125;]]></content>
      <tags>
        <tag>webpack配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 中全局变量与形参的赋值]]></title>
    <url>%2Fjavascript-%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BD%A2%E5%8F%82%E7%9A%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[javascript 中全局变量与形参的赋值现象定义数组 12345678var arr1,arr2,arr3;var arr4 = [ &#123;name:'zhangsan',age:'18'&#125;, &#123;name:'lisi',age:'18'&#125;, &#123;name:'wangwu',age:'18'&#125;, &#123;name:'zhaoliu',age:'18'&#125;, &#123;name:'xiaoming',age:'18'&#125;]; 创建一个change函数 123456function change(params)&#123; for(var i = 0; i&lt;params.length;i++)&#123; params[i].name = params[i].name +'miaomiaomiao' &#125; return params &#125; 将arr4赋值给arr1、arr2、arr3并打印，观察打印结果 12345678arr1 = arr4arr2 = arr4arr3 = arr4console.log(change(arr1)) // 对任意一个数组执行change函数console.log(arr4)console.log(arr1)console.log(arr2)console.log(arr3) 以下是打印结果 可以发现，当其中任何一个数组改变时，其他的数组的值也会跟着改变 原因在计算机的内存中，系统对变量的声明在栈中，而值是在堆中 画图理解 arr1 = arr4; arr2 = arr4; arr3 = arr4 的赋值只是将arr4的值的地址指向了arr1，arr2，arr3；内存中并没有为其创建内容空间，这样就导致直接或间接的修改变量的值，那么原始值都将被修改。]]></content>
      <tags>
        <tag>全局变量与形参的赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 中局部变量和形参同名冲突问题]]></title>
    <url>%2Fjavascript-%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%BD%A2%E5%8F%82%E5%90%8C%E5%90%8D%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[javascript 中局部变量和形参同名冲突问题新建一个数组 1234567var arr = [ &#123;name:'zhangsan',age:'18'&#125;, &#123;name:'lisi',age:'18'&#125;, &#123;name:'wangwu',age:'18'&#125;, &#123;name:'zhaoliu',age:'18'&#125;, &#123;name:'xiaoming',age:'18'&#125;] 局部变量和形参冲突的情况 12345678910function getList(i)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr[i].name == 'e')&#123; console.log('已遍历完整个数组') &#125; &#125; return arr[i]&#125;console.log(getList(1)) // undefined// 调用 getList(1)时，其结果并不是 &#123;tel:1234658,name:'b'&#125; , 而是 undefined 解决方法 将形参改变或者将循环体内变量改变一下 12345678910function getList(i) &#123; for(var j = 0; j &lt; arr.length; j++)&#123; if(arr[j].name == 'e')&#123; console.log('已遍历完整个数组') &#125; &#125; return arr[i]&#125;// console.log(getList(1)) // &#123; tel: 1234658, name: 'b' &#125;// 更改 循环体中 i 变量 为 j 结果就是想要的结果了]]></content>
      <tags>
        <tag>局部变量和形参同名冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将本地文件上传到github]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[将本地文件上传到github文件上传 桌面打开git命令面板 新建Git仓库 1git init 添加文件到git 12git add . // 或者下面一种git add README.md 添加此次更新内容描述 12 将本地仓库关联到github上 1git remote add origin git@github.com:ForeManWang/letao.git // 最后面的地址需要填写你自己github的项目地址 将代码上传到github 1git push -u origin master 常见错误执行代码git remote add origin git@github.com:ForeManWang/letao.git时出现错误：fatal: remote origin already exists 解决办法 执行命令 12git remote rm origingit remote add origin git@github.com:ForeManWang/letao.git 这样就解决了，后面再上传项目到github 1git push -u origin master]]></content>
      <tags>
        <tag>本地文件上传到github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之seo优化]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8Bseo%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HEXO SEO 优化最近用hexo搭建个人博客，但是去网上搜，搜什么都搜不到自己，这就很尴尬了，于是想到了seo优化，这里主要对google和baidu爬虫的优化 什么是 SEO SEO（Search Engine Optimization）:汉译为搜索引擎优化。是一种方式:利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是：为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力 =&gt;百度百科 建议: 最好一步一测，反正我遇到的坑无数个，由于之前没有一步一测，导致到后来错到哪都不知道，或者开启hexo debug服务命令，这样在本地站点根目会生成一个debug.log文件，就是你的错误日志，可以去查看，具体指令如下： 到站点目录下，开启git命令面板 1hexo s --debug 本地文章优化添加sitemap首先给你的文章生成sitemap文件 123npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎12 然后在站点配置文件_config.yml中添加以下代码(这里我在参考资料《HEXO SEO 高级优化》这篇博客中看到的配置，但是在我的配置里一应用就报错，所以我的没用到，我给注释起来了，具体配置和报错信息如下：) 1234567891011# 自动生成sitemap# sitemap:# path: sitemap.xml# baidusitemap:# path: baidusitemap.xml# 报错信息# =&gt; Error：FATAL duplicated mapping key at line 153, column 1:# ??path: baidusitemap.xml# ^# YAMLException: duplicated mapping key at line 153, column 1:# ??path: baidusitemap.xml 最后修改站点配置文件_config.yml 123456# URL 配置站点## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://qqqww.com # 这里应该更改为你自己的站点地址，我写的是我的root: /permalink: :title/ # 这里简化目录结构，后面也会讲到permalink_defaults: 每次hexo g后都会在/public目录下生成sitemap.xml和baidusitemap.xml，这就是你的站点地图，这里需要将站点地图提交到百度站长之家 添加 roborts.txt文件添加 roborts.txt文件到站点根目录source文件夹下 这里可以参照我的： 12345678910111213141516User-agent: *Allow: /Allow: /archives/Allow: /tags/Allow: /categories/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://qqqww.com/sitemap.xmlSitemap: http://qqqww.com/baidusitemap.xml 百度收录站点登录百度站长平台，在用户中心 =&gt; 站点管理添加你的站点网址 配置完站点属性后，进入最后一步：验证网站。有三种方式：文件验证、HTML标签验证、CNAME验证，文件验证和CNAME验证都比较简单，也有相对应的帮助文本，在此我选择的是HTML标签验证。 在主题的_config.yml文件中，设置：baidu_site_verification: true，如果没有该字段就手动添加。 在themes/next/layout/_partials/head.swig文件中添加下列代码 12345// 每个人的content值都不一致，请注意更换成你的content值&#123;% if theme.baidu_site_verification %&#125; &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;6K5YmdKWEx&quot; /&gt;&#123;% endif %&#125; 配置好后，重新发布站点，在百度站长页面完成验证。 百度链接提交 链接提交工具是网站主动向百度搜索推送数据的工具，本工具可缩短爬虫发现网站链接时间，网站时效性内容建议使用链接提交工具，实时向搜索推送数据。本工具可加快爬虫抓取速度，无法解决网站内容是否收录问题 主动推送 最为快速的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。 安装百度链接提交插件 1npm install hexo-baidu-url-submit --save 123456# 百度链接自动提交baidu_url_submit: count: 6 # 提交最新的链接数量 host: http://lianghuii.com # 在百度站长平台中注册的域名 token: # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 设置deploye 123456deploy: - type: git repo: github: git@github.com:MeanMouse/MeanMouse.github.io.git coding: git@git.coding.net:MeanMouse/blog.git - type: baidu_url_submitter 自动推送 是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。。 在主题配置文件将baidu_push设置为true 在路径themes\next\layout_scripts\下创建baidu_push.swig 文件，文件内容如下 12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) &#123; bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; &#125; else &#123; bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125; sitemap这里将之前生成的sitemap文件提交到百度站长 手动提交 如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度。 手动提交方式比较简单，按照官方提示就会使用 - -(这种方式确实好用，方便) 谷歌收录站点进行这个之前，首先友情提示下大佬们，最好开个vpn用，因为很多涉及谷歌服务，我这里用的是789vpn，网上有很多，可以去找，lantern也能用 打开 Google Search Console，添加博客地址。并进行相关验证,根据提示即可完成认证,认证成功如下： 认证方法其实这里方法和百度的类似，也有三种，我用的是直接下载文件，放到我的站点source目录下，然后我在git命令面板里输入以下指令（下面将这一套指令简称为更新并同步文件指令） 123hexo cleanhexo ghexo d 之后，我去google认证，发现并不能验证成功，后来去站点配置_config.yml下添加了一句代码，和百度的类似 1google-site-verification: true 这样就验证成功了，再去看看，验证成功吧的界面如下（这里用的是参考文档里验证成功的图片，其实都一样，下面发参考文档链接） 验证通过后点进入控制台测试robots.txt文件,没有错误和警告即可 提交 sitemap.xml 文件，点击右上角添加/测试站点地图输入 sitemap.xml 进行测试，测试无误后再提交文件 robots.txt验证和sitemap.xml验证通过，抓取网页，我这里给sitemap.xml和baidusitemap.xml都加进去了，虽然不知道是不是提交一个就可以了….. 输入框留空表示抓取首页，填入 about 表示抓取关于页面，抓取完成后,抓取因为验证原因,可能会有几种状态：完成、部分完成和已重定向等，直接提交就可以。 验证站点是否被收录 谷歌中输入：site:yousite，会有提示：(抓取需要时间。等几分钟) 以上就完成了百度和谷歌的搜索引擎抓取站点的功能 优化结构seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下： 123456# URL 配置站点## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://qqqww.comroot: /permalink: :title/permalink_defaults: 首页标题优化SEO最重要的是你的标题，一般搜索都是搜索你的标题。 更改index.swig文件(your-hexo-site\themes\next\layout); 将下面这段代码： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 这时候你的首页会更符合网站名称 - 网站描述这习惯。 进阶，做了seo优化，把关键词也显示在title标题里，可改成： 1&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125;&#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 注意：别堆砌关键字，整个标题一般不超过80个字符，可以通过chinaz的seo综合查询检查。 关键词与描述搜索引擎除了主要抓取标题外，页面的关键词和描述也会抓取。 在\scaffolds\post.md中添加如下代码，用于生成的文章中添加关键字和描述。 12keywords: description: 在\themes\next\layout_partials\head.swig有如下代码，用于生成文章的keywords。暂时还没找到生成description的位置。 1234567&#123;% if page.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; page.keywords &#125;&#125;&quot; /&gt;&#123;% elif page.tags and page.tags.length %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;&quot; /&gt;&#123;% elif theme.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; theme.keywords &#125;&#125;&quot; /&gt;&#123;% endif %&#125; 然后在\themes\next\layout_macro\post.swig中找到这个位置： 1&#123;% if post.description %&#125; 将以下代码去掉： 1234567&#123;% if post.description %&#125; &#123;&#123; post.description &#125;&#125; &lt;div class=&quot;post-more-link text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; 否则首页的文章摘要就会变成文章的description。 举个例子： 123456789101112---title: HEXO SEO优化方法总结copyright: truetop: 0date: 2018-07-19 21:17:42tags: SEOcategories: Debianpermalink:password:keywords: [HEXO,HEXO SEO优化]description: 总结一下使用Hexo搭建博客后，SEO优化方案的总结，后期会不定期更新。--- nofollow 标签给非友情链接的出站链接添加 “nofollow” 标签，nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 以hexo的NexT主题为例，需要修改两处 一：找到footer.swig，路径在your-hexo-site\themes\next\layout_partials，将下面代码 改成： 将下面代码： 1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; 改成： 1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt; 二：修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout_macro，将下面代码 1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 改成： 1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 将下面代码： 1&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt; 改成： 1&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt; 安装nofollow插件 减少出站链接能够有效防止权重分散，hexo有很方便的自动为出站链接添加nofollow的插件。 1npm install hexo-autonofollow --save 该插件会将博客中的出站链接自动加上nofollow属性，例外请在站点配置文件_config.xml中添加如下字段 1234nofollow: enable: true exclude: - https://qqqww.com // 友链地址 这样，例外的链接将不会被加上nofollow属性。 开启SEO优化选项hexo博客next提供了seo优化选项，在主题配置文件_config.yml中有个选项是seo，默认是false，改成true即开启了seo优化，会进行一些seo优化，如改变博文title等，然后相同文件下有个关键字选项keywords，填充上，写博文时最好每篇博文都加上keywords。 我用的是next的主题，把该主题的_config.yml的默认keyword改成你的网址关键词 12# Set default keywords (Use a comma to separate)keywords: &quot;wanggongtou&quot; 开启压缩文件因为hexo生成的文件是静态html，里面占用了大量的空白符。使用gulp进行压缩接口提高访问速度并且降低内存。 使用命令 1234npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --savenpm install gulp-concatnpm install gulp-imagemin 在hexo blog文件夹下创建gulpfile.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var gulp = require(&apos;gulp&apos;), uglify = require(&apos;gulp-uglify&apos;), cssmin = require(&apos;gulp-minify-css&apos;), imagemin = require(&apos;gulp-imagemin&apos;), htmlmin = require(&apos;gulp-htmlmin&apos;), htmlclean = require(&apos;gulp-htmlclean&apos;); concat = require(&apos;gulp-concat&apos;);//JS压缩gulp.task(&apos;uglify&apos;, function() &#123; return gulp.src([&apos;./public/js/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;])//只是排除min.js文件还是不严谨，一般不会有问题，根据自己博客的修改我的修改为return gulp.src([&apos;./public/**/*.js&apos;,&apos;!./public/zuoxi/**/*.js&apos;,,&apos;!./public/radio/**/*.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public/js&apos;));//对应修改为./public即可&#125;);//public-fancybox-js压缩gulp.task(&apos;fancybox:js&apos;, function() &#123; return gulp.src(&apos;./public/vendors/fancybox/source/jquery.fancybox.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public/vendors/fancybox/source/&apos;));&#125;);// 合并 JSgulp.task(&apos;jsall&apos;, function () &#123; return gulp.src(&apos;./public/**/*.js&apos;) // 压缩后重命名 .pipe(concat(&apos;app.js&apos;)) .pipe(gulp.dest(&apos;./public&apos;));&#125;);//public-fancybox-css压缩gulp.task(&apos;fancybox:css&apos;, function() &#123; return gulp.src(&apos;./public/vendors/fancybox/source/jquery.fancybox.css&apos;) .pipe(cssmin()) .pipe(gulp.dest(&apos;./public/vendors/fancybox/source/&apos;));&#125;);//CSS压缩gulp.task(&apos;cssmin&apos;, function() &#123; return gulp.src([&apos;./public/css/main.css&apos;,&apos;!./public/css/*min.css&apos;]) .pipe(cssmin()) .pipe(gulp.dest(&apos;./public/css/&apos;));&#125;);//图片压缩gulp.task(&apos;images&apos;, function() &#123; gulp.src(&apos;./public/uploads/*.*&apos;) .pipe(imagemin(&#123; progressive: false &#125;)) .pipe(gulp.dest(&apos;./public/uploads/&apos;));&#125;);// 压缩 public 目录 html文件 public/**/*.hmtl 表示public下所有文件夹中html，包括当前目录 gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;)) &#125;);gulp.task(&apos;build&apos;, [&apos;uglify&apos;, &apos;cssmin&apos;, &apos;fancybox:js&apos;, &apos;fancybox:css&apos;, &apos;jsall&apos;,&apos;images&apos;]);//, &apos;minify-html&apos; 在根目录下的package.json文件中生成写入scripts: 1&quot;scripts&quot;: &#123;&quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp build&quot;&#125; 这样每次输入npm run build就会自动清理上次生成的文件，然后生成新的文件，最后压缩文件。 站内优化这里就真正的涉及到SEO的相关知识了，对你的文章的结构，描述，关键词进行优化。 title优化搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。 1用法：&lt;title&gt;网站标题&lt;/title&gt; 注意点： 首页title写法：首页的title写法格式一般是“总标题-特别重要的关键词或者一句话含有特别重要关键词的描述”。注意这里的“-”是英文，要问我为什么呢?这个因为互联网不是我们国内开发的，汉语不是标准，计算机只对英语敏感性较高，而对汉语敏感性不太高。 栏目页title写法：栏目页title的写法有两种，关键词名称命名写法是“栏目名称-总名称”，非关键词命名写法是：“栏目名称 栏目关键词-总名称”。 分类列表页的title写法：用关键词为这个栏目起名，然后按照下列顺序填写便可了“分类列表页名称-栏目名称-总名称”。 注意事项： 每个标题应该是根据当前内容设置的独特不重复的。 字数限制。不能太长，要不然搜索引擎结果列表会显示不全。最好不超过 25 个中文字。最好是在 10~20 之间。 切勿堆砌关键词。这是很多人常犯的错误 关键词最好出现在最前面 标题有吸引力。毕竟有吸引力的标题才能让用户点击 连词符的使用。可以使用 |-&gt; 不要使用没有意义的句子 keywords优化主要作用是告诉搜索引擎，这个网站内容是什么。因为，好多站长在keywords堆砌关键词，所以好多搜索引擎不太重视keywords了。建议大家还是认真填写keywords，有的搜索引擎还是很重视的，由于现在词频和密度对于 SEO 影响不大，所以只要保持你的正文中出现 4~6 次关键词就可以了。千万不能堆砌关键词。 注意点： 首页keywords写法：首页keywords按照选定的栏目名称，在首页的keywords中加入总名称、栏目名称和一两个关键词。 栏目keywords写法：栏目的keywords其栏目下所有分类列表的名称列出，加上栏目关键字，写法是“栏目名称,栏目关键字,栏目分类列表名称” 分类列表页keywords写法：将你这个栏目中的主要关键字写入。 Description优化功能让搜索引擎是判断整个页面内容的，当中要写入的内容是你页面内容的简介。description一般不超过100个字符。对于个人站点而言，描述标签最好是一句通顺的句子，如果不能的话，则宁可不要。 注意点： 首页description写法：description的写法就是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍形式，不要只写关键词。 栏目description写法：将栏目的标题、关键字、分类列表名称，尽量的写入description中，仍是尽量写成介绍形式。 分类description写法：是将你这个栏目中的主要关键字写入。 H标签优化H 标签的重要性可能是仅次与页面标签。H1-&gt;H6 的重要性依次降低。 所以建议在页面的 H1 和 H2 标签中混入关键词 图片 ALT 文字优化插入图片的时候会提示输入文字，这个不能敷衍。图片 ALT 文字出现的关键词对页面相关性也有一定的影响。同样的，也不要在 ALT 上堆砌关键词。 内部链接及锚文字优化内部链接对于爬行和收录具有很重要的意义。内部链接对页面关键词相关性也有影响，最主要的就是在内部链接中使用锚文字。 锚文字是告诉搜索引擎被链接页面主题内容的最重要依据之一。我们有时候可能无法控制外部链接的锚文字，但是对于站内的内部链接锚文字我们可以控制。不过有几点需要注意： 适当出现匹配关键词的锚文字 锚文字不能集中导航或者页尾，要分散在正文中 本文参考文档以下三篇 HEXO SEO 高级优化 Hexo Seo优化让你的博客在google搜索排名第一 Hexo SEO设置]]></content>
      <tags>
        <tag>hexo seo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Git安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BGit%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[windows 环境下 Git 安装一、安装：官网下载对应 exe 文件直接安装 我电脑是win10 64位的，这里讲的是在windows下安装的Git 下载地址 下载之后，一直next就可以了 二、配置：配置环境变量 win + r 打开windows运行面板 输入 sysdm.cpl 打开系统属性面板 选择系统属性面板上的高级 选择环境变量 双击path,添加一条你安装git的路径即可，我这里是E:\Develop\Git\Git\cmd 三、检测是否安装成功 到任意位置下，鼠标右键出现Git Bash Here和Git GUI Here即视为成功 四、整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>Git安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装逼路上的小插曲一：博客上传图片无法显示]]></title>
    <url>%2F%E8%A3%85%E9%80%BC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%B0%8F%E6%8F%92%E6%9B%B2%E4%B8%80%EF%BC%9A%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[博客上传图片无法显示有些日子，不知不觉就过去了…… 有些坑，不知不觉就进了，我也很无奈啊 废话不说了，这里参照了————大佬的文档 简单总结下： 站点下配置文件_config.yml修改，找到post_asset_folder(如果没有，自己写一个)，默认值一般是false，修改为true。 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 1npm install https://github.com/CodeFalling/hexo-asset-image --save 安装后再站点根目录下执行命令hexo new &quot;我的测试博客&quot;，在hexo/source/_post文件夹下不仅会生成对应的.md文件，还有一个同名的文件夹，用于存放该文件相关的资源。 1npm new "我的测试博客" 这个时候在写.md文档的时候，只需要图片链接为我的测试博客/[图片名].png即可 这里是利用相对路径解决了这一问题，详细请参照大佬的博客 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>博客上传图片无法显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Github账号注册]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BGithub%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[GitHub账号注册##注册流程 点击进入Github官网 注册之后，登录，创建一个测试项目可以点击右上角红框位置 点击Create repository之后就可以创建一个测试项目了 新建一个分支 分支是用来同时处理存储库不同版本的方法；默认情况下你的存储库会有一个分支master作为主分支 。 输入分支名称，enter即可 在分支上可以进行修改和提交，具体还可以使用Git指令进行项目的下载，修改和上传，如果没有Git的，请参照我同一个系列的另一篇文章，点击hexo搭建个人博客之Git安装 Git的一些指令 本地任意位置打开Git面板 1234Git init // 初始化一个Git仓库，后面可以跟仓库名Git pull git@github.com:ForeManWang/test.git // 上传文件到项目地址，指令后面跟的是项目地址，具体查看方法，下面有Git clone git@github.com:ForeManWang/test.git // 下载文件到本地，指令后面跟的是项目地址，具体查看方法，下面有...... Github项目地址：见下图 github上的概念说明仓库(Repository) 假如想在Github上面开源一个项目,那就必须的创建一个Repostitory,如果你开源的项目多了,就拥有了多个Repostitory 收藏(star) 右上角star数量，收藏该项目的人数 复制克隆项目(Fork) 将别人的开源项目复制一份到自己的仓库中(本质是在原有项目基础上打了一个分支)，可在复制的仓库中进行修改，修改成自己想要的样子 发起请求(Pull Request) 发起请求,这个是基于Fork的,相当于在Fork了别人的项目之后,自己做了一些修改,想要分享给更多的人,这个时候可以把代码提交(Pull Request)给原有的项目,若原有项目经过测试或者review代码确认后,原有项目就可拥有这些新的代码了. 关注(Watch) 关注，当关注了某个仓库，仓库发生变化，就会在邮箱等收到通知 事物卡片(issue) 发现bug，讨论时使用 Github主页 帐号创建成功或者点击点击导航栏图标可进入主页,该页面主要展示用户的动态以及关注的仓库的动态,右侧展示所有的git仓库. 仓库主页 仓库主页主要显示项目的信息,如:项目代码,版本,收藏/关注/fork等等各种情况. 个人主页 个人信息,头像,关注我的人,我关注的人,我关注的仓库,我的开源仓库. 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示 本文参考： （https://blog.csdn.net/lezaimemecha/article/details/84969353）]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Hexo安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[hexo搭建个人博客之Hexo安装什么是hexo一个快速高效的博客框架 安装hexo安装hexo之前，先确认自己必须已经安装了NodeJs和Git和已经拥有了GitHub账号，可以参照以下三篇文章 Git详细安装教程————点击此处 GitHub账号注册详细教程————点击此处 NodeJs详细安装过程和环境配置————点击此处 如果以上步骤已经全部完成，去任意一个位置，右键打开Git面板，输入以下指令 1npm install -g hexo-cli 等待一会，安装之后，继续输入指令 1hexo -v // 有版本号则成功 成功安装之后，就可以创建一个博客了，详细请见hexo搭建个人博客总流程 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>hexo安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之NodeJs安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BNodeJs%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[NodeJs 安装与环境配置安装这里只介绍windows环境下的NodeJs安装 这里是官网请点击 图片中左边稳定版，右边最新版 点击，下载，是一个msi文件，直接安装就可以，记住你的安装路径，后面做环境配置 安装之后就可以做配置了 配置不知道怎么做环境配置的点击这里查看,同样的道理 测试打开命令行面板，输入以下指令 1node -v npmnpm即包管理工具，一般安装完NodeJs之后，npm是附带安装上去的，所以，同样的执行命令行命令 1npm --version nvmnvm即版本管理工具，详细参考点击这里 整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>NodeJs安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客详细教程]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hexo个人博客一 Git 安装及GitHub账号注册Git详细安装教程————点击此处 GitHub账号注册详细教程————点击此处 二 NodeJS 安装NodeJs详细安装过程和环境配置————点击此处 三 Hexo 安装Hexo基本框架搭建过程————点击此处 四 基本主题next开启GitPages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 登录Github，右上角创建一个项目，也可以参照我的另外一个同系列的文章 hexo搭建个人博客之Github账号注册 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。 点击Create Repository之后，选择settings 进入如下： 找到GitHub Pages找到choose theme 之后进入主题仓库,任意选择一个主题，这里我选择的是这个 此时再去查看settings,会发现GitHub Pages变化如下 现在，我们就可以使用https://UserName.github.io，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)： 备注：由于我的有一个服务已经在开着了，电脑太卡了，这里借用参考文档的图片 创建一个本地博客站点打开windows命令面板，输入以下指令 1hexo init myBlog 测试本地博客12hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 此时打开浏览器，输入 http://localhost:4000/，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)： 同步GitHub，允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地站点的配置_config.yml文件，修改deploy下的配置如下： 1234deploy: type: git // 类型为 git repository: git@github.com:ForeManWang/ForeManWang.github.io.git // 这里写仓库地址 branch: master 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 下载主题-Next(官网)安装Git部署插件12345npm install hexo-deployer-git --save // 有版本号即成功// 部署指令hexo clean // 每次同步之前操作，清理缓存hexo g //将md文档生成博客hexo d //同步到github 下载Next,参考安装包，或直接克隆1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在 Hexo 中有2份主要的配置文件，其名称都是_config.yml。一份是站点配置文件，在站点根目录下另一份是主题配置文件，在主题目录下，比如我们这里用到的是next主题，则在myHexoBlog\themes\next下 打开themes/next/下的_config.yml,查找scheme，可以看到四种不同的风格。去掉#注释，即启用对应的scheme，博主采用Gemini主题，大家可以依次测试效果，选择自己喜欢的scheme。打开根目录下的_config.yml，查找theme字段，将字段改为theme: next(冒号:之后要有空格分隔，否则无效) 之后通过hexo g和hexo s，再在浏览器中访问localhost:4000即可本地预览主题效果。 主题基础配置设置过程中，可运行在本地查看，步骤跟之前一样(注意所有的：后面都要空一格!!!)。 设置菜单找到主题next的_config.yml查找menu`，去掉#注释即可显示对应的菜单项。 设置网站基本信息和语言找到站点的_config.yml，找到Site如下设置。 设置个人信息找到主题next的_config.yml，找到social如下设置。 设置头像进入themes/next/source/uploads下，找到avatar.png，放入一张同样大小的图片替换名字。之后找到主题next的_config.yml，找到avatar如下设置。 更多美化next主题参考请点击next美化主题1-4 hexo seo优化整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示 本文参考文档Hexo搭建个人博客（一）——框架搭建 Hexo搭建个人博客网站详细流程 Hexo博客搭建]]></content>
      <tags>
        <tag>hexo搭建个人博客</tag>
      </tags>
  </entry>
</search>
