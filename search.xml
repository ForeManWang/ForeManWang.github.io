<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React-Diff算法]]></title>
    <url>%2FReact-Diff%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[React-虚拟DOM与Diff算法]]></title>
    <url>%2FReact-%E8%99%9A%E6%8B%9FDOM%2F</url>
    <content type="text"><![CDATA[虚拟DOM与Diff算法虚拟DOM(Virtual Document Object Model)的模拟DOM树操作需要用到DIff算法，推荐先看这句话下面的文章内容 DOM的本质 浏览器中的概念，用JS对象来表示 页面上的元素，并提供了操作 DOM 对象的API React中的虚拟DOM 框架中的概念，是程序员 用JS对象来模拟 页面上的 DOM 和 DOM嵌套 实现虚拟DOM的目的 为了实现页面中， DOM 元素的高效更新 DOM和虚拟DOM的区别 DOM：浏览器中，提供的概念；用JS对象，表示页面上的元素，并提供了操作元素的API 虚拟DOM：是框架中的概念；而是开发框架的程序员，手动用JS对象来模拟DOM元素和嵌套关系 本质： 用JS对象，来模拟DOM元素和嵌套关系 目的：就是为了实现页面元素的高效更新 如何实现页面元素的高效更新利用虚拟DOM可以实现页面元素的高效更新，那么如何实现页面元素的高效更新呢？ 假如我有一个需求：点击列头，实现表格数据顺序的排序 数据来源：表格中的数据从数据库查询而来 存储：这些查询到的数据以数组的形式，存放到了浏览器的内存中 渲染： 方案一：手动for循环整个数据，手动拼接字符串str += &#39;&lt;tr&gt;123&lt;tr&gt;&#39; 方案二：使用模板引擎，类似art-template，比手动更方便点，其内部本质也是拼接了字符串 思考：对于上述方案，思考其缺陷和解决方案 如果用户点击了时间,想要按照时间从大到小的排序，其流程应当是： 触发点击事件，在事件中，把内存中的对象数组，重新排序 当排序完成之后，页面时旧的，但是内存中的顺序是最新的 把最新的数据顺序渲染到页面上 上述方案只是实现了把数据渲染到页面中，但是并没有把性能做到最优，这里的第三步，完全可以按需渲染页面(只重新渲染排序中需要更新的数据所对应的页面元素)，以提高性能 DOM树实现按需渲染： 什么是DOM树： DOM结构，类似下图1中的结构 一个网页的呈现过程： 浏览器请求服务器获取HTML代码 浏览器在内存中，解析DOM结构, 并在浏览器中内存中渲染出一棵DOM树 浏览器把DOM树呈现到页面上 怎么按需更新：获取内存中新旧两棵DOM树，得到需要被按需更新得DOM树 如何获取到新旧两棵DOM树： 浏览器并没有直接提供获取DOM树的相关API，因此无法拿到内存中的DOM树 可以自己手动模拟新旧两棵DOM树 那么怎么去模拟DOM树呢 模拟一个DOM元素，假如网页上有一个div元素，怎么模拟呢？用js以字面量赋值的形式进行模拟，看下图模拟DOM元素 当旧的DOM发生改变，对比两棵DOM树的标签和值，如果都相等，则不变，如果标签相同，值不同，则修改，这样的新旧两棵树就是模拟DOM树 总结：什么是虚拟DOM 用JS对象的形式，来模拟页面上的DOM嵌套关系，即虚拟DOM是以JS对象的形式存在的 React中虚拟DOM对象的本质和目的： 本质：用JS对象来模拟DOM元素的嵌套关系 目的：实现页面元素的高效更新 Diff算法 tree diff上图中新旧两棵DOM树每一层对比的过程叫做tree diff，当整棵DOM树逐层对比完毕，则所有的按需更新的元素必然能够找到 component diff在进行tree diff的时候，每一层中组件级别的对比，叫做component diff 如果对比前后，组件类型相同，则暂时认为不需要更新组件 如果对比前后，组件类型不同，则需要暂时移除旧组件，创建新组件，追加到页面上 ###element diff 在进行组件对比的时候，如果两个组件类型相同，需要进行元素级别的对比，这叫做element diff]]></content>
      <tags>
        <tag>虚拟DOM与Diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-vuex]]></title>
    <url>%2Fvue-vuex%2F</url>
    <content type="text"><![CDATA[vuex描述本文档对于有一定vue项目环境搭建和配置的相关经验的人会更轻松的理解 什么是 vuex vuex 是 Vue 配套的公共管理数据工具，他可以把一些共享的数据，保存到 vuex 中，方便整个程序中的任何组件直接获取或者修改公共数据 为什么要用vuex下面原始的传值和vuex的区别与优缺点 兄弟组件之间传值定义中间实例vm进行传值，逻辑过于复杂 父子组件之间传值子向父传值，通过事件调用机制，父给子传值通过属性绑定，但如果嵌套过深的传值，难免会产生复杂的逻辑 引入vuexvuex相当于是项目共享数据仓库，全局共享数据存储区域，方便各个组件直接拿来使用，这样就少了很多复杂的逻辑 vuex安装和使用 安装 1npm i vuex -S 导入包到文件 1import Vuex from 'vuex' 注册 1Vue.use(Vuex) 实例化，得到一个数据仓储对象 123456789101112var store = new Vuex.store(&#123; state: &#123; // 可以把 state 对比 vue 组件中的 data ，专门用来存储数据 count: 0 &#125;, mutations: &#123; &#125;, getters: &#123; &#125;&#125;) 将 vuex 创建的实例对象挂载到 vm 实例上 12345const vm = new Vue(&#123; ... // store: store store&#125;) 在需要共享数据的组件中想要去访问 vuex 实例中的数据，需要通过this.$store.count来访问 例子####项目演示地址 git@github.com:ForeManWang/vuex-study.git 可以先去这里下载项目下来，跟着例子操作 创建基本项目结构和搭建vue环境和配置，不多赘述了 下载下来项目之后，在根目录自行安装所有依赖插件 1npm i state这里就是相当于第六步，去components/amount.vue 去访问 vuex 实例中的数据 这时候打开后台，打开页面刷新，发现就已经能够访问 vuex 中的数据了 moutations 操作数据加法需求 去components/counter.vue的methods中写了一个add方法 1&lt;input type="button" value="增加" @click="add"&gt; 1234567add() &#123; // 千万不要这么用，不符合 vuex 的设计理念 // 这种操作数据的方法相当于是自己的组件操作数据，假如数据紊乱，会不知道是谁操作的数据导致了数据紊乱，所以不利于后期维护 // 所以将需求告诉一个 &lt;库管员&gt; 让 &lt;库管员&gt; 去操作 // 这里就是要 vuex 仓库中的 mutations 提供的方法去操作对应的数据，这样假如维护中出现数据紊乱的情况，可以快速定位错误的原因，利于后期维护 this.$store.state.count++; &#125;, 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit(‘方法名’) 所以在components/counter.vue内部就这样调用 12345add() &#123; // 千万不要这么用，不符合 vuex 的设计理念 // this.$store.state.count++; this.$store.commit("increment");&#125;, 减法需求 去components/counter.vue的methods中写了一个remove方法 1&lt;input type="button" value="减少" @click="remove"&gt; 在main.js的moutations中定义 123subtract(state, obj) &#123; state.count -= (obj.c + obj.d)&#125; 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数； 去components/counter.vue中调用，需要传参 12 这样减法就实现了，实现一次性减obj.c + obj.d getters 包装数据 这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations main.js 12345getters: &#123; optCount: function (state) &#123; return '当前最新的count值是: ' + state.count &#125;&#125; counter.vue 123456computed:&#123; fullname: &#123; get()&#123;&#125;, set()&#123;&#125; &#125;&#125; 经过回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者；其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值 总结 state中的数据，不能直接修改，如果想要修改，必须通过mutations 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.*** 如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit(&#39;方法的名称&#39;， 唯一的一个参数) 如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用getters, 如果需要使用 getters ,则用this.$store.getters.***]]></content>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-读取文件方法封装]]></title>
    <url>%2Fnode-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[node读取文件方法封装&amp;Promise准备 一个空js文件和files文件里面放上三个文件，方便下面操作 载入核心模块 12const fs = require('fs')const path = require('path') 需求：封装一个方法，给你一个要读取文件的路径，你这个方法能帮我读取文件，并把内容返回给我 普通方式12345// 这是普通读取文件的方式 fs.readFile(path.join(__dirname, './files/1.txt'), 'utf-8', (err, dataStr) =&gt; &#123; if (err) throw err console.log(dataStr)&#125;) 但是这样达不到需求，所以就有了下面一种方式 简单封装一给一个路径参数fpath 12 由于读取文件是异步操作，不能直接在函数内部return,所以没有接收到返回值，在外部调用就是undefined 所以用callback接收一下 简单封装二封装一个给定文件路径，返回读取到的内容的读取文件的异步方法 12345678910function getFileByPath (fpath, callback) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) throw err // console.log(data) callback(data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), (data) =&gt; &#123; console.log(data) // 111&#125;) 这样基本就达到需求了，但是依然不能知道读取文件数据到底成功还是失败，没有明确的标识 简单封装三所以可以给 callback 规定两个参数，一个失败结果，一个成功结果 同时我们规定，如果成功后，返回结果应该位于 callback 结果的第二个位置，此时第一个结果由于没有出错，所以放一个 null ，如果失败了，则第一个结果放置 error 对象，第二个位置放置一个 undefined 123456789101112function getFileByPath (fpath, callback) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) throw err // console.log(data) callback(null, data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), (err, data) =&gt; &#123; // console.log(data) // 111 if (err) return console.log(err.message) console.log(data)&#125;) 这种情况下，不管成功还是失败，共用的是一个参数（不是很好理解），可以拆分为两个，成功一个回调，失败一个回调，这样更好理解 简单封装四1234567891011function getFileByPath (fpath, succCb, errCb) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) errCb(err) succCb(data) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt'), function (data) &#123; console.log(data + '成功了')&#125;, function (err) &#123; console.log(err.message + '失败了')&#125;) 这样就基本封装完成，达到需求，并提示失败和成功，提升体验 Promise解决回调地狱假如我们使用上一种封装方法，去按顺序读取三个文件files/1.txt、files/2.txt、files/3.txt这样就需要嵌套 1234567891011getFileByPath(path.join(__dirname, './files/1.txt'), function (data) &#123; console.log(data) getFileByPath(path.join(__dirname, './files/2.txt'), function (data) &#123; console.log(data) getFileByPath(path.join(__dirname, './files/3.txt'), function (data) &#123; console.log(data) &#125;) &#125;)&#125;) 假如以上的嵌套有很多，还不止这样三个嵌套呢？就会成这样 这样就形成了回调地狱，由于函数查找变量的规则需要由内至外一层一层去查找，这样难免造成大量的资源浪费 引入Promise来解决回调地狱的问题 Promise介绍Promise是ES6中的一个对象，用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。 在浏览器控制台输入console.dir(Promise)可以看到 我们看图片中两个红框，第一个红框，Promise是一个构造函数 第二个红框是两个回调函数，reject()表示失败执行，resolve()表示成功后执行 点开prototype:Promise发现一个then方法和catch()方法，而then和catch方法和在Promise的原型对象中，所以可以用promise直接调用 Promise解决回调地狱这样就可以封装一个基于Promise读取文件的函数 12345678910const fs = require('fs')function getFileByPath(fpath) &#123; return new Promise (function (resolve, reject) &#123; fs.readFile(fpath, 'utf-8', (err, data) =&gt; &#123; if (err) return reject(err) resolve(data) &#125;) &#125;)&#125; 12345678910111213141516171819202122// 如果 ，前面的 Promise 执行失败，我们不想让后续的Promise 操作被终止，可以为 每个 promise 指定 失败的回调 getFileByPath('./files/11.txt') .then(function (data) &#123; console.log(data) // 读取文件2 return getFileByPath('./files/2.txt') &#125;, function (err) &#123; console.log('这是失败的结果：' + err.message) // return 一个 新的 Promise return getFileByPath('./files/2.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;).then(function (data) &#123; console.log(data) &#125;) 当 我们有这样的需求： 哪怕前面的 Promise 执行失败了，但是，不要影响后续 promise 的正常执行，此时，我们可以单独为 每个 promise，通过 .then 指定一下失败的回调； 有时候，我们有这样的需求，个上面的需求刚好相反：如果 后续的Promise 执行，依赖于 前面 Promise 执行的结果，如果前面的失败了，则后面的就没有继续执行下去的意义了，此时，我们想要实现，一旦有报错，则立即终止所有 Promise的执行。 1234567891011121314151617getFileByPath('./files/1.txt') .then(function (data) &#123; console.log(data) return getFileByPath('./files/22.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;) .catch(function (err) &#123; // catch 的作用： 如果前面有任何的 Promise 执行失败，则立即终止所有 promise 的执行，并 马上进入 catch 去处理 Promise中 抛出的异常； console.log('这是自己的处理方式：' + err.message) &#125;)]]></content>
      <tags>
        <tag>函数封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime添加自定义代码段]]></title>
    <url>%2Fsublime%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[sublime添加自定义代码段一：打来Sublime Text，在菜单栏找到“Tools（工具）”-&gt;”New Snippet（新代码段）” 二：Hello, ${1:this} is a ${2:snippet}.这块代码区域，可以直接删除，然后添加上你所需要的代码段进去，然后Ctrl + s保存，保存到默认文件夹，命名随意，假如你的命名是vuecode，那么你去书写你的代码时就需要通过vuecode来调用这个代码段 三：调用过程： Ctrl + Shift + P ======&gt; Snippet:vuecode =====&gt; enter 这时候代码段就自动添加到你需要的地方了]]></content>
      <tags>
        <tag>sublime添加自定义代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime安装插件&常用的sublime插件]]></title>
    <url>%2Fsublime%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[sublime安装插件&amp;常用的sublime插件其实sublime安装插件并不难，几步操作就好了，关键插件安装过程中总出现各种各样的错误，而且比较好的插件都有哪些呢？ 安装步骤 第一步：下载一个sublime，正版不正版，汉化不汉化的那就按照你个人要求制定就行，网上也有相应教程，我用的是官网的，然后加的汉化包 sublime官网 第二步：打开你的sublime , Ctrl + ` 切换到sublime控制台，控制台一共两块内容区域，第一块区域时监控代码运行进程的，不用管，当然出错也可以从这里查找，第二块区域根据你自己的是sublime2还是sublime3来选择代码复制粘贴进去并运行 sublime3 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) sublime2 1import urllib2,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 第三步：安装完成后，按 Ctrl+Shift+p (Windows)/ Command+Shift+p (Mac), 输入Install Packages，之后Sublime会自动下载插件列表，然后弹出一个小的下拉菜单让你填写想要下载的插件名称。 常见错误这里是我遇到过的一些问题：欢迎大佬们补充 直接无法安装插件网上看了一些文档，说是GWF被墙问题 错误提示如下： 解决办法： 1、开代理自己翻墙 2、直接下载插件，将下载的文件解压到Sublime Text3的Installed Packages目录下 解析错误还有个问题是包解析错误，需要自己去发现错误翻译下看看是不是这一类问题，我忘记错误代码了，这一类问题可能是网络原因，我换了个网，能用了 常用插件推荐下面推荐我安装的一些插件，主要参照了博客sublime常用插件 本文参考博客Package Control]]></content>
      <tags>
        <tag>sublime安装插件&amp;常用的sublime插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记一]]></title>
    <url>%2FES6%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ES6笔记一 ES6的笔记参考ECMAScript 6 入门 部署进度 这里使用阮一峰老师写的一个工具 ES-Checker用来检查各种运行环境对 ES6 的支持情况。访问ruanyf.github.io/es-checker，可以看到您的浏览器支持 ES6 的程度。运行下面的命令，可以查看你正在使用的 Node 环境对 ES6 的支持程度。 1234567$ npm install -g es-checker$ es-checker// 结果=========================================Passes 39 feature DetectionsYour runtime supports 92% of ECMAScript 6========================================= Babel转码器 Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 例子： 1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 Babel的配置文件.babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 1234567891011# 最新转码规则$ npm install --save-dev babel-preset-latest# react 转码规则$ npm install --save-dev babel-preset-react# 不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 然后，将这些规则加入.babelrc。 12345678&#123; &quot;presets&quot;: [ &quot;latest&quot;, &quot;react&quot;, &quot;stage-2&quot; ], &quot;plugins&quot;: []&#125; 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 本来这里想详细总结下各种转码，然后发现阮一峰老师写的是真的详细，请参见ECMAScript 6 入门]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基本属性配置]]></title>
    <url>%2Fwebpack%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack 基本属性配置1234567891011121314151617181920212223242526272829303132333435363738394041const path = require('path')module.exports = &#123; entry: &#123; // main是默认入口，也可以是多入口 main: './src/main.js' &#125;, // 出口 output: &#123; filename: './build.js', // 指定js路径 path: path.join(__dirname, '..', '', 'dist') // 最好是绝对路径 // 代表上一级的dist &#125;, module: &#123; // 一样的功能rules: webpack2.xx新加的 loaders: [ // require('./a.css||./a.js') &#123; test: /\.css$/, loader: 'style-loader!css=loader', //多个loader用!分割 //顺序是反过来的 2!1 多个loader &#125;, &#123; test: /\.(jpg|svg)$/, loaderL 'url-loader?limit=4096&amp;name=[name].[ext]', // limit=4096&amp;name=[name].[ext]' 多个参数之间用&amp;符号分割 //[name].[ext]内置提供的 options: &#123; limit: 4096, name: '[name].[ext]' &#125; &#125; ] &#125;, plugins: [ // 插件的执行顺序是依次执行的，和loader是反过来的 new htmlWebpackPlugin(&#123; template: './src/index.html', &#125;) // 将src下的template属性描述的文件根据当前配置的output.path，将文件移动到该目录。 // 在插件的执行过程中，它本身可以去拿当前所设置的webpack选项，便于对webpack选项的复用， ]&#125;]]></content>
      <tags>
        <tag>webpack配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 中全局变量与形参的赋值]]></title>
    <url>%2Fjavascript-%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BD%A2%E5%8F%82%E7%9A%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[javascript 中全局变量与形参的赋值现象定义数组 12345678var arr1,arr2,arr3;var arr4 = [ &#123;name:'zhangsan',age:'18'&#125;, &#123;name:'lisi',age:'18'&#125;, &#123;name:'wangwu',age:'18'&#125;, &#123;name:'zhaoliu',age:'18'&#125;, &#123;name:'xiaoming',age:'18'&#125;]; 创建一个change函数 123456function change(params)&#123; for(var i = 0; i&lt;params.length;i++)&#123; params[i].name = params[i].name +'miaomiaomiao' &#125; return params &#125; 将arr4赋值给arr1、arr2、arr3并打印，观察打印结果 12345678arr1 = arr4arr2 = arr4arr3 = arr4console.log(change(arr1)) // 对任意一个数组执行change函数console.log(arr4)console.log(arr1)console.log(arr2)console.log(arr3) 以下是打印结果 可以发现，当其中任何一个数组改变时，其他的数组的值也会跟着改变 原因在计算机的内存中，系统对变量的声明在栈中，而值是在堆中 画图理解 arr1 = arr4; arr2 = arr4; arr3 = arr4 的赋值只是将arr4的值的地址指向了arr1，arr2，arr3；内存中并没有为其创建内容空间，这样就导致直接或间接的修改变量的值，那么原始值都将被修改。]]></content>
      <tags>
        <tag>全局变量与形参的赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 中局部变量和形参同名冲突问题]]></title>
    <url>%2Fjavascript-%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%BD%A2%E5%8F%82%E5%90%8C%E5%90%8D%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[javascript 中局部变量和形参同名冲突问题新建一个数组 1234567var arr = [ &#123;name:'zhangsan',age:'18'&#125;, &#123;name:'lisi',age:'18'&#125;, &#123;name:'wangwu',age:'18'&#125;, &#123;name:'zhaoliu',age:'18'&#125;, &#123;name:'xiaoming',age:'18'&#125;] 局部变量和形参冲突的情况 12345678910function getList(i)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr[i].name == 'e')&#123; console.log('已遍历完整个数组') &#125; &#125; return arr[i]&#125;console.log(getList(1)) // undefined// 调用 getList(1)时，其结果并不是 &#123;tel:1234658,name:'b'&#125; , 而是 undefined 解决方法 将形参改变或者将循环体内变量改变一下 12345678910function getList(i) &#123; for(var j = 0; j &lt; arr.length; j++)&#123; if(arr[j].name == 'e')&#123; console.log('已遍历完整个数组') &#125; &#125; return arr[i]&#125;// console.log(getList(1)) // &#123; tel: 1234658, name: 'b' &#125;// 更改 循环体中 i 变量 为 j 结果就是想要的结果了]]></content>
      <tags>
        <tag>局部变量和形参同名冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将本地文件上传到github]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[将本地文件上传到github文件上传 桌面打开git命令面板 新建Git仓库 1git init 添加文件到git 12git add . // 或者下面一种git add README.md 添加此次更新内容描述 12 将本地仓库关联到github上 1git remote add origin git@github.com:ForeManWang/letao.git // 最后面的地址需要填写你自己github的项目地址 将代码上传到github 1git push -u origin master 常见错误执行代码git remote add origin git@github.com:ForeManWang/letao.git时出现错误：fatal: remote origin already exists 解决办法 执行命令 12git remote rm origingit remote add origin git@github.com:ForeManWang/letao.git 这样就解决了，后面再上传项目到github 12 ···]]></content>
      <tags>
        <tag>本地文件上传到github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之seo优化]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8Bseo%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HEXO SEO 优化最近用hexo搭建个人博客，但是去网上搜，搜什么都搜不到自己，这就很尴尬了，于是想到了seo优化，这里主要对google和baidu爬虫的优化 什么是 SEO SEO（Search Engine Optimization）:汉译为搜索引擎优化。是一种方式:利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是：为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力 =&gt;百度百科 建议: 最好一步一测，反正我遇到的坑无数个，由于之前没有一步一测，导致到后来错到哪都不知道，或者开启hexo debug服务命令，这样在本地站点根目会生成一个debug.log文件，就是你的错误日志，可以去查看，具体指令如下： 到站点目录下，开启git命令面板 1hexo s --debug 本地文章优化添加sitemap首先给你的文章生成sitemap文件 123npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎12 然后在站点配置文件_config.yml中添加以下代码(这里我在参考资料《HEXO SEO 高级优化》这篇博客中看到的配置，但是在我的配置里一应用就报错，所以我的没用到，我给注释起来了，具体配置和报错信息如下：) 1234567891011# 自动生成sitemap# sitemap:# path: sitemap.xml# baidusitemap:# path: baidusitemap.xml# 报错信息# =&gt; Error：FATAL duplicated mapping key at line 153, column 1:# ??path: baidusitemap.xml# ^# YAMLException: duplicated mapping key at line 153, column 1:# ??path: baidusitemap.xml 最后修改站点配置文件_config.yml 123456# URL 配置站点## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://qqqww.com # 这里应该更改为你自己的站点地址，我写的是我的root: /permalink: :title/ # 这里简化目录结构，后面也会讲到permalink_defaults: 每次hexo g后都会在/public目录下生成sitemap.xml和baidusitemap.xml，这就是你的站点地图，这里需要将站点地图提交到百度站长之家 添加 roborts.txt文件添加 roborts.txt文件到站点根目录source文件夹下 这里可以参照我的： 12345678910111213141516User-agent: *Allow: /Allow: /archives/Allow: /tags/Allow: /categories/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://qqqww.com/sitemap.xmlSitemap: http://qqqww.com/baidusitemap.xml 百度收录站点登录百度站长平台，在用户中心 =&gt; 站点管理添加你的站点网址 配置完站点属性后，进入最后一步：验证网站。有三种方式：文件验证、HTML标签验证、CNAME验证，文件验证和CNAME验证都比较简单，也有相对应的帮助文本，在此我选择的是HTML标签验证。 在主题的_config.yml文件中，设置：baidu_site_verification: true，如果没有该字段就手动添加。 在themes/next/layout/_partials/head.swig文件中添加下列代码 12345// 每个人的content值都不一致，请注意更换成你的content值&#123;% if theme.baidu_site_verification %&#125; &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;6K5YmdKWEx&quot; /&gt;&#123;% endif %&#125; 配置好后，重新发布站点，在百度站长页面完成验证。 百度链接提交 链接提交工具是网站主动向百度搜索推送数据的工具，本工具可缩短爬虫发现网站链接时间，网站时效性内容建议使用链接提交工具，实时向搜索推送数据。本工具可加快爬虫抓取速度，无法解决网站内容是否收录问题 主动推送 最为快速的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。 安装百度链接提交插件 1npm install hexo-baidu-url-submit --save 123456# 百度链接自动提交baidu_url_submit: count: 6 # 提交最新的链接数量 host: http://lianghuii.com # 在百度站长平台中注册的域名 token: # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 设置deploye 123456deploy: - type: git repo: github: git@github.com:MeanMouse/MeanMouse.github.io.git coding: git@git.coding.net:MeanMouse/blog.git - type: baidu_url_submitter 自动推送 是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。。 在主题配置文件将baidu_push设置为true 在路径themes\next\layout_scripts\下创建baidu_push.swig 文件，文件内容如下 12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) &#123; bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; &#125; else &#123; bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125; sitemap这里将之前生成的sitemap文件提交到百度站长 手动提交 如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度。 手动提交方式比较简单，按照官方提示就会使用 - -(这种方式确实好用，方便) 谷歌收录站点进行这个之前，首先友情提示下大佬们，最好开个vpn用，因为很多涉及谷歌服务，我这里用的是789vpn，网上有很多，可以去找，lantern也能用 打开 Google Search Console，添加博客地址。并进行相关验证,根据提示即可完成认证,认证成功如下： 认证方法其实这里方法和百度的类似，也有三种，我用的是直接下载文件，放到我的站点source目录下，然后我在git命令面板里输入以下指令（下面将这一套指令简称为更新并同步文件指令） 123hexo cleanhexo ghexo d 之后，我去google认证，发现并不能验证成功，后来去站点配置_config.yml下添加了一句代码，和百度的类似 1google-site-verification: true 这样就验证成功了，再去看看，验证成功吧的界面如下（这里用的是参考文档里验证成功的图片，其实都一样，下面发参考文档链接） 验证通过后点进入控制台测试robots.txt文件,没有错误和警告即可 提交 sitemap.xml 文件，点击右上角添加/测试站点地图输入 sitemap.xml 进行测试，测试无误后再提交文件 robots.txt验证和sitemap.xml验证通过，抓取网页，我这里给sitemap.xml和baidusitemap.xml都加进去了，虽然不知道是不是提交一个就可以了….. 输入框留空表示抓取首页，填入 about 表示抓取关于页面，抓取完成后,抓取因为验证原因,可能会有几种状态：完成、部分完成和已重定向等，直接提交就可以。 验证站点是否被收录 谷歌中输入：site:yousite，会有提示：(抓取需要时间。等几分钟) 以上就完成了百度和谷歌的搜索引擎抓取站点的功能 优化结构seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下： 123456# URL 配置站点## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://qqqww.comroot: /permalink: :title/permalink_defaults: 首页标题优化SEO最重要的是你的标题，一般搜索都是搜索你的标题。 更改index.swig文件(your-hexo-site\themes\next\layout); 将下面这段代码： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 这时候你的首页会更符合网站名称 - 网站描述这习惯。 进阶，做了seo优化，把关键词也显示在title标题里，可改成： 1&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125;&#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 注意：别堆砌关键字，整个标题一般不超过80个字符，可以通过chinaz的seo综合查询检查。 关键词与描述搜索引擎除了主要抓取标题外，页面的关键词和描述也会抓取。 在\scaffolds\post.md中添加如下代码，用于生成的文章中添加关键字和描述。 12keywords: description: 在\themes\next\layout_partials\head.swig有如下代码，用于生成文章的keywords。暂时还没找到生成description的位置。 1234567&#123;% if page.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; page.keywords &#125;&#125;&quot; /&gt;&#123;% elif page.tags and page.tags.length %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;&quot; /&gt;&#123;% elif theme.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; theme.keywords &#125;&#125;&quot; /&gt;&#123;% endif %&#125; 然后在\themes\next\layout_macro\post.swig中找到这个位置： 1&#123;% if post.description %&#125; 将以下代码去掉： 1234567&#123;% if post.description %&#125; &#123;&#123; post.description &#125;&#125; &lt;div class=&quot;post-more-link text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; 否则首页的文章摘要就会变成文章的description。 举个例子： 123456789101112---title: HEXO SEO优化方法总结copyright: truetop: 0date: 2018-07-19 21:17:42tags: SEOcategories: Debianpermalink:password:keywords: [HEXO,HEXO SEO优化]description: 总结一下使用Hexo搭建博客后，SEO优化方案的总结，后期会不定期更新。--- nofollow 标签给非友情链接的出站链接添加 “nofollow” 标签，nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 以hexo的NexT主题为例，需要修改两处 一：找到footer.swig，路径在your-hexo-site\themes\next\layout_partials，将下面代码 改成： 将下面代码： 1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; 改成： 1&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt; 二：修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout_macro，将下面代码 1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 改成： 1&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 将下面代码： 1&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt; 改成： 1&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt; 安装nofollow插件 减少出站链接能够有效防止权重分散，hexo有很方便的自动为出站链接添加nofollow的插件。 1npm install hexo-autonofollow --save 该插件会将博客中的出站链接自动加上nofollow属性，例外请在站点配置文件_config.xml中添加如下字段 1234nofollow: enable: true exclude: - https://qqqww.com // 友链地址 这样，例外的链接将不会被加上nofollow属性。 开启SEO优化选项hexo博客next提供了seo优化选项，在主题配置文件_config.yml中有个选项是seo，默认是false，改成true即开启了seo优化，会进行一些seo优化，如改变博文title等，然后相同文件下有个关键字选项keywords，填充上，写博文时最好每篇博文都加上keywords。 我用的是next的主题，把该主题的_config.yml的默认keyword改成你的网址关键词 12# Set default keywords (Use a comma to separate)keywords: &quot;wanggongtou&quot; 开启压缩文件因为hexo生成的文件是静态html，里面占用了大量的空白符。使用gulp进行压缩接口提高访问速度并且降低内存。 使用命令 1234npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --savenpm install gulp-concatnpm install gulp-imagemin 在hexo blog文件夹下创建gulpfile.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var gulp = require(&apos;gulp&apos;), uglify = require(&apos;gulp-uglify&apos;), cssmin = require(&apos;gulp-minify-css&apos;), imagemin = require(&apos;gulp-imagemin&apos;), htmlmin = require(&apos;gulp-htmlmin&apos;), htmlclean = require(&apos;gulp-htmlclean&apos;); concat = require(&apos;gulp-concat&apos;);//JS压缩gulp.task(&apos;uglify&apos;, function() &#123; return gulp.src([&apos;./public/js/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;])//只是排除min.js文件还是不严谨，一般不会有问题，根据自己博客的修改我的修改为return gulp.src([&apos;./public/**/*.js&apos;,&apos;!./public/zuoxi/**/*.js&apos;,,&apos;!./public/radio/**/*.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public/js&apos;));//对应修改为./public即可&#125;);//public-fancybox-js压缩gulp.task(&apos;fancybox:js&apos;, function() &#123; return gulp.src(&apos;./public/vendors/fancybox/source/jquery.fancybox.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public/vendors/fancybox/source/&apos;));&#125;);// 合并 JSgulp.task(&apos;jsall&apos;, function () &#123; return gulp.src(&apos;./public/**/*.js&apos;) // 压缩后重命名 .pipe(concat(&apos;app.js&apos;)) .pipe(gulp.dest(&apos;./public&apos;));&#125;);//public-fancybox-css压缩gulp.task(&apos;fancybox:css&apos;, function() &#123; return gulp.src(&apos;./public/vendors/fancybox/source/jquery.fancybox.css&apos;) .pipe(cssmin()) .pipe(gulp.dest(&apos;./public/vendors/fancybox/source/&apos;));&#125;);//CSS压缩gulp.task(&apos;cssmin&apos;, function() &#123; return gulp.src([&apos;./public/css/main.css&apos;,&apos;!./public/css/*min.css&apos;]) .pipe(cssmin()) .pipe(gulp.dest(&apos;./public/css/&apos;));&#125;);//图片压缩gulp.task(&apos;images&apos;, function() &#123; gulp.src(&apos;./public/uploads/*.*&apos;) .pipe(imagemin(&#123; progressive: false &#125;)) .pipe(gulp.dest(&apos;./public/uploads/&apos;));&#125;);// 压缩 public 目录 html文件 public/**/*.hmtl 表示public下所有文件夹中html，包括当前目录 gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;)) &#125;);gulp.task(&apos;build&apos;, [&apos;uglify&apos;, &apos;cssmin&apos;, &apos;fancybox:js&apos;, &apos;fancybox:css&apos;, &apos;jsall&apos;,&apos;images&apos;]);//, &apos;minify-html&apos; 在根目录下的package.json文件中生成写入scripts: 1&quot;scripts&quot;: &#123;&quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp build&quot;&#125; 这样每次输入npm run build就会自动清理上次生成的文件，然后生成新的文件，最后压缩文件。 站内优化这里就真正的涉及到SEO的相关知识了，对你的文章的结构，描述，关键词进行优化。 title优化搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。 1用法：&lt;title&gt;网站标题&lt;/title&gt; 注意点： 首页title写法：首页的title写法格式一般是“总标题-特别重要的关键词或者一句话含有特别重要关键词的描述”。注意这里的“-”是英文，要问我为什么呢?这个因为互联网不是我们国内开发的，汉语不是标准，计算机只对英语敏感性较高，而对汉语敏感性不太高。 栏目页title写法：栏目页title的写法有两种，关键词名称命名写法是“栏目名称-总名称”，非关键词命名写法是：“栏目名称 栏目关键词-总名称”。 分类列表页的title写法：用关键词为这个栏目起名，然后按照下列顺序填写便可了“分类列表页名称-栏目名称-总名称”。 注意事项： 每个标题应该是根据当前内容设置的独特不重复的。 字数限制。不能太长，要不然搜索引擎结果列表会显示不全。最好不超过 25 个中文字。最好是在 10~20 之间。 切勿堆砌关键词。这是很多人常犯的错误 关键词最好出现在最前面 标题有吸引力。毕竟有吸引力的标题才能让用户点击 连词符的使用。可以使用 |-&gt; 不要使用没有意义的句子 keywords优化主要作用是告诉搜索引擎，这个网站内容是什么。因为，好多站长在keywords堆砌关键词，所以好多搜索引擎不太重视keywords了。建议大家还是认真填写keywords，有的搜索引擎还是很重视的，由于现在词频和密度对于 SEO 影响不大，所以只要保持你的正文中出现 4~6 次关键词就可以了。千万不能堆砌关键词。 注意点： 首页keywords写法：首页keywords按照选定的栏目名称，在首页的keywords中加入总名称、栏目名称和一两个关键词。 栏目keywords写法：栏目的keywords其栏目下所有分类列表的名称列出，加上栏目关键字，写法是“栏目名称,栏目关键字,栏目分类列表名称” 分类列表页keywords写法：将你这个栏目中的主要关键字写入。 Description优化功能让搜索引擎是判断整个页面内容的，当中要写入的内容是你页面内容的简介。description一般不超过100个字符。对于个人站点而言，描述标签最好是一句通顺的句子，如果不能的话，则宁可不要。 注意点： 首页description写法：description的写法就是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍形式，不要只写关键词。 栏目description写法：将栏目的标题、关键字、分类列表名称，尽量的写入description中，仍是尽量写成介绍形式。 分类description写法：是将你这个栏目中的主要关键字写入。 H标签优化H 标签的重要性可能是仅次与页面标签。H1-&gt;H6 的重要性依次降低。 所以建议在页面的 H1 和 H2 标签中混入关键词 图片 ALT 文字优化插入图片的时候会提示输入文字，这个不能敷衍。图片 ALT 文字出现的关键词对页面相关性也有一定的影响。同样的，也不要在 ALT 上堆砌关键词。 内部链接及锚文字优化内部链接对于爬行和收录具有很重要的意义。内部链接对页面关键词相关性也有影响，最主要的就是在内部链接中使用锚文字。 锚文字是告诉搜索引擎被链接页面主题内容的最重要依据之一。我们有时候可能无法控制外部链接的锚文字，但是对于站内的内部链接锚文字我们可以控制。不过有几点需要注意： 适当出现匹配关键词的锚文字 锚文字不能集中导航或者页尾，要分散在正文中 本文参考文档以下三篇 HEXO SEO 高级优化 Hexo Seo优化让你的博客在google搜索排名第一 Hexo SEO设置]]></content>
      <tags>
        <tag>hexo seo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Git安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BGit%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[windows 环境下 Git 安装一、安装：官网下载对应 exe 文件直接安装 我电脑是win10 64位的，这里讲的是在windows下安装的Git 下载地址 下载之后，一直next就可以了 二、配置：配置环境变量 win + r 打开windows运行面板 输入 sysdm.cpl 打开系统属性面板 选择系统属性面板上的高级 选择环境变量 双击path,添加一条你安装git的路径即可，我这里是E:\Develop\Git\Git\cmd 三、检测是否安装成功 到任意位置下，鼠标右键出现Git Bash Here和Git GUI Here即视为成功 四、整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>Git安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装逼路上的小插曲一：博客上传图片无法显示]]></title>
    <url>%2F%E8%A3%85%E9%80%BC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%B0%8F%E6%8F%92%E6%9B%B2%E4%B8%80%EF%BC%9A%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[博客上传图片无法显示有些日子，不知不觉就过去了…… 有些坑，不知不觉就进了，我也很无奈啊 废话不说了，这里参照了————大佬的文档 简单总结下： 站点下配置文件_config.yml修改，找到post_asset_folder(如果没有，自己写一个)，默认值一般是false，修改为true。 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 1npm install https://github.com/CodeFalling/hexo-asset-image --save 安装后再站点根目录下执行命令hexo new &quot;我的测试博客&quot;，在hexo/source/_post文件夹下不仅会生成对应的.md文件，还有一个同名的文件夹，用于存放该文件相关的资源。 1npm new "我的测试博客" 这个时候在写.md文档的时候，只需要图片链接为我的测试博客/[图片名].png即可 这里是利用相对路径解决了这一问题，详细请参照大佬的博客 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>博客上传图片无法显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Github账号注册]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BGithub%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[GitHub账号注册点击进入Github官网 注册之后，登录，创建一个测试项目可以点击右上角红框位置 点击Create repository之后就可以创建一个测试项目了 新建一个分支 分支是用来同时处理存储库不同版本的方法；默认情况下你的存储库会有一个分支master作为主分支 。 输入分支名称，enter即可 在分支上可以进行修改和提交，具体还可以使用Git指令进行项目的下载，修改和上传，如果没有Git的，请参照我同一个系列的另一篇文章，点击hexo搭建个人博客之Git安装 Git的一些指令 本地任意位置打开Git面板 1234Git init // 初始化一个Git仓库，后面可以跟仓库名Git pull git@github.com:ForeManWang/test.git // 上传文件到项目地址，指令后面跟的是项目地址，具体查看方法，下面有Git clone git@github.com:ForeManWang/test.git // 下载文件到本地，指令后面跟的是项目地址，具体查看方法，下面有...... Github项目地址：见下图 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示 本文参考： （https://blog.csdn.net/lezaimemecha/article/details/84969353）]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之Hexo安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[hexo搭建个人博客之Hexo安装什么是hexo一个快速高效的博客框架 安装hexo安装hexo之前，先确认自己必须已经安装了NodeJs和Git和已经拥有了GitHub账号，可以参照以下三篇文章 Git详细安装教程————点击此处 GitHub账号注册详细教程————点击此处 NodeJs详细安装过程和环境配置————点击此处 如果以上步骤已经全部完成，去任意一个位置，右键打开Git面板，输入以下指令 1npm install -g hexo-cli 等待一会，安装之后，继续输入指令 1hexo -v // 有版本号则成功 成功安装之后，就可以创建一个博客了，详细请见hexo搭建个人博客总流程 整个系列文档推荐 hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>hexo安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客之NodeJs安装]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BNodeJs%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[NodeJs 安装与环境配置安装这里只介绍windows环境下的NodeJs安装 这里是官网请点击 图片中左边稳定版，右边最新版 点击，下载，是一个msi文件，直接安装就可以，记住你的安装路径，后面做环境配置 安装之后就可以做配置了 配置不知道怎么做环境配置的点击这里查看,同样的道理 测试打开命令行面板，输入以下指令 1node -v npmnpm即包管理工具，一般安装完NodeJs之后，npm是附带安装上去的，所以，同样的执行命令行命令 1npm --version nvmnvm即版本管理工具，详细参考点击这里 整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示]]></content>
      <tags>
        <tag>NodeJs安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客详细教程]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hexo个人博客一 Git 安装及GitHub账号注册Git详细安装教程————点击此处 GitHub账号注册详细教程————点击此处 二 NodeJS 安装NodeJs详细安装过程和环境配置————点击此处 三 Hexo 安装Hexo基本框架搭建过程————点击此处 四 基本主题next开启GitPages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 登录Github，右上角创建一个项目，也可以参照我的另外一个同系列的文章 hexo搭建个人博客之Github账号注册 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。 点击Create Repository之后，选择settings 进入如下： 找到GitHub Pages找到choose theme 之后进入主题仓库,任意选择一个主题，这里我选择的是这个 此时再去查看settings,会发现GitHub Pages变化如下 现在，我们就可以使用https://UserName.github.io，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)： 备注：由于我的有一个服务已经在开着了，电脑太卡了，这里借用参考文档的图片 创建一个本地博客站点打开windows命令面板，输入以下指令 1hexo init myBlog 测试本地博客12hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 此时打开浏览器，输入 http://localhost:4000/，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)： 同步GitHub，允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地站点的配置_config.yml文件，修改deploy下的配置如下： 1234deploy: type: git // 类型为 git repository: git@github.com:ForeManWang/ForeManWang.github.io.git // 这里写仓库地址 branch: master 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 下载主题-Next(官网)安装Git部署插件12345npm install hexo-deployer-git --save // 有版本号即成功// 部署指令hexo clean // 每次同步之前操作，清理缓存hexo g //将md文档生成博客hexo d //同步到github 下载Next,参考安装包，或直接克隆1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在 Hexo 中有2份主要的配置文件，其名称都是_config.yml。一份是站点配置文件，在站点根目录下另一份是主题配置文件，在主题目录下，比如我们这里用到的是next主题，则在myHexoBlog\themes\next下 打开themes/next/下的_config.yml,查找scheme，可以看到四种不同的风格。去掉#注释，即启用对应的scheme，博主采用Gemini主题，大家可以依次测试效果，选择自己喜欢的scheme。打开根目录下的_config.yml，查找theme字段，将字段改为theme: next(冒号:之后要有空格分隔，否则无效) 之后通过hexo g和hexo s，再在浏览器中访问localhost:4000即可本地预览主题效果。 主题基础配置设置过程中，可运行在本地查看，步骤跟之前一样(注意所有的：后面都要空一格!!!)。 设置菜单找到主题next的_config.yml查找menu`，去掉#注释即可显示对应的菜单项。 设置网站基本信息和语言找到站点的_config.yml，找到Site如下设置。 设置个人信息找到主题next的_config.yml，找到social如下设置。 设置头像进入themes/next/source/uploads下，找到avatar.png，放入一张同样大小的图片替换名字。之后找到主题next的_config.yml，找到avatar如下设置。 更多美化next主题参考请点击next美化主题1-4 hexo seo优化整个系列文档推荐hexo搭建个人博客之Git安装 hexo搭建个人博客之Github账号注册 hexo搭建个人博客之NodeJs安装 hexo搭建个人博客之Hexo安装 hexo搭建个人博客详细教程 装逼路上的小插曲一：博客上传图片无法显示 本文参考文档Hexo搭建个人博客（一）——框架搭建 Hexo搭建个人博客网站详细流程 Hexo博客搭建]]></content>
      <tags>
        <tag>hexo搭建个人博客</tag>
      </tags>
  </entry>
</search>
